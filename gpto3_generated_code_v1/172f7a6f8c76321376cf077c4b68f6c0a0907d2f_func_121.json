{
    "contract_address": "0x172F7a6F8C76321376cf077c4b68f6C0A0907d2f",
    "heimdall_input": "function getDividendsClaimedOf(address arg0) public returns (uint256) {\n        require(arg0 == (address(arg0)));\n        var_a = 0x5cc33f7400000000000000000000000000000000000000000000000000000000;\n        address var_b = address(arg0);\n        (bool success, bytes memory ret0) = address(blacklistEnabled / 0x01).Unresolved_5cc33f74(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_d == (var_d));\n        var_e = var_d;\n        return var_d;\n    }",
    "llm_output": "function getDividendsClaimedOf(address account) public returns (uint256) {\n    // Redundant self-check kept from the original bytecode\n    require(account == address(account));\n\n    // Function selector 0x5cc33f74\n    bytes4 GET_DIVIDENDS_CLAIMED_SELECTOR = 0x5cc33f74;\n\n    // Target contract address (as in the decompiled logic)\n    address target = address(blacklistEnabled / 0x01);\n\n    // Static call to the target contract\n    (bool success, bytes memory returnData) =\n        target.staticcall(abi.encodeWithSelector(GET_DIVIDENDS_CLAIMED_SELECTOR, account));\n\n    // Silence unused\u2010variable warning (the original code ignored `success`)\n    success;\n\n    // Bounds check equivalent to the decompiled expression\n    require(returnData.length >= 32);\n\n    // Decode the returned uint256 value\n    uint256 dividendsClaimed = abi.decode(returnData, (uint256));\n\n    // Another redundant self-equality check preserved from the decompiled code\n    require(dividendsClaimed == dividendsClaimed);\n\n    return dividendsClaimed;\n}",
    "ground_truth": "function getDividendsClaimedOf (address shareholder) external view returns (uint256) {\r\n        return distributor.getDividendsClaimedOf(shareholder);\r\n    }"
}