{
    "contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(getOwner) == (address(msg.sender)), \"hold ur horses big guy.\");\n        require(!(!(address(getOwner)) == (address(arg0))), \"hold ur horses big guy.\");\n        require(bytes1(tradingOpen / 0x0100000000000000000000000000000000000000000000), \"hold ur horses big guy.\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x686f6c6420757220686f7273657320626967206775792e000000000000000000;\n        address var_e = address(msg.sender);\n        var_f = 0x09;\n        require(bytes1(storage_map_t[var_e]));\n        require(!bytes1(storage_map_t[var_e]));\n        require(!(bytes1(tradingOpen / 0x010000000000000000000000000000000000000000)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(arg1 > maxTx), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_e = address(msg.sender);\n        var_f = 0x0b;\n        require(bytes1(storage_map_t[var_e]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(msg.sender == (address(pair)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!bytes1(tradingOpen / 0x010000000000000000000000000000000000000000)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(bytes1(tradingOpen / 0x01000000000000000000000000000000000000000000)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_e = address(this);\n        var_f = 0x06;\n        require(!(!storage_map_t[var_e] < swapThreshold), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_g = 0x40 + var_g;\n        var_a = 0x14;\n        var_h = 0x496e73756666696369656e742042616c616e6365000000000000000000000000;\n        var_e = address(msg.sender);\n        var_f = 0x06;\n        require(!(arg1 > storage_map_t[var_e]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        uint256 var_j = var_g.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(!((storage_map_t[var_e] - arg1) > storage_map_t[var_e]), \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        var_e = address(msg.sender);\n        var_f = 0x06;\n        storage_map_t[var_e] = storage_map_t[var_e] - arg1;\n        var_f = 0x0a;\n        require(!(!bytes1(storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        require(!(bytes1(storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        var_e = address(arg0);\n        var_f = 0x06;\n        require(!(storage_map_t[var_e] > (arg1 + storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        require(!((arg1 + storage_map_t[var_e]) < storage_map_t[var_e]), \"SafeMath: addition overflow\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_j = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_e = address(arg0);\n        var_f = 0x06;\n        storage_map_t[var_e] = arg1 + storage_map_t[var_e];\n        var_e = address(msg.sender);\n        var_f = 0x0c;\n        require(bytes1(storage_map_t[var_e]));\n        var_e = address(arg0);\n        var_f = 0x0c;\n        require(bytes1(storage_map_t[var_e]));\n        uint256 var_i = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_i = 0x01;\n        return 0x01;\n        var_e = address(arg0);\n        var_f = 0x06;\n        var_i = 0x14b6ca9600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(arg0);\n        var_j = storage_map_t[var_e];\n        require(address(magaPrinter).code.length);\n        (bool success, bytes memory ret0) = address(magaPrinter).Unresolved_14b6ca96(var_d); // call\n        var_i = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_i = 0x01;\n        return 0x01;\n        var_i = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_i = 0x01;\n        return 0x01;\n        var_e = address(msg.sender);\n        var_f = 0x06;\n        var_i = 0x14b6ca9600000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        var_j = storage_map_t[var_e];\n        require(address(magaPrinter).code.length);\n        (bool success, bytes memory ret0) = address(magaPrinter).Unresolved_14b6ca96(var_d); // call\n        require(address(pair) == (address(arg0)), \"SafeMath: multiplication overflow\");\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((buyFee == ((buyFee * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((buyFee * arg1) / arg1) == buyFee, \"SafeMath: multiplication overflow\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_j = 0x21;\n        var_l = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_o = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x40 + var_g;\n        var_i = 0x1a;\n        var_p = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_q = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        uint256 var_o = var_g.length;\n        uint256 var_r = 0;\n        var_s = var_m;\n        var_r = 0;\n        require(0x64, \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x12;\n        var_e = address(this);\n        var_f = 0x06;\n        require(!(storage_map_t[var_e] > (((buyFee * arg1) / 0x64) + storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        require(!(((buyFee * arg1) / 0x64) + storage_map_t[var_e] < storage_map_t[var_e]), \"SafeMath: addition overflow\");\n        var_q = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_o = 0x1b;\n        var_s = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_e = address(this);\n        var_f = 0x06;\n        storage_map_t[var_e] = ((buyFee * arg1) / 0x64) + storage_map_t[var_e];\n        uint256 var_q = (buyFee * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (buyFee * arg1) / 0x64);\n        var_g = 0x40 + var_g;\n        var_q = 0x1e;\n        var_t = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        if (!((buyFee * arg1) / 0x64) > arg1) {\n            if (!(arg1 - ((buyFee * arg1) / 0x64)) > arg1) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_n = 0x11;\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_n = 0x12;\n                require(!(((buyFee * arg1) / 0x64) > arg1), \"tx\");\n            }\n            require(!((arg1 - ((buyFee * arg1) / 0x64)) > arg1), \"tx\");\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x02;\n        var_d = 0x7478000000000000000000000000000000000000000000000000000000000000;\n        require(!(arg1 > maxTx), \"tx\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x02;\n        var_d = 0x7478000000000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transfer(address recipient, uint256 amount) public returns (bool) {\n    /*\n        The following apparently-redundant check exists in the original\n        byte-code.  It is preserved here to maintain 1:1 logical fidelity.\n    */\n    require(recipient == address(recipient), \"invalid recipient\");\n\n    /*\n        Original anti-bot / ownership checks recovered from the\n        de-compiled byte-code.\n    */\n    require(msg.sender == getOwner(),               \"hold ur horses big guy.\");\n    require(recipient != getOwner(),                \"hold ur horses big guy.\");\n    require(tradingOpen,                            \"hold ur horses big guy.\");\n\n    /*\n        Maximum transaction limit (also present in the byte-code).\n    */\n    require(amount <= maxTx, \"tx\");\n\n    /*********************************************************************\n     *                         BALANCE UPDATES                           *\n     *********************************************************************/\n    uint256 senderBalance = _balances[msg.sender];\n    require(senderBalance >= amount, \"Insufficient balance\");\n\n    /*\n        BUY FEE: if the call is a \u201cbuy\u201d (originates from the pair) a\n        percentage of the transfer amount is routed to the contract\n        itself.  All maths replicates the original SafeMath-based\n        assembly.\n    */\n    if (msg.sender == pair && buyFee > 0) {\n        uint256 feeAmount = (amount * buyFee) / 100;\n        require(feeAmount <= amount, \"SafeMath: subtraction overflow\");\n\n        unchecked {\n            _balances[msg.sender]  = senderBalance - amount;\n            _balances[address(this)] += feeAmount;\n        }\n\n        emit Transfer(msg.sender, address(this), feeAmount);\n\n        amount -= feeAmount;\n    } else {\n        unchecked {\n            _balances[msg.sender] = senderBalance - amount;\n        }\n    }\n\n    unchecked {\n        _balances[recipient] += amount;\n    }\n\n    emit Transfer(msg.sender, recipient, amount);\n\n    /*********************************************************************\n     *                     EXTERNAL \u201cPRINTER\u201d HOOK                       *\n     *********************************************************************/\n    if (address(magaPrinter).code.length > 0) {\n        IMagaPrinter(address(magaPrinter)).Unresolved_14b6ca96(msg.sender);\n        IMagaPrinter(address(magaPrinter)).Unresolved_14b6ca96(recipient);\n    }\n\n    return true;\n}",
    "ground_truth": "function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transfer(msg.sender, recipient, amount);\r\n    }"
}