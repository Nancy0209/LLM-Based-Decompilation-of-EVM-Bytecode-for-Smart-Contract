{
    "contract_address": "0x51310eD331fB85314977E02B35424dafAe5c741d",
    "heimdall_input": "function withdraw() public {\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        uint256 var_c = 0x60 + var_c;\n        address var_d = storage_map_b[var_a];\n        address var_e = storage_map_c[var_a];\n        address var_f = storage_map_d[var_a];\n        require(var_g > 0, \"withdraw after one week\");\n        require(!(var_h > 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c57f), \"withdraw after one week\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require((var_h + 0x093a80) < block.timestamp, \"withdraw after one week\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_k = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_l = 0x17;\n        var_m = 0x7769746864726177206166746572206f6e65207765656b000000000000000000;\n        var_j = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_k = address(msg.sender);\n        var_l = var_g;\n        require(address(token / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(token / 0x01).{ value: 0 ether }Unresolved_a9059cbb(var_k); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"Address: insufficient balance\");\n        require(var_n == (var_n), \"Address: insufficient balance\");\n        require(var_g == 0, \"Address: insufficient balance\");\n        require(!(sumETH < (var_o)), \"Address: insufficient balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(!((var_g) & ((sumETH - (var_o)) > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / (var_g)))), \"Address: insufficient balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(0x0de0b6b3a7640000, \"Address: insufficient balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x12;\n        require(!(0 == 0), \"Address: insufficient balance\");\n        require(!0x01, \"Address: insufficient balance\");\n        var_c = 0x60 + var_c;\n        var_p = var_h;\n        uint256 var_q = 0;\n        var_r = sumETH;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_f[var_a] = var_n;\n        storage_map_g[var_a] = var_s;\n        storage_map_h[var_a] = var_t;\n        require(!((var_g * (sumETH - (var_o)) / 0x0de0b6b3a7640000) > 0), \"Address: insufficient balance\");\n        require(!(address(this).balance < (var_g * (sumETH - (var_o)) / 0x0de0b6b3a7640000)), \"Address: insufficient balance\");\n        var_u = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_v = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_w = 0x1d;\n        var_x = 0x416464726573733a20696e73756666696369656e742062616c616e6365000000;\n        (bool success, bytes memory ret0) = address(msg.sender).transfer(var_g * (sumETH - (var_o)) / 0x0de0b6b3a7640000);\n        require(ret0.length == 0, \"Address: unable to send value, recipient may have reverted\");\n        var_u = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_v = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_w = 0x3a;\n        var_x = 0x416464726573733a20756e61626c6520746f2073656e642076616c75652c2072;\n        var_y = 0x6563697069656e74206d61792068617665207265766572746564000000000000;\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_k = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_l = 0x12;\n        var_m = 0x4e6f20696e697469616c206465706f7369740000000000000000000000000000;\n    }",
    "llm_output": "function withdraw() public {\n    address user = msg.sender;\n\n    /* Decompiler bookkeeping \u2013 retains arithmetic that has no side-effects */\n    uint256 internalOffset = 0;\n    internalOffset = 0x60 + internalOffset;\n\n    /* Reads preserved for semantic fidelity */\n    address _dummy1 = address(uint160(_mapB[user]));\n    address _dummy2 = address(uint160(_mapC[user]));\n    address _dummy3 = address(uint160(_mapD[user]));\n    _dummy1; _dummy2; _dummy3;               // silence unused-var warnings\n\n    uint256 deposited     = _tokenDeposit[user];\n    uint256 depositedAt   = _depositTimestamp[user];\n\n    /* \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014  Original checks  \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 */\n    require(deposited > 0, \"withdraw after one week\");\n    require(\n        !(depositedAt > 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c57f),\n        \"withdraw after one week\"\n    );\n    require(depositedAt + 604_800 < block.timestamp, \"withdraw after one week\");\n\n    /* \u2014\u2014\u2014 ERC-20 transfer back to caller \u2014\u2014\u2014 */\n    require(address(token).code.length > 0, \"Address: call to non-contract\");\n\n    (bool callSucceeded, bytes memory tokenRet) = address(token).call(\n        abi.encodeWithSelector(IERC20.transfer.selector, user, deposited)\n    );\n    require(callSucceeded, \"Token transfer failed\");\n\n    internalOffset += uint256(uint248(tokenRet.length + 0x1f));\n\n    require(\n        !(((internalOffset + tokenRet.length) - internalOffset) < 0x20),\n        \"Address: insufficient balance\"\n    );\n\n    bool transferResult;\n    if (tokenRet.length >= 32) {\n        transferResult = abi.decode(tokenRet, (bool));\n    }\n\n    require(transferResult == transferResult, \"Address: insufficient balance\");\n\n    /* Conflicting check kept exactly as in byte-code */\n    require(deposited == 0, \"Address: insufficient balance\");\n\n    uint256 placeholder_o = 0;   // var_o in decompiled output\n    require(!(sumETH < placeholder_o), \"Address: insufficient balance\");\n\n    require(\n        !(\n            (deposited &\n                ((sumETH - placeholder_o) > (type(uint256).max / deposited)))\n        ),\n        \"Address: insufficient balance\"\n    );\n\n    require(1 ether != 0, \"Address: insufficient balance\");\n\n    /* Two byte-code constructs that always revert have been collapsed\n       into a dedicated revert, as required by the transformation rules. */\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function withdraw() external {\\n\\t\\tShare memory share = shares[msg.sender];\\n\\t\\trequire(share.initialDeposit > 0, \\\"No initial deposit\\\");\\n\\t\\trequire(share.depositTime + 1 weeks < block.timestamp, \\\"withdraw after one week\\\");\\n\\t\\ttoken.transfer(msg.sender, share.initialDeposit);\\n\\t\\t_payoutGainsUpdateShare(msg.sender, share, 0, true);\\n\\t}"
}