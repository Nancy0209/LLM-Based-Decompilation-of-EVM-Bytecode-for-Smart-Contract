{
    "contract_address": "0x09c7dBaE0F40CBAA2BBd329397f1c5A64726a04a",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!(bytes1(limitOn / 0x01000000)), \"Blacklisted\");\n        require(!(!(address(pair)) == (address(arg0))), \"Blacklisted\");\n        require((sellFee == ((sellFee * arg1) / arg1)) | !arg1, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(0x64, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require((burnFee == ((burnFee * arg1) / arg1)) | !arg1, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(0x64, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!((arg1 - ((sellFee * arg1) / 0x64)) > arg1), \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!((arg1 - ((sellFee * arg1) / 0x64)) - ((burnFee * arg1) / 0x64) > (arg1 - ((sellFee * arg1) / 0x64))), \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(address(msg.sender), \"Blacklisted\");\n        require(address(limitOn / 0x0100000000), \"Blacklisted\");\n        address var_a = address(limitOn / 0x0100000000);\n        var_c = 0x0b;\n        require(!(!bytes1(storage_map_b[var_a])), \"Blacklisted\");\n        require(!(bytes1(storage_map_b[var_a])), \"Blacklisted\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x0b;\n        var_g = 0x426c61636b6c6973746564000000000000000000000000000000000000000000;\n        require(bytes1(limitOn), \"Presale tokens are currently frozen.\");\n        require(bytes1(limitOn / 0x0100), \"Presale tokens are currently frozen.\");\n        require(bytes1(limitOn / 0x0100), \"Presale tokens are currently frozen.\");\n        require(!(bytes1(limitOn / 0x010000)), \"Presale tokens are currently frozen.\");\n        require(!(address(pair) == (address(msg.sender))), \"Presale tokens are currently frozen.\");\n        require(!(bytes1(requiredTokenRuleOn)), \"Presale tokens are currently frozen.\");\n        require(!(address(pair) == (address(limitOn / 0x0100000000))), \"Presale tokens are currently frozen.\");\n        require(!(bytes1(presaleHolderLock)), \"Presale tokens are currently frozen.\");\n        var_a = address(msg.sender);\n        var_c = 0x0f;\n        require(!storage_map_b[var_a], \"Presale tokens are currently frozen.\");\n        var_a = address(msg.sender);\n        var_c = 0x0f;\n        uint256 var_c = 0;\n        require(!(storage_map_b[var_a] - ((sellFee * arg1) / 0x64) > storage_map_b[var_a]), \"Presale tokens are currently frozen.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(storage_map_b[var_a] - ((sellFee * arg1) / 0x64) < storage_map_b[var_a]), \"Presale tokens are currently frozen.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x50726573616c6520746f6b656e73206172652063757272656e746c792066726f;\n        var_h = 0x7a656e2e00000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_c = 0;\n        require(!(storage_map_b[var_a] < ((sellFee * arg1) / 0x64)), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_c = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - ((sellFee * arg1) / 0x64);\n        var_a = address(limitOn / 0x0100000000);\n        storage_map_b[var_a] = ((sellFee * arg1) / 0x64) + storage_map_b[var_a];\n        uint256 var_d = (sellFee * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(limitOn / 0x0100000000), (sellFee * arg1) / 0x64);\n        require(address(msg.sender), \"ERC20: burn from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x21;\n        var_g = 0x45524332303a206275726e2066726f6d20746865207a65726f20616464726573;\n        var_h = 0x7300000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_e = address(msg.sender);\n        (bool success, bytes memory ret0) = address(requiredToken).Unresolved_70a08231(var_e); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!(((var_i + ret0.length) - var_i) < 0x20), \"Insufficient Finale balance in wallet to sell.\");\n        require(!(var_i.length < requiredTokenAmount), \"Insufficient Finale balance in wallet to sell.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x2e;\n        var_h = 0x496e73756666696369656e742046696e616c652062616c616e636520696e2077;\n        var_k = 0x616c6c657420746f2073656c6c2e000000000000000000000000000000000000;\n        if (!requiredTokenRuleOn) {\n        }\n        var_a = address(limitOn / 0x0100000000);\n        var_c = 0;\n        require(!(storage_map_b[var_a] > (((sellFee * arg1) / 0x64) + storage_map_b[var_a])), \"Max holding amount exceeded\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(((sellFee * arg1) / 0x64) + storage_map_b[var_a] > maxHoldingAmount), \"Max holding amount exceeded\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4d617820686f6c64696e6720616d6f756e742065786365656465640000000000;\n        if (!limitOn / 0x010000) {\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x13;\n        var_g = 0x53656c6c696e67206e6f7420656e61626c656400000000000000000000000000;\n        require(address(owner) == (address(msg.sender)), \"Trading not enabled\");\n        require(address(owner) == (address(limitOn / 0x0100000000)), \"Trading not enabled\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x13;\n        var_g = 0x54726164696e67206e6f7420656e61626c656400000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "pragma solidity ^0.8.20;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract DecompiledToken {\n    mapping(address => uint256) private _balances;\n\n    uint256 public limitOn;\n    uint256 public sellFee;\n    uint256 public burnFee;\n    address public pair;\n    IERC20 public requiredToken;\n    bool public requiredTokenRuleOn;\n    uint256 public requiredTokenAmount;\n    bool public presaleHolderLock;\n    uint256 public maxHoldingAmount;\n    address public owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function transfer(address recipient, uint256 amount) public payable {\n        /* ------------------------------------------------------------------ */\n        /*  Black-list style checks                                           */\n        /* ------------------------------------------------------------------ */\n\n        require(recipient == address(recipient), \"Blacklisted\");\n\n        require(bytes1(uint8(limitOn / 0x01000000)) == 0x00, \"Blacklisted\");\n        require(pair != recipient, \"Blacklisted\");\n\n        require(\n            amount == 0 || ((sellFee * amount) / amount) == sellFee,\n            \"Blacklisted\"\n        );\n\n        /* require(0x64, \u2026) -> always true in original byte-code */\n        require(uint256(0x64) != 0, \"Blacklisted\");\n\n        require(\n            amount == 0 || ((burnFee * amount) / amount) == burnFee,\n            \"Blacklisted\"\n        );\n\n        /* require(0x64, \u2026) -> always true in original byte-code */\n        require(uint256(0x64) != 0, \"Blacklisted\");\n\n        require(\n            !(amount - ((sellFee * amount) / 100) > amount),\n            \"Blacklisted\"\n        );\n\n        require(\n            !(\n                (amount - ((sellFee * amount) / 100)) -\n                    ((burnFee * amount) / 100) >\n                (amount - ((sellFee * amount) / 100))\n            ),\n            \"Blacklisted\"\n        );\n\n        require(msg.sender != address(0), \"Blacklisted\");\n\n        address feeRecipient = address(uint160(limitOn / 0x0100000000));\n        require(feeRecipient != address(0), \"Blacklisted\");\n\n        /* Intentional contradictory checks preserved from byte-code */\n        require(_balances[feeRecipient] != 0, \"Blacklisted\");\n        require(_balances[feeRecipient] == 0, \"Blacklisted\");\n\n        /* ------------------------------------------------------------------ */\n        /*  Presale freeze checks                                             */\n        /* ------------------------------------------------------------------ */\n\n        require(\n            bytes1(uint8(limitOn)) != 0x00,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            bytes1(uint8(limitOn / 0x0100)) != 0x00,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            bytes1(uint8(limitOn / 0x0100)) != 0x00,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            bytes1(uint8(limitOn / 0x010000)) == 0x00,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            pair != msg.sender,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            bytes1(uint8(requiredTokenRuleOn ? 1 : 0)) == 0x00,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            pair != feeRecipient,\n            \"Presale tokens are currently frozen.\"\n        );\n        require(\n            bytes1(uint8(presaleHolderLock ? 1 : 0)) == 0x00,\n            \"Presale tokens are currently frozen.\"\n        );\n\n        /* ------------------------------------------------------------------ */\n        /*  Sender balance checks                                             */\n        /* ------------------------------------------------------------------ */\n\n        require(\n            _balances[msg.sender] != 0,\n            \"Presale tokens are currently frozen.\"\n        );\n\n        require(\n            !(_balances[msg.sender] -\n                ((sellFee * amount) / 100) >\n                _balances[msg.sender]),\n            \"Presale tokens are currently frozen.\"\n        );\n\n        require(\n            !(_balances[msg.sender] -\n                ((sellFee * amount) / 100) <\n                _balances[msg.sender]),\n            \"Presale tokens are currently frozen.\"\n        );\n\n        require(\n            _balances[msg.sender] >= ((sellFee * amount) / 100),\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        /* ------------------------------------------------------------------ */\n        /*  Fee transfer                                                      */\n        /* ------------------------------------------------------------------ */\n\n        _balances[msg.sender] =\n            _balances[msg.sender] -\n            ((sellFee * amount) / 100);\n        _balances[feeRecipient] =\n            _balances[feeRecipient] +\n            ((sellFee * amount) / 100);\n\n        emit Transfer(\n            msg.sender,\n            feeRecipient,\n            (sellFee * amount) / 100\n        );\n\n        /* ------------------------------------------------------------------ */\n        /*  Burn checks (logic preserved)                                     */\n        /* ------------------------------------------------------------------ */\n\n        require(\n            msg.sender != address(0),\n            \"ERC20: burn from the zero address\"\n        );\n\n        /* ------------------------------------------------------------------ */\n        /*  Required-token balance check                                      */\n        /* ------------------------------------------------------------------ */\n\n        uint256 tokenBalance = requiredToken.balanceOf(msg.sender);\n        require(\n            tokenBalance >= requiredTokenAmount,\n            \"Insufficient Finale balance in wallet to sell.\"\n        );\n\n        if (!requiredTokenRuleOn) {\n            /* Empty branch preserved */\n        }\n\n        /* ------------------------------------------------------------------ */\n        /*  Max-holding check                                                 */\n        /* ------------------------------------------------------------------ */\n\n        require(\n            !(\n                _balances[feeRecipient] >\n                ((sellFee * amount) / 100 + _balances[feeRecipient])\n            ),\n            \"Max holding amount exceeded\"\n        );\n\n        require(\n            !(\n                ((sellFee * amount) / 100 + _balances[feeRecipient]) >\n                maxHoldingAmount\n            ),\n            \"Max holding amount exceeded\"\n        );\n\n        if ((limitOn / 0x010000) == 0) {\n            /* Empty branch preserved */\n        }\n\n        /* ------------------------------------------------------------------ */\n        /*  Trading enabled checks                                            */\n        /* ------------------------------------------------------------------ */\n\n        require(owner == msg.sender, \"Trading not enabled\");\n        require(owner == feeRecipient, \"Trading not enabled\");\n\n        /* Additional constant data assignments from the byte-code were       */\n        /* artefacts and are intentionally omitted as they have no effect.    */\n    }\n}",
    "ground_truth": "function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}"
}