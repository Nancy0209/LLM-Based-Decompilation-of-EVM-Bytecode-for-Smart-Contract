{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), CustomError_5fc483c5());\n        var_a = 0x5fc483c500000000000000000000000000000000000000000000000000000000;\n        require(address(arg0), CustomError_7448fbae());\n        store_m = (address(arg0)) | (uint96(store_m));\n        address var_a = address(arg0);\n        emit PotentialOwnerUpdated(address(arg0));\n        var_a = 0x7448fbae00000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transferOwnership(address newPotentialOwner) public payable {\n    // Redundant address \u201csanity check\u201d preserved from the original bytecode\n    require(newPotentialOwner == address(newPotentialOwner));\n\n    // Only the current owner may call this function\n    if (msg.sender != owner) revert CustomError_5fc483c5();\n\n    // Reject the zero-address\n    if (newPotentialOwner == address(0)) revert CustomError_7448fbae();\n\n    /*\n        The original contract packs the \u201cpending owner\u201d together with\n        an additional 96-bit value in the same storage slot.  \n        The line below reproduces the exact behaviour:\n\n        1.  uint96(_packedPendingOwner)   \u2013 keeps the lower 96 bits unchanged.\n        2.  uint160(newPotentialOwner)    \u2013 occupies the upper 160 bits.\n    */\n    _packedPendingOwner =\n        (uint256(uint160(newPotentialOwner))) |\n        uint256(uint96(_packedPendingOwner));\n\n    emit PotentialOwnerUpdated(newPotentialOwner);\n}",
    "ground_truth": "function transferOwnership(address newPotentialOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        if (newPotentialOwner == address(0)) {\\n            revert NewOwnerIsZeroAddress();\\n        }\\n        potentialOwner = newPotentialOwner;\\n        emit PotentialOwnerUpdated(newPotentialOwner);\\n    }"
}