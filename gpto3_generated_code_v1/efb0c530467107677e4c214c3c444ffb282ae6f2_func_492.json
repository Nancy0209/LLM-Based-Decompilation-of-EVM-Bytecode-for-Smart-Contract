{
    "contract_address": "0xEFB0c530467107677E4C214c3C444fFb282AE6F2",
    "heimdall_input": "function getBalanceERC20(uint256 arg0) public returns (uint256) {\n        require(arg0 < store_e);\n        var_a = 0x0b;\n        var_b = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_c = address(this);\n        (bool success, bytes memory ret0) = address(storage_map_f[arg0 * 0x02]).Unresolved_70a08231(var_c); // staticcall\n        uint256 var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!((var_d + ret0.length) - var_d) < 0x20);\n        uint256 var_e = var_d.length;\n        return var_d.length;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n    }",
    "llm_output": "function getBalanceERC20(uint256 tokenIndex) public view returns (uint256) {\n    // Original logic: require(tokenIndex < store_e);\n    require(tokenIndex < tokenCount, \"Index out of range\");\n\n    // Original mapping access: storage_map_f[tokenIndex * 0x02]\n    address tokenAddress = tokenAddresses[tokenIndex * 2];\n\n    // calldata for balanceOf(address(this))\n    bytes memory payload = abi.encodeWithSelector(0x70a08231, address(this));\n\n    // Original code used .staticcall without an explicit success check\n    (bool /*success*/, bytes memory returnData) = tokenAddress.staticcall(payload);\n\n    // Original check: require(!((var_d + returnData.length) - var_d) < 0x20);\n    // which simplifies to: require(returnData.length >= 32);\n    require(returnData.length >= 32, \"Invalid return size\");\n\n    uint256 balance;\n    assembly {\n        balance := mload(add(returnData, 32))\n    }\n\n    return balance;\n}",
    "ground_truth": "function getBalanceERC20(uint256 _pid) public view returns (uint256) {\\n        TokenInfo storage tokens = AllowedCrypto[_pid];\\n        IERC20 paytoken;\\n        paytoken = tokens.paytoken;\\n        return paytoken.balanceOf(address(this)); //Return the contract balance\\n    }"
}