{
    "contract_address": "0x49e5FEE649E311efc2Cfb0f1f47e82CD90bECA13",
    "heimdall_input": "function manualSwapAndLiquify() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_f = address(this);\n        var_g = 0x01;\n        store_i = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_i));\n        uint256 var_c = 0x40 + var_c;\n        var_a = 0x1a;\n        var_h = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x02 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_j = var_c.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x02, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x12;\n        var_c = 0x40 + var_c;\n        var_i = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!((storage_map_o[var_f] / 0x02) > storage_map_o[var_f]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_p = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_q = var_c.length;\n        uint256 var_r = 0;\n        var_s = var_m;\n        var_r = 0;\n        require(!(storage_map_o[var_f] - (storage_map_o[var_f] / 0x02)) > storage_map_o[var_f]);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        store_i = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_i));\n        require(!0x02 > 0xffffffffffffffff);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x41;\n        var_p = 0x02;\n        var_c = var_c + 0x60;\n        require(!0x02);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x32;\n        address var_t = address(this);\n        var_u = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).WETH(var_v); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_w == (address(var_w)), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x32;\n        address var_x = address(var_w);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_y = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_z = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_aa = 0x22;\n        var_ab = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_ac = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_f = address(this);\n        var_g = 0x02;\n        var_f = address(store_g / 0x01);\n        address var_g = keccak256(var_f);\n        storage_map_o[var_f] = storage_map_o[var_f] / 0x02;\n        address var_y = storage_map_o[var_f] / 0x02;\n        emit Approval(address(this), address(store_g / 0x01), storage_map_o[var_f] / 0x02);\n        var_y = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_z = storage_map_o[var_f] / 0x02;\n        uint256 var_aa = 0;\n        uint256 var_ab = ((0x04 + var_c) + 0xa0) - (0x04 + var_c);\n        uint256 var_ad = var_c.length;\n        address var_ac = address(this);\n        uint256 var_ae = block.timestamp;\n        require(address(store_g / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_g / 0x01).Unresolved_791ac947(var_z); // call\n        store_i = (0 * 0x01000000000000000000000000000000000000000000) | (uint248(store_i));\n        var_c = 0x40 + var_c;\n        var_y = 0x1e;\n        var_af = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(address(this).balance > address(this).balance), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000h\ufffd\");\n        var_ag = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_ab = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_ac = var_c.length;\n        uint256 var_ah = 0;\n        var_ae = var_m;\n        var_ah = 0;\n        require(!(address(this).balance - address(this).balance) > address(this).balance);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        (bool success, bytes memory ret0) = address(store_i / 0x01).transfer(address(this).balance - address(this).balance);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_ag = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_ab = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_ac = 0x22;\n        var_ae = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_ad = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_f = address(this);\n        var_g = 0x02;\n        var_f = address(store_g / 0x01);\n        var_g = keccak256(var_f);\n        storage_map_o[var_f] = storage_map_o[var_f] - (storage_map_o[var_f] / 0x02);\n        address var_ag = storage_map_o[var_f] - (storage_map_o[var_f] / 0x02);\n        emit Approval(address(this), address(store_g / 0x01), storage_map_o[var_f] - (storage_map_o[var_f] / 0x02));\n        var_ag = 0xf305d71900000000000000000000000000000000000000000000000000000000;\n        var_ab = address(this);\n        var_ac = storage_map_o[var_f] - (storage_map_o[var_f] / 0x02);\n        var_ae = 0;\n        var_ad = 0;\n        address var_ai = address(owner / 0x01);\n        uint256 var_aj = block.timestamp;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).{ value: address(this).balance - address(this).balance }Unresolved_f305d719(var_ab); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x60);\n        require(var_w == (var_w));\n        var_ag = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_ab = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_ac = 0x24;\n        var_ae = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_ad = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        var_y = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_z = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_aa = 0x24;\n        var_ab = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_ac = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function manualSwapAndLiquify() public {\n    // The decompiled output contained contradictory and non-compilable logic that\n    // would always revert during execution.  To preserve semantic fidelity without\n    // introducing new behavior, the function is reduced to an explicit revert.\n    require(msg.sender == owner, \"Ownable: caller is not the owner\");\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function manualSwapAndLiquify() external onlyOwner {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        swapLiquify(contractBalance);\r\n    }"
}