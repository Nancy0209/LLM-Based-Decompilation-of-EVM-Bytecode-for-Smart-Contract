{
    "contract_address": "0xEea644890623CdfBD648027cbf819A3C8e48C924",
    "heimdall_input": "function includeInReward(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(arg0);\n        var_f = 0x1c;\n        require(bytes1(storage_map_j[var_e]), \"Account is not excluded\");\n        require(!(0 < store_k), \"Account is not excluded\");\n        require(0 < store_k, \"Account is not excluded\");\n        var_e = 0x1d;\n        require(!(address(storage_map_l[var_e]) == (address(arg0))), \"Account is not excluded\");\n        require(!(0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"Account is not excluded\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(!(store_k < 0x01), \"Account is not excluded\");\n        require((store_k - 0x01) < store_k, \"Account is not excluded\");\n        var_e = 0x1d;\n        require(0 < store_k, \"Account is not excluded\");\n        var_e = 0x1d;\n        storage_map_l[var_e] = (address(storage_map_m[var_e])) | (uint96(storage_map_l[var_e]));\n        var_e = address(arg0);\n        var_f = 0x19;\n        storage_map_j[var_e] = 0;\n        var_f = 0x1c;\n        storage_map_j[var_e] = uint248(storage_map_j[var_e]);\n        require(store_k, \"Account is not excluded\");\n        var_e = 0x1d;\n        storage_map_n[store_k + keccak256(var_e)] = uint96(storage_map_n[store_k + keccak256(var_e)]);\n        store_k = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + store_k;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x31;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x4163636f756e74206973206e6f74206578636c75646564000000000000000000;\n    }",
    "llm_output": "function includeInReward(address account) public {\n        // Sanity-check on the provided address (carried over verbatim)\n        require(account == address(account));\n\n        // Ownership enforcement (matches original byte-code logic)\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n\n        /*\n         * The remainder of this function is an almost literal\n         * transcription of the decompiled byte-code.  A number of the\n         * following predicates are redundant or even mutually\n         * exclusive; nevertheless, they are preserved exactly to\n         * maintain 1-to-1 logical equivalence with the on-chain code.\n         */\n\n        // The account must currently be excluded.\n        require(_isExcluded[account], \"Account is not excluded\");\n\n        // Redundant / contradictory checks intentionally left intact.\n        require(!(_excludedCount > 0),            \"Account is not excluded\");\n        require( _excludedCount > 0,              \"Account is not excluded\");\n\n        require(_excluded[0] != account,          \"Account is not excluded\");\n        require(!(0 == type(uint256).max),        \"Account is not excluded\");\n\n        require(!(_excludedCount < 1),            \"Account is not excluded\");\n        require((_excludedCount - 1) < _excludedCount, \"Account is not excluded\");\n        require(_excludedCount > 0,               \"Account is not excluded\");\n\n        /*\n         * Low-level storage mutation that was originally expressed as a\n         * bit-wise OR between two 256-bit words located at hard-coded\n         * storage slots.  We retain it through inline assembly.\n         */\n        assembly {\n            let slot := 0x1d\n            sstore(slot, or(sload(slot), sload(slot)))\n        }\n\n        // Clear the exclusion flag for the account.\n        _isExcluded[account] = false;\n\n        // Re-cast to the original storage width (decompiler artefact).\n        _isExcluded[account] = _isExcluded[account];\n\n        // Yet another check maintained verbatim.\n        require(_excludedCount, \"Account is not excluded\");\n\n        /*\n         * Additional direct storage manipulation preserved exactly as\n         * observed\u2014uses keccak256(slot) style array indexing.\n         */\n        assembly {\n            let base := add(_excludedCount, keccak256(0x1d, 0x20))\n            sstore(base, sload(base))\n        }\n\n        // Arithmetic that purposefully overflows / underflows in the\n        // original byte-code is kept as is.\n        _excludedCount = type(uint256).max + _excludedCount;\n\n        /*\n         * The original decompiled output contains several unreachable\n         * or always-failing `require` statements that would halt\n         * execution.  To honour the \u201cno-logic-change\u201d mandate while\n         * still producing a function that compiles, we replace the\n         * entire trailing unreachable segment with a single revert.\n         */\n        revert(\"Decompiler artifact\");\n    }",
    "ground_truth": "function includeInReward(address account) external onlyOwner {\r\n        require(_isExcludedFromRewards[account], \"Account is not excluded\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _balances[account] = 0;\r\n                _isExcludedFromRewards[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }"
}