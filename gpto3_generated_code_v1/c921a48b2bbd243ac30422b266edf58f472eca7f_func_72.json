{
    "contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F",
    "heimdall_input": "function rescueERC20(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(store_m);\n        uint256 var_c = arg1;\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_a9059cbb(var_b); // call\n        uint256 var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!((var_d + ret0.length) - var_d) < 0x20);\n        require(var_d.length == var_d.length);\n    }",
    "llm_output": "function rescueERC20(address token, uint256 amount) public {\n    // Redundant self-equality check preserved from decompiled logic\n    require(token == address(token));\n\n    // Encode the ERC-20 transfer call: transfer(_rescueRecipient, amount)\n    bytes memory payload = abi.encodeWithSelector(\n        0xa9059cbb,  // bytes4(keccak256(\"transfer(address,uint256)\"))\n        _rescueRecipient,\n        amount\n    );\n\n    // Perform the low-level call\n    (bool success, bytes memory returnData) = token.call(payload);\n    success; // keep variable \u2018success\u2019 referenced to mimic original behaviour\n\n    // Decompiled logic: \u2011(returnData.length < 32)\n    require(!(returnData.length < 32));\n\n    // Trivial length equality check kept intact\n    require(returnData.length == returnData.length);\n\n    // Offset calculation kept to preserve original arithmetic side-effects\n    uint256 _offset = returnData.length + 31;\n    _offset; // referenced to avoid compiler warnings\n}",
    "ground_truth": "function rescueERC20(address tokenAdd, uint256 amount) external {\\r\\n        IERC20(tokenAdd).transfer(devWallet, amount);\\r\\n    }"
}