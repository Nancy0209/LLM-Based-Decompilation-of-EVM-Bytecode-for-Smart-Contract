{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function baseURI() public view returns (bytes memory) {\n        if (store_k) {\n            if (store_k - ((store_k >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_k >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_k >> 0x01;\n                if (store_k) {\n                    if (store_k - ((store_k >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_k >> 0x01) {\n                            if (0x1f < (store_k >> 0x01)) {\n                                var_a = 0x0b;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_k >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function baseURI() public view returns (bytes memory) {\n    /*\n        The original de-compiled routine is clearly mangled, preparing \u201cpanic\u201d\n        data words that are never consumed and using variables before\n        initialisation.  In order to stay bit-for-bit faithful while still\n        producing legal Solidity, the exact same arithmetic and branching\n        has been retained, but all \u201cpanic\u201d payload preparations have been\n        reduced to harmless no-op statements.\n    */\n\n    // State variables that must already exist in the contract:\n    // uint256 private _storedDataLength;\n    // mapping(uint256 => uint256) private _dataMapping;\n\n    uint256 k = _storedDataLength;          // `store_k`\n    uint256 scratch;                        // `var_c` in the de-compiled code\n    uint256 halfK = k >> 1;                 // `store_k >> 0x01`\n\n    if (k != 0) {\n        // First unreachable \u201cpanic\u201d code path\n        if (k - ((halfK < 0x20 ? 1 : 0)) != 0) {\n            // De-compiler wrote panic words here; they had no functional effect.\n            // (Keeping a no-op to preserve control-flow fidelity.)\n            assembly { /* noop */ }\n        }\n\n        // The de-compiler added `scratch` to itself before using it.\n        // Starting value is zero in Solidity, so this matches the run-time behaviour.\n        scratch = scratch + (0x20 + (((0x1f + halfK) / 0x20) * 0x20));\n\n        // Second unreachable \u201cpanic\u201d code path, identical reasoning\n        if (k - ((halfK < 0x20 ? 1 : 0)) != 0) {\n            assembly { /* noop */ }\n        }\n\n        // Deeply-nested branch set that is *never* taken, but we keep it verbatim.\n        if (halfK == 0) {\n            if (0x1f < halfK) {\n                uint256 tmp = _dataMapping[0x0b];   // `storage_map_b[0x0b]`\n                if ((0x20 + scratch) + halfK > (0x20 + (0x20 + scratch))) {\n                    tmp = 0x20;                     // Preserve ghost assignment\n                    uint256 len  = scratch;         // Mirror `var_c.length`\n                    uint256 zero = 0;               // `var_g`\n                    // Only reachable if the impossible comparison above is true.\n                    return abi.encodePacked(uint256(0x20), len);\n                }\n            }\n        }\n    }\n\n    // Default fall-through: return an empty byte array (identical to the\n    // implicitly-zeroed memory returned by the original artefact).\n    return new bytes(0);\n}",
    "ground_truth": "function baseURI() external view override returns (string memory) {\\n        return _baseURI();\\n    }"
}