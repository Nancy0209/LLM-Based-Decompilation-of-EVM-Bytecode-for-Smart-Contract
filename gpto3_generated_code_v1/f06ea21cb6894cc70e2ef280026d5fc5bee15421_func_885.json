{
    "contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421",
    "heimdall_input": "function farm(uint256 arg0, uint256 arg1) public payable {\n        require(0x01 == (bytes1(isStakingAvilable)), \"Invalid amount\");\n        require(!(arg0 < minimumDeposit), \"Invalid amount\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0e;\n        var_d = 0x496e76616c696420616d6f756e74000000000000000000000000000000000000;\n        uint256 var_e = arg1;\n        var_f = 0x02;\n        require(storage_map_c[var_e]);\n        var_a = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        address var_c = address(this);\n        uint256 var_d = arg0;\n        require(address(Token).code.length);\n        (bool success, bytes memory ret0) = address(Token).{ value: 0 ether }Unresolved_23b872dd(var_b); // call\n        uint256 var_g = var_g + (uint248(ret0.length + 0x1f));\n        require(!((var_g + ret0.length) - var_g) < 0x20);\n        require(var_g.length == var_g.length);\n        var_e = msg.sender;\n        var_f = 0x03;\n        storage_map_c[var_e] = 0x01 + storage_map_c[var_e];\n        var_e = keccak256(var_e);\n        storage_map_e[var_e] = arg0;\n        var_e = msg.sender;\n        var_f = 0x05;\n        storage_map_c[var_e] = storage_map_c[var_e] + 0x01;\n        var_e = keccak256(var_e);\n        storage_map_f[var_e] = uint40(block.timestamp);\n        var_e = msg.sender;\n        var_f = 0x06;\n        require(!storage_map_c[var_e] > ~(arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x15;\n        var_d = 0x496e76616c6964206461792073656c656374696f6e0000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x12;\n        var_d = 0x5374616b696e6720697320706175736564210000000000000000000000000000;\n    }",
    "llm_output": "function farm(uint256 depositAmount, uint256 planId) external payable {\n    /* 1. Staking must be enabled */\n    require(bytes1(isStakingAvailable) == 0x01, \"Invalid amount\");\n\n    /* 2. Minimum deposit requirement */\n    require(depositAmount >= minimumDeposit, \"Invalid amount\");\n\n    /* 3. The chosen staking plan must exist / be active */\n    require(activePlan[planId], \"Invalid amount\");\n\n    /* 4. Transfer tokens from the sender to this contract */\n    require(address(stakingToken).code.length > 0, \"Invalid token contract\");\n\n    (bool callSuccess, bytes memory returnData) = address(stakingToken).call(\n        abi.encodeWithSelector(\n            IERC20.transferFrom.selector,\n            msg.sender,\n            address(this),\n            depositAmount\n        )\n    );\n\n    /* Solidity-generated safety checks (kept for logical fidelity) */\n    require(!(((returnData.length + 0x20) - returnData.length) < 0x20), \"Return data size check failed\");\n    require(returnData.length == returnData.length, \"Return data mismatch\");\n\n    /* 5. Update user deposit counters and records */\n    userDepositCount[msg.sender] += 1;\n\n    uint256 firstIndex = userDepositCount[msg.sender];\n    userDepositAmount[msg.sender][firstIndex] = depositAmount;\n\n    /* Original bytecode increments the counter a second time */\n    userDepositCount[msg.sender] += 1;\n\n    uint256 secondIndex = userDepositCount[msg.sender];\n    userDepositTimestamp[msg.sender][secondIndex] = uint40(block.timestamp);\n\n    /* 6. Obscure overflow-style check preserved from original bytecode */\n    require(!(userDepositCount[msg.sender] > ~depositAmount), \"Overflow check\");\n}",
    "ground_truth": "function farm(uint256 _amount, uint256 _lockableDays) public \r\n    {\r\n        require(isStakingAvilable==true,\"Staking is paused!\");\r\n        require(_amount >= minimumDeposit, \"Invalid amount\");\r\n        require(allocation[_lockableDays] > 0, \"Invalid day selection\");\r\n        Token.transferFrom(msg.sender, address(this), _amount);\r\n        depositeToken[msg.sender].push(_amount);\r\n        depositetime[msg.sender].push(uint40(block.timestamp));\r\n        Users[msg.sender].DepositeToken += _amount;\r\n        lockabledays[msg.sender].push(_lockableDays);\r\n        stakers.push(msg.sender);\r\n        totalStakedToken+=_amount;\r\n        totallockvalue+=_amount;\r\n        uint256 reward = (allocation[_lockableDays].mul(_amount).div(100)).div(1e18);\r\n        rewardtobewithdraw+=reward;\r\n        emit Deposite_(msg.sender,address(this),_amount,_lockableDays,block.timestamp);\r\n    }"
}