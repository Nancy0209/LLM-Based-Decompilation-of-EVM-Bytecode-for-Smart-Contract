{
    "contract_address": "0x2bAa6759eF2a982BBf5619E21eC244eA7a2Ee3C4",
    "heimdall_input": "function getPriceinUSD() public payable {\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x0d4a11d5eeaac28ec3f61d100daf4d40471f1852;\n        require(address(0xdac17f958d2ee523a2206206994597c13d831ec7).code.length);\n        (bool success, bytes memory ret0) = address(0xdac17f958d2ee523a2206206994597c13d831ec7).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_d == (var_d));\n        var_e = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x0d4a11d5eeaac28ec3f61d100daf4d40471f1852;\n        require(address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).code.length);\n        (bool success, bytes memory ret0) = address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).Unresolved_70a08231(var_f); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_d == (var_d));\n        require(!(var_d == 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_c = 0x40 + var_c;\n        var_g = 0x1a;\n        var_h = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(var_d > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_j = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_k = var_c.length;\n        require(!(0 > var_c.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_l = 0;\n        var_m = var_n;\n        require(!(0x20 > var_c.length), \"SafeMath: division by zero\");\n        var_l = 0;\n        require(var_d);\n        var_o = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_p = 0x12;\n        var_i = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_j = 0x3ac4b2c0cbb85d309f1a7d0410e8e10594e5c928;\n        require(address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).code.length);\n        (bool success, bytes memory ret0) = address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).Unresolved_70a08231(var_j); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_d == (var_d));\n        var_q = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x3ac4b2c0cbb85d309f1a7d0410e8e10594e5c928;\n        require(address(0xe1223f2d494c37f83e1bdda5015e990938f00d81).code.length);\n        (bool success, bytes memory ret0) = address(0xe1223f2d494c37f83e1bdda5015e990938f00d81).Unresolved_70a08231(var_k); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_d == (var_d));\n        require(!(var_d == 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_c = 0x40 + var_c;\n        var_r = 0x1a;\n        var_s = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(var_d > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_u = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_v = var_c.length;\n        require(!(0 > var_c.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_w = 0;\n        var_x = var_n;\n        require(!(0x20 > var_c.length), \"SafeMath: division by zero\");\n        var_w = 0;\n        require(var_d);\n        var_o = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_p = 0x12;\n        require(!(var_d) & (0x3b9aca00 > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / (var_d))));\n        var_o = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_p = 0x11;\n    }",
    "llm_output": "function getPriceinUSD() external payable {\n    // Common ERC-20 selector: balanceOf(address)\n    bytes4 constant BALANCE_OF_SELECTOR = 0x70a08231;\n\n    // Tokens\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address constant WETH = 0xC02aaA39b223FE8D0A0E5C4F27eAD9083C756Cc2;\n    address constant TOKEN3 = 0xe1223F2D494C37F83e1BDda5015e990938F00d81;\n\n    // LP / holding contracts\n    address constant WETH_USDT_PAIR  = 0x0d4a11d5EeAaC28eC3F61D100DaF4d40471f1852;\n    address constant WETH_TOKEN3_PAIR = 0x3ac4b2C0CbB85d309F1A7d0410E8e10594E5c928;\n\n    // -------------------------------------------------------------\n    // USDT reserve in the WETH/USDT pair\n    (bool okUSDT, bytes memory dataUSDT) =\n        USDT.staticcall(abi.encodeWithSelector(BALANCE_OF_SELECTOR, WETH_USDT_PAIR));\n    require(okUSDT, \"USDT staticcall failed\");\n    require(dataUSDT.length >= 32, \"Invalid USDT returndata\");\n\n    uint256 reserveUSDT;\n    assembly {\n        reserveUSDT := mload(add(dataUSDT, 32))\n    }\n    require(reserveUSDT != 0, \"\");\n\n    // -------------------------------------------------------------\n    // WETH reserve in the WETH/USDT pair\n    (bool okWETH1, bytes memory dataWETH1) =\n        WETH.staticcall(abi.encodeWithSelector(BALANCE_OF_SELECTOR, WETH_USDT_PAIR));\n    require(okWETH1, \"WETH staticcall failed\");\n    require(dataWETH1.length >= 32, \"Invalid WETH returndata\");\n\n    uint256 reserveWETH1;\n    assembly {\n        reserveWETH1 := mload(add(dataWETH1, 32))\n    }\n    require(reserveWETH1 > 0, \"\");\n\n    // -------------------------------------------------------------\n    // WETH reserve in the WETH/TOKEN3 pair\n    (bool okWETH2, bytes memory dataWETH2) =\n        WETH.staticcall(abi.encodeWithSelector(BALANCE_OF_SELECTOR, WETH_TOKEN3_PAIR));\n    require(okWETH2, \"WETH2 staticcall failed\");\n    require(dataWETH2.length >= 32, \"Invalid WETH2 returndata\");\n\n    uint256 reserveWETH2;\n    assembly {\n        reserveWETH2 := mload(add(dataWETH2, 32))\n    }\n\n    // -------------------------------------------------------------\n    // TOKEN3 reserve in the WETH/TOKEN3 pair\n    (bool okT3, bytes memory dataT3) =\n        TOKEN3.staticcall(abi.encodeWithSelector(BALANCE_OF_SELECTOR, WETH_TOKEN3_PAIR));\n    require(okT3, \"TOKEN3 staticcall failed\");\n    require(dataT3.length >= 32, \"Invalid TOKEN3 returndata\");\n\n    uint256 reserveT3;\n    assembly {\n        reserveT3 := mload(add(dataT3, 32))\n    }\n    require(reserveT3 != 0, \"\");\n\n    // -------------------------------------------------------------\n    // The original decompiled code ends with contradictory or\n    // malformed arithmetic that can never succeed.  Re-emit the\n    // same behavior explicitly.\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function getPriceinUSD() public view returns (uint256){\r\n        \r\n        address USDT_WETH = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852; //USDT_WETH pancake pool address\r\n        IERC20 USDTTOKEN = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT Token address\r\n        IERC20 WETHTOKEN = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // WETH Token address\r\n        uint256 USDTSUPPLYINUSDT_WETH = USDTTOKEN.balanceOf(USDT_WETH);\r\n        uint256 WETHSUPPLYINUSDT_WETH = WETHTOKEN.balanceOf(USDT_WETH);\r\n        uint256 BNBPRICE = (USDTSUPPLYINUSDT_WETH.mul(1e18)).div(WETHSUPPLYINUSDT_WETH);\r\n        address TKN_WETH = 0x3Ac4B2C0cBb85d309f1a7D0410e8E10594e5c928; // TKN_WETH pancake pool address\r\n        IERC20 TKNTOKEN = IERC20(0xE1223F2d494c37f83E1BDda5015E990938f00d81); // TKN Token address \r\n        uint256 WETHSUPPLYINTKN_WETH =(WETHTOKEN.balanceOf(TKN_WETH));\r\n        uint256 TKNSUPPLYINTKN_WETH = (TKNTOKEN.balanceOf(TKN_WETH));\r\n        uint256 TKNUSDVAL = (((WETHSUPPLYINTKN_WETH.mul(1e9)).div((TKNSUPPLYINTKN_WETH))).mul(BNBPRICE)).div(1e18);\r\n        return TKNUSDVAL;\r\n    }"
}