{
    "contract_address": "0x0c929e3FF6Ed49E9D538756Bd127f5f23e1fC7D6",
    "heimdall_input": "function name() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                uint256 var_c = 0;\n                uint256 var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory tokenName) {\n    assembly {\n        // The packed string lives in storage slot 0\n        let slotData := sload(0)\n\n        // If the least-significant bit is 1 the string is <=31 bytes and stored in the slot itself.\n        switch and(slotData, 1)\n        case 1 {\n            // --------------------------\n            // Short string (\u2264 31 bytes)\n            // --------------------------\n            let strLen := shr(1, and(slotData, 0xFF))        // length is stored in the lowest byte >> 1\n\n            // Allocate memory for the return value\n            tokenName := mload(0x40)\n            mstore(tokenName, strLen)                        // store length\n\n            // The actual string data starts at bit position 8 of the slot\n            let data := shr(8, slotData)\n            mstore(add(tokenName, 0x20), data)               // copy data\n\n            // Advance free-memory pointer (32-byte aligned)\n            mstore(0x40, add(tokenName, add(0x20, and(add(strLen, 31), not(31)))))\n        }\n        default {\n            // --------------------------\n            // Long string (> 31 bytes)\n            // --------------------------\n            let strLen := shr(1, slotData)                   // length is slotData >> 1\n\n            // Compute storage slot where data starts: keccak256(0)\n            mstore(0x00, 0)                                  // scratch space\n            let dataSlot := keccak256(0x00, 0x20)\n\n            // Allocate memory for the return value\n            tokenName := mload(0x40)\n            mstore(tokenName, strLen)\n\n            // Copy string data word by word\n            let destPtr := add(tokenName, 0x20)\n            for { let offset := 0 } lt(offset, strLen) { offset := add(offset, 0x20) } {\n                mstore(add(destPtr, offset), sload(add(dataSlot, div(offset, 0x20))))\n            }\n\n            // Advance free-memory pointer (32-byte aligned)\n            mstore(0x40, add(destPtr, and(add(strLen, 31), not(31))))\n        }\n    }\n}",
    "ground_truth": "function name() external view override returns (string memory) {\\r\\n      return _name;\\r\\n    }"
}