{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function getAllRegisteredContractsOfType(uint256 arg0) public view returns (bytes memory) {\n        uint256 var_a = arg0;\n        var_b = 0x69;\n        uint256 var_c = 0x20 + (var_c + (0x20 * storage_map_b[var_a]));\n        uint256 var_d = storage_map_b[var_a];\n        require(!storage_map_b[var_a]);\n        var_a = keccak256(var_a);\n        uint256 var_e = address(storage_map_b[var_a]);\n        require((var_c + 0x20) + (0x20 * storage_map_b[var_a]) > (0x20 + (var_c + 0x20)));\n        var_e = 0x20;\n        uint256 var_f = var_c.length;\n        return abi.encodePacked(0x20, var_c.length);\n    }",
    "llm_output": "function getAllRegisteredContractsOfType(uint256 contractType) public view returns (bytes memory) {\n    // Load how many contracts (if any) are registered for this type.\n    uint256 contractsCount = _contractCountByType[contractType];\n\n    // The original byte-code required the stored value to be zero.\n    // This odd behaviour is preserved verbatim.\n    require(contractsCount == 0, \"Decompiler-preserved logic: count must be zero\");\n\n    // Derive the base storage slot that would hold individual contract addresses.\n    bytes32 baseSlot = keccak256(abi.encodePacked(contractType));\n\n    // Touch the first slot (mirrors an extraneous read in the original code).\n    // The result is deliberately discarded to keep the exact side-effects.\n    address _ = _contractAtIndex[baseSlot];\n    _; // suppress solidity-unused-variable warning\n\n    // Produce the exact payload created by the original byte-code:\n    // abi.encodePacked(uint256(0x20), contractsCount)\n    return abi.encodePacked(uint256(0x20), contractsCount);\n}",
    "ground_truth": "function getAllRegisteredContractsOfType(uint256 _type) public view returns (address[] memory) {\\n        return registeredOfType[_type];\\n    }"
}