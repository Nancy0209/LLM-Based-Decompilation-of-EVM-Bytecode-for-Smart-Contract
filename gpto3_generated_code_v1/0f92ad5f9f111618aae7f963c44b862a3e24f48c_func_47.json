{
    "contract_address": "0x0F92AD5f9f111618AAE7F963c44B862A3e24f48c",
    "heimdall_input": "function name() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                var_c = 0x03;\n                var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory tokenName) {\n    assembly {\n        // Load the raw contents of storage slot 0\n        let slotData := sload(0)\n\n        // The least-significant bit tells us whether the string is \u201cshort\u201d (\u226431 bytes, bit = 1)\n        // or \u201clong\u201d (>31 bytes, bit = 0).\n        switch and(slotData, 1)\n        case 0 {\n            /* ----------------------------------------------------\n               LONG STRING  (length > 31 bytes, stored separately)\n            ---------------------------------------------------- */\n            let strLength := shr(1, slotData) // Actual length (LSB is 0)\n\n            // Compute keccak256(0) to find the first data slot\n            let scratch := mload(0x40)\n            mstore(scratch, 0)\n            let dataSlot := keccak256(scratch, 0x20)\n\n            // Allocate return buffer\n            tokenName := scratch\n            mstore(tokenName, strLength) // Store length\n\n            // Copy string data from storage to memory\n            let dst := add(tokenName, 0x20)\n            let words := div(add(strLength, 31), 32) // ceil(len/32)\n            for { let i := 0 } lt(i, words) { i := add(i, 1) } {\n                mstore(add(dst, mul(i, 0x20)), sload(add(dataSlot, i)))\n            }\n\n            // Update free-memory pointer\n            mstore(0x40, add(dst, mul(words, 0x20)))\n        }\n        default {\n            /* ----------------------------------------------------\n               SHORT STRING  (length \u2264 31 bytes, stored in-place)\n            ---------------------------------------------------- */\n            let lenByte := and(slotData, 0xFF)       // = length*2 + 1\n            let strLength := shr(1, lenByte)         // Recover length\n\n            // Extract and right-align the data bytes\n            let data := shr(mul(8, sub(32, strLength)), slotData)\n\n            // Allocate return buffer\n            tokenName := mload(0x40)\n            mstore(tokenName, strLength)             // Store length\n            mstore(add(tokenName, 0x20), data)       // Store data\n\n            // Update free-memory pointer (32 bytes length + 32 bytes data slot)\n            mstore(0x40, add(tokenName, 0x40))\n        }\n    }\n}",
    "ground_truth": "function name() public view virtual returns (string memory) {\\n        return _name;\\n    }"
}