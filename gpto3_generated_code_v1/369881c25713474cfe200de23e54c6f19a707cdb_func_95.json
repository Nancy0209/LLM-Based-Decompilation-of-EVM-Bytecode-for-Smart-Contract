{
    "contract_address": "0x369881c25713474CFe200dE23E54C6f19a707cDB",
    "heimdall_input": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory) {\n    bytes32 header;\n    assembly {\n        /* slot-0 is reserved for the string header of `name`                    */\n        header := sload(0)\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*  Early exit for an empty string                                            */\n    /* -------------------------------------------------------------------------- */\n    if (header == bytes32(0)) {\n        return \"\";\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*  Short-string flag & duplicated legacy checks                              */\n    /* -------------------------------------------------------------------------- */\n    bool isShortString = (uint256(header) & 1) == 1;\n\n    uint256 headerCheck = uint256(header) - (isShortString ? 1 : 0);\n    if (headerCheck != 0) {\n        /* The original byte-code writes the panic selector (0x4e487b71) and the\n           error code (0x22) to memory but does NOT revert.  We reproduce that\n           exact side-effect for full semantic fidelity.                          */\n        assembly {\n            mstore(\n                0x00,\n                0x4e487b7100000000000000000000000000000000000000000000000000000000\n            )\n            mstore(0x04, 0x22)\n        }\n    }\n\n    /* A second, identical check exists in the original byte-code; we keep it.   */\n    if (headerCheck != 0) {\n        assembly {\n            mstore(\n                0x00,\n                0x4e487b7100000000000000000000000000000000000000000000000000000000\n            )\n            mstore(0x04, 0x22)\n        }\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*  Decode the actual byte length                                             */\n    /* -------------------------------------------------------------------------- */\n    uint256 byteLength = uint256(header) >> 1;\n\n    /* -------------------------------------------------------------------------- */\n    /*  Short-string mode: data is packed into the header                         */\n    /* -------------------------------------------------------------------------- */\n    if (isShortString) {\n        bytes memory buffer = new bytes(byteLength);\n\n        if (byteLength > 0) {\n            assembly {\n                /* Drop the least-significant byte (flag) and copy the remaining\n                   31 bytes into memory.                                          */\n                let data := shr(8, shl(8, header))\n                mstore(add(buffer, 0x20), data)\n            }\n        }\n\n        return string(buffer);\n    }\n\n    /* -------------------------------------------------------------------------- */\n    /*  Long-string mode                                                          */\n    /* -------------------------------------------------------------------------- */\n    bytes memory longBuffer = new bytes(byteLength);\n\n    /* Storage offset where the actual data begins: keccak256(slot)              */\n    bytes32 dataSlot;\n    assembly {\n        mstore(0x00, 0x00)\n        dataSlot := keccak256(0x00, 0x20)\n    }\n\n    /* Copy the data word-by-word from storage to memory                         */\n    uint256 wordsToCopy = (byteLength + 31) / 32;\n    for (uint256 i = 0; i < wordsToCopy; ++i) {\n        bytes32 word;\n        assembly {\n            word := sload(add(dataSlot, i))\n        }\n\n        assembly {\n            mstore(add(add(longBuffer, 0x20), mul(i, 0x20)), word)\n        }\n    }\n\n    return string(longBuffer);\n}",
    "ground_truth": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }"
}