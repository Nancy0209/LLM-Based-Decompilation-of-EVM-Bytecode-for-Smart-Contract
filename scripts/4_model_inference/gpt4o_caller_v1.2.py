# -*- coding: utf-8 -*-
import json
import os
import requests
import time
import logging
from tqdm import tqdm
import sys

# --- Configuration ---
API_URL = "https://api.videocaptioner.cn/v1/chat/completions"
# <<< IMPORTANT: Paste your secret OpenAI API Key here >>>
API_KEY = "sk-9t6vPfoSZfORhHnpG4Y6mB9UN2IC8SQ8KpABD09OnOg1YlRz"
# Use the latest and most powerful model from OpenAI
MODEL_NAME = "gpt-4o"
# --- General Settings ---
INPUT_DATASET_FILE = 'data/datasets/val_dataset_v3.jsonl'

OUTPUT_DIR = 'results/gpt4o_generated_code_v1.2'

# API call settings
API_CALL_DELAY = 1.0
API_TIMEOUT = 120

# --- Logging Setup ---
LOG_FILE = "results/logs/gpt4o_generated_code_v1.2.log"
os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE, mode="w", encoding="utf-8"),
        logging.StreamHandler()
    ]
)

### --- Prompt V1: Strong Constraint Strategy --- ###
### --- Prompt V1.2: Context-Enhanced Strategy --- ###
def build_prompt(heimdall_code, contract_address, abi, full_context):
    """
    Constructs the V1.2 prompt, enhanced with ABI and full contract context.
    """
    # Format the abi and full_context into easy-to-read JSON strings
    abi_str = json.dumps(abi, indent=2) if abi else "Not available"
    context_str = json.dumps(full_context, indent=2) if full_context else "Not available"

    system_prompt = "You are an expert-level Solidity reverse engineer. Your task is to semantically refine decompiled Solidity code to match the original source code as closely as possible."
    user_prompt = f"""
The following Solidity code was generated by a decompiler from the contract at address {contract_address}.
It suffers from poor readability and potential compilation errors.

### PRIMARY GOALS (Do This):
1.  **Rename Identifiers:** Aggressively rename generic variables (`var_a`, `storage_map_b`), function names (`Unresolved_XXXX`), and parameters (`arg0`) to be meaningful and idiomatic based on their usage context. This is your most important task.
2.  **Correct Syntax:** Fix all syntax errors, type mismatches, and non-standard Solidity patterns to make the code fully compilable.
3.  **Improve Readability:** Restructure control flow (like if/else statements) to be clean and easy to follow, but only if the logic remains identical.

### CRITICAL CONSTRAINTS (Do NOT Do This):
1.  **DO NOT ADD OR REMOVE LOGIC:** You are forbidden from introducing any new `require`, `if`, or other conditional checks that did not exist in the decompiled code's logic. You must not add checks like `require(address != address(0))`. Your goal is 100% logical fidelity, NOT to add security best practices.
2.  **DO NOT REMOVE CHECKS:** Do not remove any existing logical checks, even if they seem redundant or strange.
3.  **HANDLE BROKEN LOGIC:** If the decompiled code contains a statement that will always fail (e.g., `require(false)`), you must replace it with a simple `revert('Decompiler artifact');` and nothing else.

### CONTEXTUAL INFORMATION (Use This for Better Naming):

#### ABI (for correct function signatures):
```json
{abi_str}
```
#### Full Contract Context (for better variable naming):
```json
{context_str}
```
### OUTPUT FORMAT:
Only output the raw Solidity code for the refined function.
Do not include any explanations or markdown formatting around the code block.
### Decompiled Code:
``` solidity
{heimdall_code}
```
"""
    return [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}]


def call_api(input_dataset_path, output_dir):
    """
    Loads the dataset, calls the specified API for each entry,
    and saves the input, output, and ground truth for evaluation.
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        logging.info(f"Created output directory: {output_dir}")

    if not os.path.exists(input_dataset_path):
        logging.error(f"Input dataset file '{input_dataset_path}' not found. Exiting.")
        sys.exit(1)

    with open(input_dataset_path, 'r', encoding='utf-8') as f:
        data_points = [json.loads(line) for line in f]

    logging.info(f"Loaded {len(data_points)} data points from {input_dataset_path}.")

    processed_count = 0
    failed_count = 0
    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {API_KEY}"}

    for i, data_point in enumerate(tqdm(data_points, desc=f"Calling OpenAi API (Prompt v1.2)")):
        try:
            heimdall_code = data_point.get('heimdall_decompiled_code')
            original_code = data_point.get('original_solidity_code')
            contract_address = data_point.get('contract_address')
            abi = data_point.get('abi')
            full_context = data_point.get('full_context')

            address_base = contract_address.lower().replace('0x', '')
            output_file_path = os.path.join(output_dir, f"{address_base}_func_{i}.json")

            if os.path.exists(output_file_path):
                processed_count += 1
                continue

            prompt_messages = build_prompt(heimdall_code, contract_address, abi, full_context)
            payload = {
                "model": MODEL_NAME,
                "messages": prompt_messages,
                "stream": False,
                "temperature": 0.0
            }

            response = requests.post(API_URL, headers=headers, json=payload, timeout=API_TIMEOUT)
            response.raise_for_status()

            api_response = response.json()
            generated_text = api_response['choices'][0]['message']['content']

            # Clean up the output if it includes markdown code blocks
            if "```solidity" in generated_text:
                generated_text = generated_text.split("```solidity")[1].strip()
            if generated_text.endswith("```"):
                generated_text = generated_text[:-3].strip()

            evaluation_data = {
                'contract_address': contract_address,
                'heimdall_input': heimdall_code,
                'llm_output': generated_text,
                'ground_truth': original_code
            }

            with open(output_file_path, 'w', encoding='utf-8') as f:
                json.dump(evaluation_data, f, indent=4)

            processed_count += 1

        except Exception as e:
            failed_count += 1
            logging.error(f"API request failed for item {i} ({data_point.get('contract_address')}): {e}")

        time.sleep(API_CALL_DELAY)

    logging.info(f"\n--- OpenAi API Calling Completed ---")
    logging.info(f"Total data points: {len(data_points)}")
    logging.info(f"Successfully generated outputs: {processed_count}")
    logging.info(f"Failed attempts: {failed_count}")


if __name__ == "__main__":
    if "YOUR_NEW_OPENAI_API_KEY_HERE" in API_KEY:
        logging.error("Error: Please replace 'sk-YOUR_NEW_OPENAI_API_KEY_HERE' with your actual OpenAi API Key in the script.")
        sys.exit(1)

    logging.info(f"Starting API call process for {MODEL_NAME} with Prompt V1.2")
    call_api(INPUT_DATASET_FILE, OUTPUT_DIR)
