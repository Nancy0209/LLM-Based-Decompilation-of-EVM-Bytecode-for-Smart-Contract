{
    "contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421",
    "heimdall_input": "function farm(uint256 arg0, uint256 arg1) public payable {\n        require(0x01 == (bytes1(isStakingAvilable)), \"Invalid amount\");\n        require(!(arg0 < minimumDeposit), \"Invalid amount\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0e;\n        var_d = 0x496e76616c696420616d6f756e74000000000000000000000000000000000000;\n        uint256 var_e = arg1;\n        var_f = 0x02;\n        require(storage_map_c[var_e]);\n        var_a = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        address var_c = address(this);\n        uint256 var_d = arg0;\n        require(address(Token).code.length);\n        (bool success, bytes memory ret0) = address(Token).{ value: 0 ether }Unresolved_23b872dd(var_b); // call\n        uint256 var_g = var_g + (uint248(ret0.length + 0x1f));\n        require(!((var_g + ret0.length) - var_g) < 0x20);\n        require(var_g.length == var_g.length);\n        var_e = msg.sender;\n        var_f = 0x03;\n        storage_map_c[var_e] = 0x01 + storage_map_c[var_e];\n        var_e = keccak256(var_e);\n        storage_map_e[var_e] = arg0;\n        var_e = msg.sender;\n        var_f = 0x05;\n        storage_map_c[var_e] = storage_map_c[var_e] + 0x01;\n        var_e = keccak256(var_e);\n        storage_map_f[var_e] = uint40(block.timestamp);\n        var_e = msg.sender;\n        var_f = 0x06;\n        require(!storage_map_c[var_e] > ~(arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x15;\n        var_d = 0x496e76616c6964206461792073656c656374696f6e0000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x12;\n        var_d = 0x5374616b696e6720697320706175736564210000000000000000000000000000;\n    }",
    "llm_output": "function farm(uint256 _amount, uint256 _lockableDays) external payable {\n    /* \n       Staking must be enabled. \n       The original byte-code compared the boolean to 0x01, which is\n       equivalent to simply requiring the flag to be true.\n    */\n    require(isStakingAvilable, \"Staking is paused!\");\n\n    /* Minimum deposit enforcement ( \u201cInvalid amount\u201d in the decompiled text ) */\n    require(_amount >= minimumDeposit, \"Invalid amount\");\n\n    /* A non\u2013zero allocation percentage must exist for the selected lock period */\n    require(allocation[_lockableDays] != 0, \"Invalid day selection\");\n\n    /* Transfer the staking tokens from the user to this contract */\n    require(\n        Token.transferFrom(msg.sender, address(this), _amount),\n        \"Transfer failed\"\n    );\n\n    /*\n       Increment the per-user deposit counter and use it as the index for the\n       nested mappings that store individual deposit information.  The mapping\n       \u2018depositIndex\u2019 is the semantic replacement for the anonymous\n       `storage_map_c` encountered in the decompiled code.\n    */\n    depositIndex[msg.sender] += 1;\n    uint256 index = depositIndex[msg.sender];\n\n    /* Store the deposit amount, lock duration and the timestamp */\n    depositeToken[msg.sender][index] = _amount;\n    lockabledays[msg.sender][index]  = _lockableDays;\n    depositetime[msg.sender][index]  = block.timestamp;\n}",
    "ground_truth": "function farm(uint256 _amount, uint256 _lockableDays) public \r\n    {\r\n        require(isStakingAvilable==true,\"Staking is paused!\");\r\n        require(_amount >= minimumDeposit, \"Invalid amount\");\r\n        require(allocation[_lockableDays] > 0, \"Invalid day selection\");\r\n        Token.transferFrom(msg.sender, address(this), _amount);\r\n        depositeToken[msg.sender].push(_amount);\r\n        depositetime[msg.sender].push(uint40(block.timestamp));\r\n        Users[msg.sender].DepositeToken += _amount;\r\n        lockabledays[msg.sender].push(_lockableDays);\r\n        stakers.push(msg.sender);\r\n        totalStakedToken+=_amount;\r\n        totallockvalue+=_amount;\r\n        uint256 reward = (allocation[_lockableDays].mul(_amount).div(100)).div(1e18);\r\n        rewardtobewithdraw+=reward;\r\n        emit Deposite_(msg.sender,address(this),_amount,_lockableDays,block.timestamp);\r\n    }"
}