{
    "contract_address": "0x2bAa6759eF2a982BBf5619E21eC244eA7a2Ee3C4",
    "heimdall_input": "function realtimeRewardPerBlock(address arg0, uint256 arg1) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        address var_b = keccak256(var_a);\n        require(!(!bytes1(storage_map_k[var_a] / 0x01)), \"SafeMath: multiplication overflow\");\n        require(!(!bytes1(storage_map_k[var_a] / 0x01)), \"SafeMath: multiplication overflow\");\n        uint256 var_c = 0;\n        uint256 var_d = 0;\n        return abi.encodePacked(0, 0);\n        var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        var_b = keccak256(var_a);\n        require(!(storage_map_af[var_a] == 0), \"SafeMath: multiplication overflow\");\n        require(!(block.timestamp < (storage_map_af[var_a])), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        var_b = keccak256(var_a);\n        require(!((block.timestamp - (storage_map_af[var_a])) == 0), \"SafeMath: multiplication overflow\");\n        var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        var_b = keccak256(var_a);\n        require(!(0 < (storage_map_ag[var_a])), \"SafeMath: multiplication overflow\");\n        require(!(0 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_c = 0;\n        var_d = block.timestamp;\n        return abi.encodePacked(0, block.timestamp);\n        require(!((block.timestamp - (storage_map_af[var_a])) & (storage_map_n[var_a] > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / (block.timestamp - (storage_map_af[var_a]))))), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        require(block.timestamp - (storage_map_af[var_a]), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x12;\n        require((block.timestamp - (storage_map_af[var_a])) * (storage_map_n[var_a]) / (block.timestamp - (storage_map_af[var_a])) == (storage_map_n[var_a]), \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_f = ((0x04 + var_g) + 0x20) - (0x04 + var_g);\n        var_h = 0x21;\n        var_i = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_j = 0x7700000000000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function realtimeRewardPerBlock(address user, uint256 index) public view returns (uint256 reward, uint256 timestamp) {\n    // Load the requested stake record\n    Stake storage stakeRecord = stakersRecord[user][index];\n\n    /*\n        The original (decompiled) byte-code performs a sequence of checks that,\n        in effect, short\u2013circuit the computation when the stake has been\n        withdrawn, when no stake time is recorded, or when the time window\n        has already elapsed.  The following early-return clauses reproduce\n        that behaviour without altering the underlying logic.\n    */\n\n    // 1. Nothing to calculate once the stake has been withdrawn\n    if (stakeRecord.withdrawan) {\n        return (0, 0);\n    }\n\n    // 2. If the stake was never initialised (zero timestamp) return zeros\n    if (stakeRecord.staketime == 0) {\n        return (0, 0);\n    }\n\n    /*\n        Determine the upper bound (endTime) for reward calculation.\n\n        unstaketime == 0  \u279c  User hasn\u2019t called `unstake` yet,\n                             so we consider the current block-timestamp.\n\n        unstaketime  > 0  \u279c  `unstake` was requested; rewards stop at\n                             the recorded unstake-time.\n    */\n    uint256 endTime = stakeRecord.unstaketime == 0\n        ? block.timestamp\n        : stakeRecord.unstaketime;\n\n    /*\n        If endTime is not greater than the last harvest time there is no\n        additional reward to claim.\n    */\n    if (endTime <= stakeRecord.lastharvesttime) {\n        return (0, block.timestamp);\n    }\n\n    /*\n        The decompiled code applies SafeMath multiplications; Solidity \u22650.8\n        reverts on overflow natively, so plain arithmetic is equivalent.\n    */\n    uint256 elapsedTime = endTime - stakeRecord.lastharvesttime;\n\n    reward    = elapsedTime * stakeRecord.persecondreward;\n    timestamp = block.timestamp;      // Match original return packing\n\n    return (reward, timestamp);\n}",
    "ground_truth": "function realtimeRewardPerBlock(address user, uint256 blockno) public view returns (uint256,uint256) {\r\n        uint256 ret;\r\n        uint256 commontimestamp;\r\n            if (\r\n                !stakersRecord[user][blockno].withdrawan &&\r\n                !stakersRecord[user][blockno].unstaked\r\n            ) {\r\n                uint256 val;\r\n                uint256 tempharvesttime = stakersRecord[user][blockno].lastharvesttime;\r\n                commontimestamp = block.timestamp;\r\n                if(tempharvesttime == 0){\r\n                    tempharvesttime = stakersRecord[user][blockno].staketime;\r\n                }\r\n                val = commontimestamp - tempharvesttime;\r\n                val = val.mul(stakersRecord[user][blockno].persecondreward);\r\n                if (val < stakersRecord[user][blockno].remainingreward) {\r\n                    ret += val;\r\n                } else {\r\n                    ret += stakersRecord[user][blockno].remainingreward;\r\n                }\r\n            }\r\n        return (ret,commontimestamp);\r\n    }"
}