{
    "contract_address": "0x332098414098f0E42658f2eA0254B44b077bb4A5",
    "heimdall_input": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function getName() public view returns (string memory) {\n    if (storedValue > 0) {\n        if (storedValue - ((storedValue / 2) < 32)) {\n            uint256 errorCode = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            uint256 errorType = 34;\n            uint256 adjustedLength = adjustedLength + (32 + (((31 + (storedValue / 2)) / 32) * 32));\n            uint256 halfStoredValue = storedValue / 2;\n\n            if (storedValue > 0) {\n                if (storedValue - ((storedValue / 2) < 32)) {\n                    errorCode = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    errorType = 34;\n\n                    if (halfStoredValue == 0) {\n                        if (31 < (storedValue / 2)) {\n                            errorCode = 3;\n                            bytes32 storageValue = storageMap[errorCode];\n\n                            if ((32 + adjustedLength) + (storedValue / 2) > (32 + (32 + adjustedLength))) {\n                                uint256 encodedLength = (adjustedLength + 32) - adjustedLength;\n                                uint256 dataLength = adjustedLength.length;\n                                uint256 placeholder = 0;\n\n                                return abi.encodePacked((adjustedLength + 32) - adjustedLength, adjustedLength.length);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "ground_truth": "function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address owner) external view returns (uint256);\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint256);\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n    function price0CumulativeLast() external view returns (uint256);\\n    function price1CumulativeLast() external view returns (uint256);\\n    function kLast() external view returns (uint256);\\n    function mint(address to) external returns (uint256 liquidity);\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n    function skim(address to) external;\\n    function sync() external;\\n    function initialize(address, address) external;\\n}\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}"
}