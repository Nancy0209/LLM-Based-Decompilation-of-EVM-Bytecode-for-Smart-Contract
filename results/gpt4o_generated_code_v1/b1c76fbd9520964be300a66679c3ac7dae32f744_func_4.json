{
    "contract_address": "0xB1C76Fbd9520964Be300A66679C3ac7dae32f744",
    "heimdall_input": "function withdrawToken(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(this) - (address(arg0)));\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(this);\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"Address: insufficient balance for call\");\n        address var_d = address(owner);\n        uint256 var_f = var_e.length;\n        uint256 var_g = 0x44 + (var_e - var_e);\n        var_e = var_e + 0x64;\n        uint224 var_h = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 | (uint224(var_i));\n        var_e = 0x40 + var_e;\n        var_j = 0x20;\n        var_k = 0x5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564;\n        require(!(address(this).balance < 0), \"Address: insufficient balance for call\");\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        var_n = 0x26;\n        var_o = 0x416464726573733a20696e73756666696369656e742062616c616e636520666f;\n        var_p = 0x722063616c6c0000000000000000000000000000000000000000000000000000;\n        require(address(arg0).code.length, \"Address: call to non-contract\");\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        var_n = 0x1d;\n        var_o = 0x416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000;\n        uint256 var_o = 0;\n        (bool success, bytes memory ret0) = address(arg0).{ value: var_o ether }Unresolved_08c379a0(var_m); // call\n        require(ret0.length == 0);\n        require(!var_q);\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        uint256 var_n = var_e.length;\n        uint256 var_p = 0;\n        var_o = var_r;\n        var_p = 0;\n        require(!var_q, \"SafeERC20: ERC20 operation did not succeed\");\n        require(!(((0x80 + var_q) - 0x80) < 0x20), \"SafeERC20: ERC20 operation did not succeed\");\n        require(var_a == var_a, \"SafeERC20: ERC20 operation did not succeed\");\n        require(var_a, \"SafeERC20: ERC20 operation did not succeed\");\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        var_n = 0x2a;\n        var_o = 0x5361666545524332303a204552433230206f7065726174696f6e20646964206e;\n        var_p = 0x6f74207375636365656400000000000000000000000000000000000000000000;\n        var_e = var_e + (uint248(ret0.length + 0x3f));\n        uint256 var_l = ret0.length;\n        require(!var_e.length);\n        require(!var_e.length);\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0b;\n        var_d = 0x4e6f7420616c6c6f776564000000000000000000000000000000000000000000;\n    }",
    "llm_output": "pragma solidity ^0.8.0;\n\ncontract TokenWithdrawal {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdrawToken(address tokenAddress) public {\n        require(tokenAddress != address(0), \"Invalid token address\");\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n\n        // Check token balance of the contract\n        bytes4 balanceOfSelector = bytes4(keccak256(\"balanceOf(address)\"));\n        (bool balanceCheckSuccess, bytes memory balanceData) = tokenAddress.staticcall(abi.encodeWithSelector(balanceOfSelector, address(this)));\n        require(balanceCheckSuccess, \"Failed to fetch token balance\");\n        require(balanceData.length >= 32, \"Invalid balance data\");\n\n        uint256 tokenBalance = abi.decode(balanceData, (uint256));\n        require(tokenBalance > 0, \"No tokens to withdraw\");\n\n        // Transfer tokens to the owner\n        bytes4 transferSelector = bytes4(keccak256(\"transfer(address,uint256)\"));\n        (bool transferSuccess, bytes memory transferData) = tokenAddress.call(abi.encodeWithSelector(transferSelector, owner, tokenBalance));\n        require(transferSuccess, \"Token transfer failed\");\n        require(transferData.length == 0 || abi.decode(transferData, (bool)), \"Token transfer did not succeed\");\n    }\n}",
    "ground_truth": "function withdrawToken(address token) external onlyOwner{\r\n        require(address(this) != token, \"Not allowed\");\r\n        IERC20(token).safeTransfer(owner(), IERC20(token).balanceOf(address(this)));\r\n    }"
}