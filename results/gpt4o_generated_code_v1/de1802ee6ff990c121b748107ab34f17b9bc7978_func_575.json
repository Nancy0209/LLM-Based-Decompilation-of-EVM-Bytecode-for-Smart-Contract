{
    "contract_address": "0xDE1802eE6Ff990c121b748107Ab34f17b9Bc7978",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 > 0, \"SafeMath: addition overflow\");\n        address var_a = address(msg.sender);\n        var_b = 0x03;\n        require(bytes1(storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        require(bytes1(storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        require(!0, \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_a[var_a] > (0 + storage_map_a[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((0 + storage_map_a[var_a]) < storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_a[var_a] = 0 + storage_map_a[var_a];\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        uint256 var_h = 0x40 + var_h;\n        var_d = 0x1e;\n        var_i = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_a[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_k = var_h.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        require(!((storage_map_a[var_a] - arg1) > storage_map_a[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_a[var_a] = storage_map_a[var_a] - arg1;\n        var_h = 0x40 + var_h;\n        var_j = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(0 > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_p = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        uint256 var_q = var_h.length;\n        uint256 var_r = 0;\n        var_s = var_n;\n        var_r = 0;\n        require(!(arg1 - 0) > arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(bytes1(tradingEnabled / 0x010000000000000000000000000000000000000000));\n        require(address(msg.sender) - (address(tradingEnabled)));\n        require(address(arg0) - (address(tradingEnabled)));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        tradingEnabled = 0x01000000000000000000000000000000000000000000 | (uint248(tradingEnabled));\n        var_d = 0x02;\n        var_h = var_h + 0x60;\n        var_t = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_i = address(this);\n        var_o = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_c / 0x01).WETH(var_k); // staticcall\n        var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!((var_h + ret0.length) - var_h) < 0x20);\n        require(var_h.length == (address(var_h.length)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        uint256 var_j = address(var_h.length);\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_c);\n        address var_b = keccak256(var_a);\n        storage_map_a[var_a] = store_d;\n        var_p = store_d;\n        emit Approval(address(this), address(store_c), store_d);\n        var_p = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_m = store_d;\n        var_q = 0;\n        var_s = 0xa0;\n        uint256 var_u = var_h.length;\n        address var_v = address(this);\n        uint256 var_w = block.timestamp;\n        require(address(store_c).code.length);\n        (bool success, bytes memory ret0) = address(store_c).Unresolved_791ac947(var_m); // call\n        tradingEnabled = uint248(tradingEnabled);\n        (bool success, bytes memory ret0) = address(store_e).transfer(address(this).balance);\n        if (ret0.length == 0) {\n        }\n        var_a = address(this);\n        var_b = 0x01;\n        if (!storage_map_a[var_a] > store_d) {\n        }\n        if (!tradingEnabled / 0x0100000000000000000000000000000000000000000000) {\n        }\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((sellFees == ((sellFees * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((sellFees * arg1) / arg1) == sellFees, \"SafeMath: multiplication overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_k = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x40 + var_h;\n        var_d = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        if (0x64) {\n            if (0x64) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x12;\n                require(0x64, \"Trading is not started\");\n            }\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x12;\n            require(0x64, \"Trading is not started\");\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x16;\n        var_g = 0x54726164696e67206973206e6f74207374617274656400000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_k = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "pragma solidity ^0.8.0;\n\ncontract DecompiledContract {\n    mapping(address => uint256) private balances;\n    bool private tradingEnabled;\n    address private storeC;\n    address private storeE;\n    uint256 private sellFees;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function transfer(address recipient, uint256 amount) public {\n        require(recipient != address(0), \"Invalid recipient address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        address sender = msg.sender;\n\n        // Check if sender has sufficient balance\n        require(balances[sender] >= amount, \"Insufficient balance\");\n\n        // Subtract the amount from sender's balance\n        balances[sender] -= amount;\n\n        // Add the amount to recipient's balance\n        balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        // Additional trading checks\n        require(tradingEnabled, \"Trading is not enabled\");\n        require(balances[sender] >= sellFees, \"Insufficient balance for fees\");\n\n        // Perform some operation with storeC\n        require(storeC != address(0), \"StoreC address is not set\");\n        (bool success, ) = storeC.call(abi.encodeWithSignature(\"Unresolved_791ac947(uint256)\", sellFees));\n        require(success, \"Call to storeC failed\");\n\n        // Transfer contract balance to storeE\n        require(storeE != address(0), \"StoreE address is not set\");\n        (success, ) = storeE.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer to storeE failed\");\n    }\n}",
    "ground_truth": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }"
}