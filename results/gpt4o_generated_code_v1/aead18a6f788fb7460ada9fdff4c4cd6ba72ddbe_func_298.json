{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function tokensOfOwner(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        if (0x01 == totalSupply) {\n            var_a = 0x20;\n            var_b = var_c;\n            if (!0 < var_c) {\n                return abi.encodePacked(0x20, var_c);\n                if (0x01 < totalSupply) {\n                    if (!0x01 < 0x01) {\n                        if (totalSupply < totalSupply) {\n                            if (address(arg0)) {\n                                address var_d = address(arg0);\n                                var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c45;\n                                if (!(0x01 < totalSupply) * (uint64(storage_map_k[var_d]))) {\n                                    require(0x01 == totalSupply, CustomError_8f4eb604());\n                                    uint256 var_f = var_f + (((totalSupply - 0x01) + 0x01) << 0x05);\n                                    var_f = var_f + 0x80;\n                                    uint256 var_a = 0;\n                                    uint256 var_b = 0;\n                                    uint256 var_g = 0;\n                                    uint256 var_h = 0;\n                                    require(!(0 < var_c), CustomError_8f4eb604());\n                                    require(0x01 < totalSupply, CustomError_8f4eb604());\n                                    var_f = var_f + 0x80;\n                                    uint256 var_i = 0;\n                                    uint256 var_j = 0;\n                                    uint256 var_k = 0;\n                                    uint256 var_l = 0;\n                                    var_d = 0x01;\n                                    var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                                    var_f = var_f + 0x80;\n                                    uint256 var_m = 0;\n                                    uint256 var_n = 0;\n                                    uint256 var_o = 0;\n                                    uint256 var_p = 0;\n                                    var_m = address(storage_map_k[var_d]);\n                                    var_n = uint64(storage_map_k[var_d] >> 0xa0);\n                                    var_o = !(!bytes1(storage_map_k[var_d]));\n                                    var_p = storage_map_k[var_d] >> 0xe8;\n                                    require(!(0x01 < 0x01), CustomError_8f4eb604());\n                                    require(totalSupply < totalSupply, CustomError_8f4eb604());\n                                    require(address(arg0), CustomError_8f4eb604());\n                                }\n                                require(!((0x01 < totalSupply) * (uint64(storage_map_k[var_d]))), CustomError_8f4eb604());\n                                require((totalSupply - 0x01) > ((0x01 < totalSupply) * (uint64(storage_map_k[var_d]))), CustomError_8f4eb604());\n                                require(0x01 < 0x01, CustomError_8f4eb604());\n                                require(var_q, CustomError_8f4eb604());\n                            }\n                            var_b = 0x01;\n                            require(var_r == 0, CustomError_8f4eb604());\n                        }\n                    }\n                }\n                require(!var_f.length, CustomError_8f4eb604());\n                var_d = 0x01;\n                var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                require((var_f.length ^ arg0) << 0x60, CustomError_8f4eb604());\n            }\n            var_f = var_f + (((0x01 < totalSupply) * (uint64(storage_map_k[var_d])) + 0x01) << 0x05);\n            var_f = var_f + 0x80;\n            var_b = 0;\n            var_g = 0;\n            var_h = 0;\n            var_i = 0;\n            require(!(0x01 < totalSupply), CustomError_8f4eb604());\n            require(0x01 < 0x01, CustomError_8f4eb604());\n            var_d = 0x01;\n            var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n            require(!(0x01 < totalSupply), CustomError_8f4eb604());\n        }\n        var_d = 0x8f4eb60400000000000000000000000000000000000000000000000000000000;\n        var_d = 0x32c1995a00000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function tokensOfOwner(address owner) public view returns (bytes memory) {\n    require(owner == address(owner), \"Invalid address\");\n\n    if (totalSupply == 1) {\n        uint256 dataLength = 0x20;\n        uint256 tokenCount = 0; // Assuming var_c is tokenCount\n\n        if (tokenCount == 0) {\n            return abi.encodePacked(dataLength, tokenCount);\n        }\n\n        if (totalSupply > 1) {\n            if (totalSupply > 1) {\n                if (totalSupply < totalSupply) {\n                    if (owner != address(0)) {\n                        address currentOwner = owner;\n                        bytes32 someHash = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c45;\n\n                        if (!((totalSupply > 1) * uint64(storage_map_k[currentOwner]))) {\n                            require(totalSupply == 1, \"CustomError_8f4eb604\");\n                            uint256 offset = 0;\n                            offset += ((totalSupply - 1) + 1) << 5;\n                            offset += 0x80;\n\n                            require(tokenCount == 0, \"CustomError_8f4eb604\");\n                            require(totalSupply > 1, \"CustomError_8f4eb604\");\n\n                            offset += 0x80;\n                            currentOwner = address(0x01);\n                            someHash = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                            offset += 0x80;\n\n                            address storedAddress = address(storage_map_k[currentOwner]);\n                            uint64 storedValue = uint64(storage_map_k[currentOwner] >> 0xa0);\n                            bool isNonZero = !(!bytes1(storage_map_k[currentOwner]));\n                            uint256 shiftedValue = storage_map_k[currentOwner] >> 0xe8;\n\n                            require(!(totalSupply > 1), \"CustomError_8f4eb604\");\n                            require(totalSupply < totalSupply, \"CustomError_8f4eb604\");\n                            require(owner != address(0), \"CustomError_8f4eb604\");\n                        }\n\n                        require(!((totalSupply > 1) * uint64(storage_map_k[currentOwner])), \"CustomError_8f4eb604\");\n                        require((totalSupply - 1) > ((totalSupply > 1) * uint64(storage_map_k[currentOwner])), \"CustomError_8f4eb604\");\n                        require(totalSupply > 1, \"CustomError_8f4eb604\");\n                        require(false, \"CustomError_8f4eb604\");\n                    }\n\n                    require(false, \"CustomError_8f4eb604\");\n                }\n            }\n        }\n\n        require(false, \"CustomError_8f4eb604\");\n    }\n\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/HasRegistration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CLOSED - Pending Licensing Audit\\npragma solidity ^0.8.4;\\nimport \\\"./IsBypassable.sol\\\";\\n\\ncontract HasRegistration is IsBypassable {\\n\\n    mapping(address => uint256) public registeredContracts; // 0 EMPTY, 1 ERC1155, 2 ERC721, 3 HANDLER, 4 ERC20, 5 BALANCE, 6 CLAIM, 7 UNKNOWN, 8 FACTORY, 9 STAKING, 10 BYPASS\\n    mapping(uint256 => address[]) internal registeredOfType;\\n\\n    modifier isRegisteredContract(address _contract) {\\n        require(registeredContracts[_contract] > 0, \\\"Contract is not registered\\\");\\n        _;\\n    }\\n\\n    modifier isRegisteredContractOrOwner(address _contract) {\\n        require(registeredContracts[_contract] > 0 || owner() == _msgSender(), \\\"Contract is not registered nor Owner\\\");\\n        _;\\n    }\\n\\n    function registerContract(address _contract, uint _type) public isRegisteredContractOrOwner(_msgSender()) {\\n        registeredContracts[_contract] = _type;\\n        registeredOfType[_type].push(_contract);\\n    }\\n\\n    function unregisterContract(address _contract, uint256 index) public onlyOwner isRegisteredContract(_contract) {\\n        address[] storage arr = registeredOfType[registeredContracts[_contract]];\\n        arr[index] = arr[arr.length - 1];\\n        arr.pop();\\n        delete registeredContracts[_contract];\\n    }\\n\\n    function isRegistered(address _contract, uint256 _type) public view returns (bool) {\\n        return registeredContracts[_contract] == _type;\\n    }\\n\\n    function getAllRegisteredContractsOfType(uint256 _type) public view returns (address[] memory) {\\n        return registeredOfType[_type];\\n    }\\n}\"\r\n    }"
}