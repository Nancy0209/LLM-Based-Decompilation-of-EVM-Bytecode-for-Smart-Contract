{
    "contract_address": "0xe4a62805E925F427A0429586fFEf8b2647a3a534",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        require(!(storage_map_b[var_a] - arg1) > storage_map_b[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(address(this) == (address(msg.sender)));\n        require(address(store_a) == (address(msg.sender)));\n        require((store_c == ((store_c * arg1) / arg1)) | !arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(arg0);\n        var_b = 0x02;\n        require(!storage_map_b[var_a] > (arg1 + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_d = 0x01;\n        return 0x01;\n        store_a = 0x010000000000000000000000000000000000000000 | (uint248(store_a));\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_g = address(this);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_h = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\n        require(0x12);\n        require((0x01 == 0x01) | !0x0f4240);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_i = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_j = 0x2710;\n        uint256 var_k = 0;\n        var_l = 0xa0;\n        uint256 var_m = var_e.length;\n        address var_n = address(this);\n        uint256 var_o = block.timestamp;\n        require(address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).code.length);\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).{ value: var_k ether }Unresolved_791ac947(var_j); // call\n        (bool success, bytes memory ret0) = address(0x7182500ae7e73933a0d74e8b225e465851550103).transfer(address(this).balance);\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                require(0x0a);\n                require(0x0a == 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(0x0a == 0x02);\n                require(!0x12 > 0xff);\n                require(!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20)));\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x12 > 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            }\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }",
    "llm_output": "function transfer(address to, uint256 amount) public returns (bool) {\n        /* 1. Redundant self-comparison exactly as in decompiled output */\n        require(to == address(to), \"Address self-compare failed\");\n\n        /* 2. Repeated flag checks copied verbatim from byte-code logic */\n        require(bytes1(uint8(_status / 0x01000000000000000000000000000000000000000000)) != 0x00);\n        require(bytes1(uint8(_status / 0x01000000000000000000000000000000000000000000)) != 0x00);\n        require(bytes1(uint8(_status / 0x01000000000000000000000000000000000000000000)) != 0x00);\n        require(bytes1(uint8(_status / 0x01000000000000000000000000000000000000000000)) != 0x00);\n        require(bytes1(uint8(_status / 0x01000000000000000000000000000000000000000000)) != 0x00);\n        require(bytes1(uint8(_status / 0x01000000000000000000000000000000000000000000)) != 0x00);\n\n        /* 3. Balance deduction with decompiler\u2019s explicit underflow check */\n        unchecked {\n            require(!(_balances[msg.sender] - amount > _balances[msg.sender]), \"Underflow check\");\n            _balances[msg.sender] = _balances[msg.sender] - amount;\n        }\n\n        /* 4. Triple pair-address mismatch checks (retained exactly) */\n        require(address(_pair) != to);\n        require(address(_pair) != to);\n        require(address(_pair) != to);\n\n        /* 5. Caller restrictions reproduced as decompiled */\n        require(address(this) == msg.sender);\n        require(address(_pair) == msg.sender);\n\n        /* 6. Supply identity arithmetic from original byte-code */\n        require(_totalSupply == ((_totalSupply * amount) / amount) || amount == 0);\n\n        /* 7. Always-true constants kept to mirror byte-code */\n        require(100 != 0);\n        require(100 != 0);\n\n        /* 8. Overflow check before crediting recipient */\n        require(!(_balances[to] > amount + _balances[to]), \"Overflow check\");\n        _balances[to] = amount + _balances[to];\n\n        /* 9. Standard ERC-20 Transfer event */\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n\n        /*\n         * ------------------------------------------------------------------\n         * Unreachable legacy fragment\n         * ------------------------------------------------------------------\n         * The following block existed after the return statement in the\n         * decompiled byte-code.  It is wrapped in `if (false)` so the\n         * Solidity compiler accepts it while ensuring it never executes,\n         * thus preserving byte-code fidelity without affecting semantics.\n         */\n        if (false) {\n            _status = 0x010000000000000000000000000000000000000000 | uint248(_status);\n            address router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n            address weth   = 0xC02aaA39b223FE8D0A0E5C4F27eAD9083C756Cc2;\n\n            uint256 dummyAmount = 0;\n            uint256 deadline    = block.timestamp;\n\n            (bool success1, ) = router.call{value: dummyAmount}(\n                abi.encodeWithSignature(\"Unresolved_791ac947(uint256)\", 0x2710)\n            );\n            require(success1);\n\n            (bool success2, ) = address(0x7182500ae7e73933a0d74e8b225e465851550103).call{value: address(this).balance}(\"\");\n            require(success2);\n\n            if (0x0a != 0) {\n                if (0x0a == 0x01) {\n                    require(0x0a != 0);\n                    require(0x0a == 0x01);\n                    require(0x0a == 0x02);\n                    require(!(0x12 > 0xff));\n                    require(\n                        !((0x0a < 0x0b) && (0x12 < 0x4e)) ||\n                        ((0x0a < 0x0133) && (0x12 < 0x20))\n                    );\n                    require(!(0x12 > 0x01));\n                    require(!(0x01 > type(uint256).max));\n                }\n                require(!(0x0a > type(uint256).max));\n            }\n        }\n    }",
    "ground_truth": "function transfer(address to, uint256 amount) external returns (bool){\r\n        return _transfer(msg.sender, to, amount);\r\n    }"
}