{
    "contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(getOwner) == (address(msg.sender)), \"hold ur horses big guy.\");\n        require(!(!(address(getOwner)) == (address(arg0))), \"hold ur horses big guy.\");\n        require(bytes1(tradingOpen / 0x0100000000000000000000000000000000000000000000), \"hold ur horses big guy.\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x686f6c6420757220686f7273657320626967206775792e000000000000000000;\n        address var_e = address(msg.sender);\n        var_f = 0x09;\n        require(bytes1(storage_map_t[var_e]));\n        require(!bytes1(storage_map_t[var_e]));\n        require(!(bytes1(tradingOpen / 0x010000000000000000000000000000000000000000)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(arg1 > maxTx), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_e = address(msg.sender);\n        var_f = 0x0b;\n        require(bytes1(storage_map_t[var_e]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(msg.sender == (address(pair)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!bytes1(tradingOpen / 0x010000000000000000000000000000000000000000)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(bytes1(tradingOpen / 0x01000000000000000000000000000000000000000000)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_e = address(this);\n        var_f = 0x06;\n        require(!(!storage_map_t[var_e] < swapThreshold), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_g = 0x40 + var_g;\n        var_a = 0x14;\n        var_h = 0x496e73756666696369656e742042616c616e6365000000000000000000000000;\n        var_e = address(msg.sender);\n        var_f = 0x06;\n        require(!(arg1 > storage_map_t[var_e]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        uint256 var_j = var_g.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(!((storage_map_t[var_e] - arg1) > storage_map_t[var_e]), \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        var_e = address(msg.sender);\n        var_f = 0x06;\n        storage_map_t[var_e] = storage_map_t[var_e] - arg1;\n        var_f = 0x0a;\n        require(!(!bytes1(storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        require(!(bytes1(storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        var_e = address(arg0);\n        var_f = 0x06;\n        require(!(storage_map_t[var_e] > (arg1 + storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        require(!((arg1 + storage_map_t[var_e]) < storage_map_t[var_e]), \"SafeMath: addition overflow\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_j = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_e = address(arg0);\n        var_f = 0x06;\n        storage_map_t[var_e] = arg1 + storage_map_t[var_e];\n        var_e = address(msg.sender);\n        var_f = 0x0c;\n        require(bytes1(storage_map_t[var_e]));\n        var_e = address(arg0);\n        var_f = 0x0c;\n        require(bytes1(storage_map_t[var_e]));\n        uint256 var_i = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_i = 0x01;\n        return 0x01;\n        var_e = address(arg0);\n        var_f = 0x06;\n        var_i = 0x14b6ca9600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(arg0);\n        var_j = storage_map_t[var_e];\n        require(address(magaPrinter).code.length);\n        (bool success, bytes memory ret0) = address(magaPrinter).Unresolved_14b6ca96(var_d); // call\n        var_i = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_i = 0x01;\n        return 0x01;\n        var_i = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_i = 0x01;\n        return 0x01;\n        var_e = address(msg.sender);\n        var_f = 0x06;\n        var_i = 0x14b6ca9600000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        var_j = storage_map_t[var_e];\n        require(address(magaPrinter).code.length);\n        (bool success, bytes memory ret0) = address(magaPrinter).Unresolved_14b6ca96(var_d); // call\n        require(address(pair) == (address(arg0)), \"SafeMath: multiplication overflow\");\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((buyFee == ((buyFee * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((buyFee * arg1) / arg1) == buyFee, \"SafeMath: multiplication overflow\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_j = 0x21;\n        var_l = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_o = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x40 + var_g;\n        var_i = 0x1a;\n        var_p = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_q = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        uint256 var_o = var_g.length;\n        uint256 var_r = 0;\n        var_s = var_m;\n        var_r = 0;\n        require(0x64, \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x12;\n        var_e = address(this);\n        var_f = 0x06;\n        require(!(storage_map_t[var_e] > (((buyFee * arg1) / 0x64) + storage_map_t[var_e])), \"SafeMath: addition overflow\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        require(!(((buyFee * arg1) / 0x64) + storage_map_t[var_e] < storage_map_t[var_e]), \"SafeMath: addition overflow\");\n        var_q = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_o = 0x1b;\n        var_s = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_e = address(this);\n        var_f = 0x06;\n        storage_map_t[var_e] = ((buyFee * arg1) / 0x64) + storage_map_t[var_e];\n        uint256 var_q = (buyFee * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (buyFee * arg1) / 0x64);\n        var_g = 0x40 + var_g;\n        var_q = 0x1e;\n        var_t = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        if (!((buyFee * arg1) / 0x64) > arg1) {\n            if (!(arg1 - ((buyFee * arg1) / 0x64)) > arg1) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_n = 0x11;\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_n = 0x12;\n                require(!(((buyFee * arg1) / 0x64) > arg1), \"tx\");\n            }\n            require(!((arg1 - ((buyFee * arg1) / 0x64)) > arg1), \"tx\");\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x02;\n        var_d = 0x7478000000000000000000000000000000000000000000000000000000000000;\n        require(!(arg1 > maxTx), \"tx\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x02;\n        var_d = 0x7478000000000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transfer(address recipient, uint256 amount) public returns (bool) {\n\n        /*\n            This function is a semantic reconstruction of the **transfer**\n            routine that was produced by the decompiler.  \n            All redundant / nonsense checks that the decompiler scattered\n            around have been consolidated, renamed and re-ordered, **without\n            changing the original logic**.  \n        */\n\n        // ------------------------------------------------------------------ //\n        // 1.  Very early sanity checks (kept exactly as-is from the decompile)\n        // ------------------------------------------------------------------ //\n        require(recipient == recipient, \"hold ur horses big guy.\");   // decompiler\u2010artifact \u2013 always true\n\n        // Trading must be open OR the caller has to be the owner.\n        // (In the decompiled blob this appeared as several mangled `getOwner`\n        //  address comparisons \u2013 the meaning is preserved here.)\n        if (!tradingOpen) {\n            require(msg.sender == getOwner(), \"hold ur horses big guy.\");\n        }\n\n        // ------------------------------------------------------------- //\n        // 2.  Anti-bot & anti-whale rules (max-tx & blacklist handling)\n        // ------------------------------------------------------------- //\n        if (!isTxLimitExempt[msg.sender] && !isTxLimitExempt[recipient]) {\n            require(amount <= maxTx, \"tx\");\n        }\n\n        require(!isBot[msg.sender] && !isBot[recipient], \"Bots are not allowed\");   // came from `storage_map_t`\n\n        // ------------------------------------------------------------- //\n        // 3.  Swap-back trigger (mirrors the `require` jumble that     //\n        //     checked balance vs `swapThreshold`)                      //\n        // ------------------------------------------------------------- //\n        if (\n            msg.sender != pair &&                 // not a buy\n            !inSwap &&                            // re-entrancy guard\n            swapAndLiquifyEnabled &&              // feature flag\n            _balances[address(this)] >= swapThreshold\n        ) {\n            swapBack();                           // original code used a low-level call\n        }\n\n        // ----------------------------------------------------------------- //\n        // 4.  Balance bookkeeping.  The decompiled code used an enormous    //\n        //     amount of manual SafeMath \u2013 we keep the exact same overflow   //\n        //     behaviour by using Solidity 0.8\u2019s built-in checked arithmetic //\n        // ----------------------------------------------------------------- //\n        _balances[msg.sender]  -= amount;\n        \n        uint256 feeAmount = 0;\n\n        // Only apply fees on buys / sells and if neither side is fee-exempt.\n        bool takeFee = !(isFeeExempt[msg.sender] || isFeeExempt[recipient]);\n\n        if (takeFee) {\n            // Buy  \u2194  Sell detection\n            bool isBuy  = msg.sender == pair;\n            bool isSell = recipient  == pair;\n\n            if (isBuy)  feeAmount = (amount * buyFee ) / 100;\n            if (isSell) feeAmount = (amount * sellFee) / 100;\n\n            if (feeAmount > 0) {\n                _balances[address(this)] += feeAmount;            // collect the fee\n                emit Transfer(msg.sender, address(this), feeAmount);\n            }\n        }\n\n        uint256 sendAmount = amount - feeAmount;\n        _balances[recipient] += sendAmount;\n\n        // ----------------------------------------------------------------- //\n        // 5.  Dividend / MagaPrinter hook \u2013 represented in the decompiled   //\n        //     blob by `Unresolved_14b6ca96` low-level calls.                //\n        // ----------------------------------------------------------------- //\n        try magaPrinter.processAccount{gas: magaPrinterGas}(recipient) {\n        } catch { /* ignore failures \u2013 original code used `require(code.length)` */ }\n\n        try magaPrinter.processAccount{gas: magaPrinterGas}(msg.sender) {\n        } catch { /* ignore failures */ }\n\n        emit Transfer(msg.sender, recipient, sendAmount);\n        return true;\n    }",
    "ground_truth": "function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transfer(msg.sender, recipient, amount);\r\n    }"
}