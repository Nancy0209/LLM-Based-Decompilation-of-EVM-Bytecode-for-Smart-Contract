{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function getMintStats(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = uint64(storage_map_b[var_a] >> 0x40);\n        uint256 var_d = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + totalSupply;\n        var_e = maxSupply;\n        return abi.encodePacked(uint64(storage_map_b[var_a] >> 0x40), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + totalSupply, maxSupply);\n    }",
    "llm_output": "function getMintStats(address minter)\n    public\n    view\n    returns (\n        uint256 minterNumMinted,\n        uint256 currentTotalSupply,\n        uint256 maxSupply_\n    )\n{\n    // This check exists in the original bytecode (always true).\n    require(minter == address(minter), \"\");\n\n    // Retrieve packed data and extract the number minted (bits 64\u2012127).\n    uint256 packedData = _packedAddressData[minter];\n    minterNumMinted = uint64(packedData >> 64);\n\n    // Replicate the original arithmetic (`MAX_UINT256 + totalSupply`) which\n    // underflows to `totalSupply - 1` in an unchecked context.\n    unchecked {\n        currentTotalSupply = type(uint256).max + totalSupply();\n    }\n\n    maxSupply_ = maxSupply;\n}",
    "ground_truth": "function getMintStats(address minter)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 minterNumMinted,\\n            uint256 currentTotalSupply,\\n            uint256 maxSupply\\n        )\\n    {\\n        minterNumMinted = _numberMinted(minter);\\n        currentTotalSupply = _totalMinted();\\n        maxSupply = _maxSupply;\\n    }"
}