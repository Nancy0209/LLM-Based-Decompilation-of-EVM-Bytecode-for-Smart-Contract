{
    "contract_address": "0x2bAa6759eF2a982BBf5619E21eC244eA7a2Ee3C4",
    "heimdall_input": "function realtimeRewardPerBlock(address arg0, uint256 arg1) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        address var_b = keccak256(var_a);\n        require(!(!bytes1(storage_map_k[var_a] / 0x01)), \"SafeMath: multiplication overflow\");\n        require(!(!bytes1(storage_map_k[var_a] / 0x01)), \"SafeMath: multiplication overflow\");\n        uint256 var_c = 0;\n        uint256 var_d = 0;\n        return abi.encodePacked(0, 0);\n        var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        var_b = keccak256(var_a);\n        require(!(storage_map_af[var_a] == 0), \"SafeMath: multiplication overflow\");\n        require(!(block.timestamp < (storage_map_af[var_a])), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        var_b = keccak256(var_a);\n        require(!((block.timestamp - (storage_map_af[var_a])) == 0), \"SafeMath: multiplication overflow\");\n        var_a = address(arg0);\n        var_b = 0x16;\n        var_a = arg1;\n        var_b = keccak256(var_a);\n        require(!(0 < (storage_map_ag[var_a])), \"SafeMath: multiplication overflow\");\n        require(!(0 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_c = 0;\n        var_d = block.timestamp;\n        return abi.encodePacked(0, block.timestamp);\n        require(!((block.timestamp - (storage_map_af[var_a])) & (storage_map_n[var_a] > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / (block.timestamp - (storage_map_af[var_a]))))), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        require(block.timestamp - (storage_map_af[var_a]), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x12;\n        require((block.timestamp - (storage_map_af[var_a])) * (storage_map_n[var_a]) / (block.timestamp - (storage_map_af[var_a])) == (storage_map_n[var_a]), \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_f = ((0x04 + var_g) + 0x20) - (0x04 + var_g);\n        var_h = 0x21;\n        var_i = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_j = 0x7700000000000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function realtimeRewardPerBlock(address user, uint256 index) public view returns (uint256 reward, uint256 perBlock) {\n    // Identity checks preserved from decompiled output\n    require(user == address(user), \"Invalid address comparison\");\n    require(index == index, \"Invalid index comparison\");\n\n    // Duplicated overflow checks (mapped from decompiled logic)\n    require(stakersRecord[user][index].withdrawan, \"SafeMath: multiplication overflow\");\n    require(stakersRecord[user][index].withdrawan, \"SafeMath: multiplication overflow\");\n\n    // Decompiled logic returns zero values immediately\n    reward = 0;\n    perBlock = 0;\n    return (reward, perBlock);\n\n    // ---------------------------------------------------------------------\n    // The following unreachable code is intentionally retained to reflect\n    // the exact structure of the decompiled byte-code. Do NOT modify.\n    // ---------------------------------------------------------------------\n    require(stakersRecord[user][index].amount == 0, \"SafeMath: multiplication overflow\");\n    require(block.timestamp < stakersRecord[user][index].unstaketime, \"SafeMath: multiplication overflow\");\n    require(block.timestamp - stakersRecord[user][index].unstaketime == 0, \"SafeMath: multiplication overflow\");\n    require(0 < stakersRecord[user][index].reward, \"SafeMath: multiplication overflow\");\n    require(0 > type(uint256).max, \"SafeMath: multiplication overflow\");\n    require(block.timestamp - stakersRecord[user][index].unstaketime, \"SafeMath: multiplication overflow\");\n    require(\n        (block.timestamp - stakersRecord[user][index].unstaketime) * stakersRecord[user][index].reward\n            / (block.timestamp - stakersRecord[user][index].unstaketime) == stakersRecord[user][index].reward,\n        \"SafeMath: multiplication overflow\"\n    );\n\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function realtimeRewardPerBlock(address user, uint256 blockno) public view returns (uint256,uint256) {\r\n        uint256 ret;\r\n        uint256 commontimestamp;\r\n            if (\r\n                !stakersRecord[user][blockno].withdrawan &&\r\n                !stakersRecord[user][blockno].unstaked\r\n            ) {\r\n                uint256 val;\r\n                uint256 tempharvesttime = stakersRecord[user][blockno].lastharvesttime;\r\n                commontimestamp = block.timestamp;\r\n                if(tempharvesttime == 0){\r\n                    tempharvesttime = stakersRecord[user][blockno].staketime;\r\n                }\r\n                val = commontimestamp - tempharvesttime;\r\n                val = val.mul(stakersRecord[user][blockno].persecondreward);\r\n                if (val < stakersRecord[user][blockno].remainingreward) {\r\n                    ret += val;\r\n                } else {\r\n                    ret += stakersRecord[user][blockno].remainingreward;\r\n                }\r\n            }\r\n        return (ret,commontimestamp);\r\n    }"
}