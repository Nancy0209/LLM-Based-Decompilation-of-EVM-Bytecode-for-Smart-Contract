{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), CustomError_5fc483c5());\n        var_a = 0x5fc483c500000000000000000000000000000000000000000000000000000000;\n        require(address(arg0), CustomError_7448fbae());\n        store_m = (address(arg0)) | (uint96(store_m));\n        address var_a = address(arg0);\n        emit PotentialOwnerUpdated(address(arg0));\n        var_a = 0x7448fbae00000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transferOwnership(address newPotentialOwner) public payable {\n    // Redundant equality check preserved from original bytecode\n    require(newPotentialOwner == address(newPotentialOwner));\n\n    // Only the current owner can initiate an ownership transfer\n    if (msg.sender != _owner) revert OnlyOwner();\n\n    // The new potential owner cannot be the zero address\n    if (newPotentialOwner == address(0)) revert NewOwnerIsZeroAddress();\n\n    /*\n     * Persist the new potential owner.\n     * The contract stores this value in a packed 256-bit word where the lower\n     * 160 bits hold the address and the upper 96 bits hold auxiliary data.\n     * We replicate the original behaviour by updating only the lower 160 bits\n     * and leaving the upper 96 bits untouched.\n     */\n    _potentialOwnerPacked =\n        (uint256(uint160(newPotentialOwner))) |\n        (_potentialOwnerPacked & ~uint256(type(uint160).max));\n\n    emit PotentialOwnerUpdated(newPotentialOwner);\n}",
    "ground_truth": "function transferOwnership(address newPotentialOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        if (newPotentialOwner == address(0)) {\\n            revert NewOwnerIsZeroAddress();\\n        }\\n        potentialOwner = newPotentialOwner;\\n        emit PotentialOwnerUpdated(newPotentialOwner);\\n    }"
}