{
    "contract_address": "0xe3023a720d6f4d03b78763EDB3587f123565Cc6D",
    "heimdall_input": "function investorOrderIds(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x08;\n        address var_c = 0x20 + (var_c + (0x20 * storage_map_c[var_a]));\n        address var_d = storage_map_c[var_a];\n        require(!storage_map_c[var_a]);\n        var_a = keccak256(var_a);\n        address var_e = storage_map_c[var_a];\n        require((var_c + 0x20) + (0x20 * storage_map_c[var_a]) > (0x20 + (var_c + 0x20)));\n        var_e = 0x20;\n        address var_f = var_c.length;\n        return abi.encodePacked(0x20, var_c.length);\n    }",
    "llm_output": "function investorOrderIds(address investor) public view returns (uint256[] memory) {\n    assembly {\n        /* -------------------------------------------------------------\n           1.  Redundant self-equality check kept from the decompiled code\n        ------------------------------------------------------------- */\n        if iszero(eq(investor, investor)) {\n            revert(0, 0)\n        }\n\n        /* -------------------------------------------------------------\n           2.  Compute the storage slot that holds the dynamic array\n               investorOrderIds[investor].  In the original byte-code\n               this mapping lives at storage position 8.\n        ------------------------------------------------------------- */\n        mstore(0x00, investor)         // slot key (address)\n        mstore(0x20, 8)                // slot number (mapping position)\n        let lengthSlot := keccak256(0x00, 0x40)\n\n        /* -------------------------------------------------------------\n           3.  Load array length and preserve the   require(!value)\n               check that appeared in the decompiled output.\n               -->  require(!storage_map_c[var_a]);\n               Translates to: revert if array length is *not* zero.\n        ------------------------------------------------------------- */\n        let orderCount := sload(lengthSlot)\n        if iszero(iszero(orderCount)) {\n            revert(0, 0)\n        }\n\n        /* -------------------------------------------------------------\n           4.  Prepare return data in memory\n        ------------------------------------------------------------- */\n        let memPtr := mload(0x40)                // free memory pointer\n        mstore(memPtr, orderCount)               // write array length\n\n        let dataStart := add(memPtr, 0x20)       // first element position\n        let newFreePtr := add(dataStart, mul(orderCount, 0x20))\n\n        /* -------------------------------------------------------------\n           5.  Copy each uint256 element from storage to memory\n        ------------------------------------------------------------- */\n        for { let i := 0 } lt(i, orderCount) { i := add(i, 1) } {\n            let elementSlot := add(lengthSlot, add(1, i)) // slot of element i\n            let elementValue := sload(elementSlot)\n            mstore(add(dataStart, mul(i, 0x20)), elementValue)\n        }\n\n        /* -------------------------------------------------------------\n           6.  Update free-memory pointer\n        ------------------------------------------------------------- */\n        mstore(0x40, newFreePtr)\n\n        /* -------------------------------------------------------------\n           7.  Boundary check copied verbatim from the decompiled code\n               require((dataStart + 0x20) + (0x20 * orderCount) >\n                       (0x20 + (dataStart + 0x20)));\n        ------------------------------------------------------------- */\n        let lhs := add(add(dataStart, 0x20), mul(orderCount, 0x20))\n        let rhs := add(0x20, add(dataStart, 0x20))\n        if iszero(gt(lhs, rhs)) {\n            revert(0, 0)\n        }\n\n        /* -------------------------------------------------------------\n           8.  Return the in-memory uint256[] array\n        ------------------------------------------------------------- */\n        return(memPtr, sub(newFreePtr, memPtr))\n    }\n}",
    "ground_truth": "function investorOrderIds(address investor)\r\n        external\r\n        view\r\n        returns (uint256[] memory ids)\r\n    {\r\n        uint256[] memory arr = orderIds[investor];\r\n        return arr;\r\n    }"
}