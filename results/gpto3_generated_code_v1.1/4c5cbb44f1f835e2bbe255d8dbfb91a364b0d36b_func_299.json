{
    "contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B",
    "heimdall_input": "function mintForOG(uint256 arg0, bytes32[] arg1) public payable {\n        require(!arg1 > 0xffffffffffffffff);\n        require(!(arg1) > 0xffffffffffffffff);\n        require(store_d - 0x02, CustomError_2c5a460a());\n        store_d = 0x02;\n        require(0x01 == salePhase, CustomError_2c5a460a());\n        uint256 var_a = var_a + (0x20 + (0x20 * (arg1)));\n        uint256 var_b = (arg1);\n        var_c = msg.data[36:36];\n        uint256 var_d = 0;\n        address var_e = address(msg.sender << 0x60);\n        var_d = ((0x34 + var_a) - var_a) - 0x20;\n        var_a = 0x34 + var_a;\n        require(keccak256(var_c) < (var_c), CustomError_2c5a460a());\n        var_f = keccak256(var_c);\n        var_g = var_c;\n        require(0x01, CustomError_2c5a460a());\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_f = var_c;\n        var_g = keccak256(var_c);\n        require(0x01, CustomError_2c5a460a());\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x32;\n        require(keccak256(var_c) == merkleRootOG, CustomError_2c5a460a());\n        require(!(arg0 > 0x06), CustomError_2c5a460a());\n        var_i = 0x2c5a460a00000000000000000000000000000000000000000000000000000000;\n        address var_f = msg.sender;\n        var_g = 0x17;\n        require(!(storage_map_v[var_f] > (arg0 + storage_map_v[var_f])), CustomError_30db1f08());\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(!((arg0 + storage_map_v[var_f]) > 0x06), CustomError_30db1f08());\n        var_i = 0x30db1f0800000000000000000000000000000000000000000000000000000000;\n        var_i = 0xb05e92fa00000000000000000000000000000000000000000000000000000000;\n        var_b = 0x4ce630e100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_j = 0x20;\n        var_k = 0x1f;\n        var_l = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n    }",
    "llm_output": "function mintForOG(uint256 amount, bytes32[] calldata merkleProof) external payable nonReentrant {\n    // The OG phase is encoded as `1`\n    if (salePhase != 1) revert SaleNotInWLOGPhase();\n\n    // Verify the caller is in the OG list\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n    if (!MerkleProof.verify(merkleProof, merkleRootOG, leaf)) revert InvalidMerkleProof();\n\n    // Per-transaction limit\n    if (amount > 6) revert ExceedsMaxPerTransaction();\n\n    // Per-address limit\n    uint256 alreadyMinted = _mintedPerAddress[msg.sender];\n    if (alreadyMinted + amount > 6) revert ExceedsMaxPerAddress();\n\n    // Allocation for the public/OG pool\n    if (totalSupply() + amount > AmountForPublic) revert ExceedsMaxPerPublic();\n\n    // Payment check\n    uint256 requiredPayment = OG_PRICE * amount;\n    if (msg.value < requiredPayment) revert InsufficientPayment();\n\n    // Book-keeping and mint\n    _mintedPerAddress[msg.sender] = alreadyMinted + amount;\n    _safeMint(msg.sender, amount);\n}",
    "ground_truth": "function mintForOG(uint256 amount, bytes32[] calldata merkleProof) external payable nonReentrant {\\n        if (salePhase != 1) revert SaleNotInWLOGPhase();\\n        if (!_verifyMerkleProof(msg.sender, merkleProof, merkleRootOG)) revert InvalidMerkleProof();\\n        if (amount > maxPerAddressDuringMint) revert ExceedsMaxPerTransaction();\\n        if (_mintedPerAddress[msg.sender] + amount > maxPerAddressDuringMint) revert ExceedsMaxPerAddress();\\n        if (totalSupply() + amount > AmountForPublic) revert ExceedsMaxPerPublic();\\n        \\n        uint256 totalPrice = OG_PRICE * amount;\\n        if (msg.value < totalPrice) revert InsufficientPayment();\\n        \\n        _mintedPerAddress[msg.sender] += amount;\\n        _safeMint(msg.sender, amount);\\n    }"
}