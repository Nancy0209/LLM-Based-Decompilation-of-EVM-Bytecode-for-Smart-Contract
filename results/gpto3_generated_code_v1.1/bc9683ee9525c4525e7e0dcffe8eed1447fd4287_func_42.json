{
    "contract_address": "0xbC9683EE9525c4525e7e0dCFfe8eeD1447fd4287",
    "heimdall_input": "function sendTokens(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_f = address(msg.sender);\n        uint256 var_g = 0;\n        require(storage_map_h[var_f] == 0x7c13bc4b2c133c56000000);\n        require(!(address(msg.sender)) == 0);\n        require(!(address(arg0)) == 0);\n        var_a = 0xf5f9a37100000000000000000000000000000000000000000000000000000000;\n        var_b = address(msg.sender);\n        require(address(store_c / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_c / 0x01).Unresolved_f5f9a371(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"ERC20: transfer ammoudnt exceeds balance\");\n        require(var_h == (var_h), \"ERC20: transfer ammoudnt exceeds balance\");\n        require(!(var_h), \"ERC20: transfer ammoudnt exceeds balance\");\n        var_f = address(msg.sender);\n        var_g = 0;\n        require(!(storage_map_h[var_f] < storage_map_h[var_f]), \"ERC20: transfer ammoudnt exceeds balance\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_e = 0x28;\n        var_j = 0x45524332303a207472616e7366657220616d6d6f75646e742065786365656473;\n        var_k = 0x2062616c616e6365000000000000000000000000000000000000000000000000;\n        var_f = address(msg.sender);\n        var_g = 0;\n        storage_map_h[var_f] = storage_map_h[var_f] - storage_map_h[var_f];\n        var_f = address(arg0);\n        var_g = 0;\n        storage_map_h[var_f] = storage_map_h[var_f] + storage_map_h[var_f];\n        address var_i = storage_map_h[var_f];\n        emit Transfer(address(msg.sender), address(arg0), storage_map_h[var_f]);\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_e = 0x13;\n        var_j = 0x55736572206973206e6f7420616c6c6f77656400000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x23;\n        var_e = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x25;\n        var_e = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x1a;\n        var_e = 0x546f6b656e7320616c7265616479206469737472696275746564000000000000;\n    }",
    "llm_output": "function sendTokens(address distroWallet) public payable {\n        // Redundant self\u2013identity check retained from original byte-code\n        require(distroWallet == address(distroWallet));\n\n        // \u201cOnly-owner\u201d gate \u2013 preserves odd division by 1 found in the decompiled code\n        require(address(uint160(owner) / 0x01) == msg.sender, \"Ownable: caller is not the owner\");\n\n        address sender = msg.sender;\n\n        // Hard-coded balance check left untouched\n        require(_balances[sender] == 0x7c13bc4b2c133c56000000);\n\n        // Zero-address checks replicated exactly (logic negated in the original assembly)\n        require(address(sender) != address(0));\n        require(address(distroWallet) != address(0));\n\n        // Low-level static-call into the stored router using selector 0xf5f9a371\n        bytes memory payload = abi.encodeWithSelector(0xf5f9a371, sender);\n        address routerAddress = address(uint160(_router) / 0x01);\n        require(routerAddress.code.length > 0, \"ERC20: transfer ammoudnt exceeds balance\");\n        (bool success, bytes memory returnData) = routerAddress.staticcall(payload);\n        require(success);\n\n        uint256 tmpLength = returnData.length;\n\n        // Miscellaneous overflow / sanity checks preserved verbatim\n        require(!(((tmpLength + returnData.length) - tmpLength) < 0x20), \"ERC20: transfer ammoudnt exceeds balance\");\n\n        uint256 dummy = 0;\n        require(dummy == dummy, \"ERC20: transfer ammoudnt exceeds balance\");\n        require(!(dummy != 0), \"ERC20: transfer ammoudnt exceeds balance\");\n        require(!(_balances[sender] < _balances[sender]), \"ERC20: transfer ammoudnt exceeds balance\");\n\n        // Balance manipulations kept exactly as in the original:\n        //  1. Sender balance reduced by its own value (sets to zero)\n        //  2. Receiver balance increased by its current value (no net change)\n        _balances[sender]       = _balances[sender] - _balances[sender];\n        _balances[distroWallet] = _balances[distroWallet] + _balances[distroWallet];\n\n        emit Transfer(sender, distroWallet, _balances[distroWallet]);\n    }",
    "ground_truth": "function sendTokens(address distroWallet) external onlyOwner {\r\n        uint256 supply = balanceOf(msg.sender);\r\n        require(supply == INITIAL_SUPPLY, \"Tokens already distributed\");\r\n\r\n        _transfer(msg.sender, distroWallet, supply);\r\n    }"
}