{
    "contract_address": "0x30F674e5399B6493A6096d239153b21331fbC670",
    "heimdall_input": "function manualsend() public {\n        require(address(msg.sender) == (address(store_u)));\n        require(address(msg.sender) == (address(store_v)));\n        (bool success, bytes memory ret0) = address(store_v).transfer(address(this).balance);\n        if (ret0.length == 0) {\n            uint256 var_a = var_a + (uint248(ret0.length + 0x3f));\n            uint256 var_b = ret0.length;\n        }\n    }",
    "llm_output": "function manualsend() external {\n    // Require the caller to be both designated wallets (as in the original byte-code logic)\n    require(msg.sender == marketingWallet, \"manualsend: unauthorized\");\n    require(msg.sender == developmentWallet, \"manualsend: unauthorized\");\n\n    // Forward the entire ETH balance held by this contract to the development wallet\n    (bool success, bytes memory returnData) = payable(developmentWallet).call{value: address(this).balance}(\"\");\n    // Preserve the `success` variable to silence compiler warnings\n    success;\n\n    // Decompiler artefact \u2013 kept to maintain byte-level parity; no functional impact\n    if (returnData.length == 0) {\n        uint256 _placeholder1 = uint256(returnData.length + 0x3f);\n        uint256 _placeholder2 = returnData.length;\n        // Reference placeholders to avoid Solidity warnings\n        _placeholder1;\n        _placeholder2;\n    }\n}",
    "ground_truth": "function manualsend() external {\r\n        require(\r\n            _msgSender() == developmentWallet ||\r\n                _msgSender() == marketingWallet\r\n        );\r\n        bool success;\r\n        (success, ) = address(marketingWallet).call{\r\n            value: address(this).balance\r\n        }(\"\");\r\n    }"
}