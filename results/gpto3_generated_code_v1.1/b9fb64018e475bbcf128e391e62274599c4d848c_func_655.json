{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!address(0xaaeb6d7670e522a718067333cd4e).code.length, CustomError_df2d9b42());\n        require(0x01 > arg1, CustomError_df2d9b42());\n        require(!(arg1 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x04;\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(0 - storage_map_b[var_a], CustomError_cfb3b942());\n        require(address(storage_map_b[var_a]) == msg.sender, CustomError_cfb3b942());\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x07;\n        var_a = msg.sender;\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_c = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1;\n        var_b = 0x04;\n        if (0 - storage_map_b[var_a]) {\n            var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1);\n            var_b = 0x04;\n            if (0 - storage_map_b[var_a]) {\n                var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1));\n                var_b = 0x04;\n                if (0 - storage_map_b[var_a]) {\n                }\n            }\n        }\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xc617113400000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        address var_e = address(arg0);\n        (bool success, bytes memory ret0) = address(0xaaeb6d7670e522a718067333cd4e).Unresolved_c6171134(var_d); // staticcall\n        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));\n        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_ede71dcc());\n        require(var_f.length == var_f.length, CustomError_ede71dcc());\n        require(var_f.length, CustomError_ede71dcc());\n        var_g = 0xede71dcc00000000000000000000000000000000000000000000000000000000;\n        var_e = address(arg0);\n    }",
    "llm_output": "function approve(address operator, uint256 tokenId) public payable {\n    /* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       NOTE:\n       The seemingly-redundant and unconventional checks below (e.g. ensuring\n       the Operator-Filter-Registry address has zero code, the multiple under-\n       flows, etc.) are artifacts of the original on-chain byte-code and therefore\n       MUST be preserved verbatim to maintain byte-for-byte behavioural parity.\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n\n    // Redundant self\u2013equality check preserved from the original logic\n    require(operator == address(operator));\n\n    // Registry must be undeployed (matches original byte-code path)\n    require(\n        !address(0xaaeb6d7670e522a718067333cd4e).code.length,\n        CustomError_df2d9b42()\n    );\n\n    // `tokenId` must be < 1   (original comparison was `0x01 > tokenId`)\n    require(0x01 > tokenId, CustomError_df2d9b42());\n\n    // `tokenId` must be \u2265 totalSupply  (original logic: `!(tokenId < totalSupply)`)\n    require(!(tokenId < totalSupply), CustomError_df2d9b42());\n\n    uint256 id = tokenId;\n\n    // --------------------------------------------------------------------- //\n    //                     Storage slot-specific branch checks               //\n    // --------------------------------------------------------------------- //\n    // These \u201c0 \u2013 storage\u201d style checks came directly from the decompiler and\n    // are retained exactly, even though they look nonsensical in high-level\n    // Solidity.  They operate on packed ownership / approval storage words.\n    // --------------------------------------------------------------------- //\n\n    require(uint256(uint8(_packedOwnerships[id])) == 0, CustomError_df2d9b42());\n\n    // Caller must be the owner (original error selector: 0xcfb3b942)\n    require(_packedOwnerships[id] != 0, CustomError_cfb3b942());\n    require(\n        address(uint160(_packedOwnerships[id])) == msg.sender,\n        CustomError_cfb3b942()\n    );\n\n    address owner = address(uint160(_packedOwnerships[id]));\n\n    // Extra packed-data check preserved verbatim\n    require(uint256(uint8(_packedAddressData[msg.sender])) != 0, CustomError_cfb3b942());\n\n    // --------------------------------------------------------------------- //\n    //                              Set Approval                             //\n    // --------------------------------------------------------------------- //\n    _tokenApprovals[tokenId] = operator;\n    emit Approval(owner, operator, tokenId);\n\n    // The original byte-code set the same approval & emitted the same event\n    // twice; we mirror that behaviour here.\n    _tokenApprovals[tokenId] = operator;\n    emit Approval(owner, operator, tokenId);\n\n    // --------------------------------------------------------------------- //\n    //   No-op loop chain preserved (series of under-flowing storage checks) //\n    // --------------------------------------------------------------------- //\n    id = type(uint256).max + tokenId;\n    if (_packedOwnerships[id] != 0) {\n        id = type(uint256).max + id;\n        if (_packedOwnerships[id] != 0) {\n            id = type(uint256).max + id;\n            if (_packedOwnerships[id] != 0) {\n                // intentionally left blank (behavioural parity)\n            }\n        }\n    }\n\n    // --------------------------------------------------------------------- //\n    //                External static-call preserved verbatim                //\n    // --------------------------------------------------------------------- //\n    address self = address(this);\n    (bool /* success */, ) = address(0xaaeb6d7670e522a718067333cd4e).staticcall(\n        abi.encodeWithSelector(0xc6171134, self)\n    );\n}",
    "ground_truth": "function approve(address operator, uint256 tokenId)\\n        public\\n        override\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }"
}