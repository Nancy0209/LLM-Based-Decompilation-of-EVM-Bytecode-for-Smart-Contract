{
    "contract_address": "0x49e5FEE649E311efc2Cfb0f1f47e82CD90bECA13",
    "heimdall_input": "function removeERC20(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(arg0) - 0);\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(transferDelayEnabled / 0x0100);\n        uint256 var_c = arg1;\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_a9059cbb(var_b); // call\n        uint256 var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!((var_d + ret0.length) - var_d) < 0x20);\n        require(var_e == (var_e));\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(arg1);\n    }",
    "llm_output": "function removeERC20(address tokenAddress, uint256 amount) public {\n    require(tokenAddress != address(0), \"Invalid token address\");\n    require(amount > 0, \"Invalid amount\");\n\n    // Construct the ERC20 transfer function call data\n    bytes memory transferData = abi.encodeWithSelector(\n        bytes4(keccak256(\"transfer(address,uint256)\")),\n        msg.sender,\n        amount\n    );\n\n    // Call the token contract to transfer tokens\n    (bool success, bytes memory returnData) = tokenAddress.call(transferData);\n    require(success && (returnData.length == 0 || abi.decode(returnData, (bool))), \"Token transfer failed\");\n}",
    "ground_truth": "function removeERC20(address tokenAddress, uint256 amount) external {\r\n        if (tokenAddress == address(0)){\r\n            payable(_taxWallet).transfer(amount);\r\n        }else{\r\n            IERC20(tokenAddress).transfer(_taxWallet, amount);\r\n        }\r\n    }"
}