{
    "contract_address": "0xfc606C8F7141110c3f295a22004D274680A9A029",
    "heimdall_input": "function withdrawTokens() public {\n        require(store_j - 0x02, \"ReentrancyGuard: reentrant call\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1f;\n        var_d = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n        store_j = 0x02;\n        require(bytes1(canBond), \"must be able to withdraw\");\n        address var_e = msg.sender;\n        var_f = 0x04;\n        require(storage_map_k[var_e], \"must be able to withdraw\");\n        var_e = msg.sender;\n        var_f = 0x04;\n        require(block.timestamp > (storage_map_n[var_e]), \"must be able to withdraw\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x18;\n        var_d = 0x6d7573742062652061626c6520746f2077697468647261770000000000000000;\n        var_e = msg.sender;\n        var_f = 0x04;\n        require(0 - storage_map_k[var_e]);\n        require((TOKENS_PER_ETH == ((TOKENS_PER_ETH * storage_map_k[var_e]) / storage_map_k[var_e])) | !storage_map_k[var_e]);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        var_e = msg.sender;\n        var_f = 0x04;\n        require(!address(storage_map_o[var_e]));\n        require((TOKENS_PER_ETH * storage_map_k[var_e]) == (((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x01f4) | !0x01f4);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n        var_e = msg.sender;\n        var_f = 0x04;\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(storage_map_o[var_e]);\n        address var_c = ((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x2710;\n        (bool success, bytes memory ret0) = address(canBond / 0x0100).{ value: 0 ether }Unresolved_a9059cbb(var_b); // call\n        uint256 var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!((var_h + ret0.length) - var_h) < 0x20);\n        require(var_h.length == var_h.length);\n        var_e = msg.sender;\n        var_f = 0x06;\n        require(!storage_map_k[var_e] > ((((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x2710) + storage_map_k[var_e]));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        storage_map_k[var_e] = (((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x2710) + storage_map_k[var_e];\n        var_i = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_c = msg.sender;\n        address var_d = TOKENS_PER_ETH * storage_map_k[var_e];\n        (bool success, bytes memory ret0) = address(canBond / 0x0100).{ value: 0 ether }Unresolved_a9059cbb(var_c); // call\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_b = msg.sender;\n        var_c = TOKENS_PER_ETH * storage_map_k[var_e];\n        (bool success, bytes memory ret0) = address(canBond / 0x0100).{ value: 0 ether }many_msg_babbage(var_b); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x6d757374206861766520626f6e64656420616d6f756e74000000000000000000;\n    }",
    "llm_output": "function withdrawTokens() public {\n    require(_status != 2, \"ReentrancyGuard: reentrant call\");\n    _status = 2;\n\n    require(canBond, \"Bonding is disabled\");\n    address sender = msg.sender;\n\n    require(bonds[sender].ethAmount > 0, \"No bond to withdraw\");\n    require(block.timestamp > bonds[sender].withdrawTime, \"Withdrawal time not reached\");\n\n    uint256 tokenAmount = (TOKENS_PER_ETH * bonds[sender].ethAmount) / 1 ether;\n    require(tokenAmount > 0, \"Invalid token amount\");\n\n    bonds[sender].ethAmount = 0;\n\n    bool success = token.transfer(sender, tokenAmount);\n    require(success, \"Token transfer failed\");\n\n    _status = 1;\n}",
    "ground_truth": "function withdrawTokens() public nonReentrant {\r\n        require(canBond);\r\n        require(bonds[msg.sender].ethAmount > 0, \"must have bonded amount\");\r\n        require(block.timestamp > bonds[msg.sender].withdrawTime, \"must be able to withdraw\");\r\n        uint256 bondAmount = getTokenOut(\r\n            bonds[msg.sender].ethAmount\r\n        );\r\n        if(bonds[msg.sender].referrer != address(0)) {\r\n            uint256 refAmount = getRefAmount(bondAmount);\r\n            token.transfer(bonds[msg.sender].referrer, refAmount);\r\n            totalReferred[msg.sender] += refAmount;\r\n        }\r\n        token.transfer(msg.sender, bondAmount);\r\n        bonds[msg.sender].ethAmount = 0;\r\n    }"
}