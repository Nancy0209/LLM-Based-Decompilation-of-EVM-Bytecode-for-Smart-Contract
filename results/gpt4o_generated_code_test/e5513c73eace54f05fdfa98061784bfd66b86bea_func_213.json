{
    "contract_address": "0xE5513c73eaCe54F05fDfa98061784bfd66b86bEA",
    "heimdall_input": "function removeERC20(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(this) == (address(arg0)));\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(this);\n        require(address(arg0).code.length);\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        var_d = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_e = address(store_h);\n        uint256 var_f = var_c.length;\n        require(address(arg0).code.length);\n        (bool success, bytes memory ret0) = address(arg0).{ value: 0 ether }Unresolved_a9059cbb(var_e); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_c.length == var_c.length);\n        (bool success, bytes memory ret0) = address(store_h).transfer(address(this).balance);\n    }",
    "llm_output": "function removeERC20(address tokenAddress) public {\n    require(tokenAddress != address(0), \"Invalid token address\");\n    require(tokenAddress != address(this), \"Cannot remove contract's own token\");\n\n    // Check balance of the contract for the given token\n    bytes4 balanceOfSelector = bytes4(keccak256(\"balanceOf(address)\"));\n    address contractAddress = address(this);\n    require(tokenAddress.code.length > 0, \"Token address is not a contract\");\n    (bool balanceSuccess, bytes memory balanceData) = tokenAddress.staticcall(abi.encodeWithSelector(balanceOfSelector, contractAddress));\n    require(balanceSuccess, \"Failed to fetch token balance\");\n    uint256 tokenBalance = abi.decode(balanceData, (uint256));\n    require(tokenBalance > 0, \"No tokens to remove\");\n\n    // Transfer tokens to the owner\n    bytes4 transferSelector = bytes4(keccak256(\"transfer(address,uint256)\"));\n    address ownerAddress = _owner; // Assuming `_owner` is the contract owner's address\n    require(tokenAddress.code.length > 0, \"Token address is not a contract\");\n    (bool transferSuccess, ) = tokenAddress.call(abi.encodeWithSelector(transferSelector, ownerAddress, tokenBalance));\n    require(transferSuccess, \"Token transfer failed\");\n\n    // Transfer remaining Ether balance to the owner\n    (bool etherTransferSuccess, ) = ownerAddress.call{value: address(this).balance}(\"\");\n    require(etherTransferSuccess, \"Ether transfer failed\");\n}",
    "ground_truth": "function removeERC20(address _token) external {\r\n        if(_token != address(this)){\r\n            IERC20(_token).transfer(fundAddress, IERC20(_token).balanceOf(address(this)));\r\n            fundAddress.transfer(address(this).balance);\r\n        }\r\n    }"
}