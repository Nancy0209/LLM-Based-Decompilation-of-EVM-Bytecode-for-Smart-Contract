{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function unregisterContract(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(!(bytes1(isClaimable / 0x0100)), \"Contract is not registered\");\n        address var_a = msg.sender;\n        var_b = 0x66;\n        var_a = uint32(msg.data[0]);\n        address var_b = keccak256(var_a);\n        require(address(owner) == msg.sender, \"Contract is not registered\");\n        require(bytes1(storage_map_b[var_a]), \"Contract is not registered\");\n        var_a = address(arg0);\n        var_b = 0x68;\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = address(arg0);\n        var_b = 0x68;\n        var_a = storage_map_b[var_a];\n        var_b = 0x69;\n        require(!(storage_map_b[var_a] < 0x01), \"Contract is not registered\");\n        require((storage_map_b[var_a] - 0x01) < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        require(arg1 < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_l[var_a] = (address(storage_map_m[var_a] / 0x01) * 0x01) | (uint96(storage_map_l[var_a]));\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_n[storage_map_b[var_a] + keccak256(var_a)] = uint96(storage_map_n[storage_map_b[var_a] + keccak256(var_a)]);\n        storage_map_b[var_a] = storage_map_b[var_a] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_a = address(arg0);\n        var_b = 0x68;\n        storage_map_b[var_a] = 0;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x31;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1a;\n        var_g = 0x436f6e7472616374206973206e6f742072656769737465726564000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        var_a = address(arg0);\n        var_b = 0x68;\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = address(arg0);\n        var_b = 0x68;\n        var_a = storage_map_b[var_a];\n        var_b = 0x69;\n        require(!(storage_map_b[var_a] < 0x01), \"Contract is not registered\");\n        require((storage_map_b[var_a] - 0x01) < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        require(arg1 < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_l[var_a] = (address(storage_map_m[var_a] / 0x01) * 0x01) | (uint96(storage_map_l[var_a]));\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_n[storage_map_b[var_a] + keccak256(var_a)] = uint96(storage_map_n[storage_map_b[var_a] + keccak256(var_a)]);\n        storage_map_b[var_a] = storage_map_b[var_a] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_a = address(arg0);\n        var_b = 0x68;\n        storage_map_b[var_a] = 0;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x31;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1a;\n        var_g = 0x436f6e7472616374206973206e6f742072656769737465726564000000000000;\n    }",
    "llm_output": "function unregisterContract(address contractAddress, uint256 index) public {\n    require(contractAddress == address(contractAddress), \"Invalid address\");\n    require(!isClaimable, \"Contract is not registered\");\n    require(msg.sender == owner, \"Not owner or able to bypass\");\n    require(storage_map_b[contractAddress] != 0, \"Contract is not registered\");\n\n    uint256 contractIndex = storage_map_b[contractAddress];\n    require(contractIndex >= 1, \"Contract is not registered\");\n    require(contractIndex - 1 < contractIndex, \"Contract is not registered\");\n\n    bytes32 contractHash = keccak256(abi.encodePacked(contractAddress));\n    require(index < storage_map_b[contractHash], \"Contract is not registered\");\n\n    storage_map_l[contractHash] = (address(storage_map_m[contractHash] / 1) * 1) | uint96(storage_map_l[contractHash]);\n    require(storage_map_b[contractHash] != 0, \"Contract is not registered\");\n\n    storage_map_n[storage_map_b[contractHash] + contractHash] = uint96(storage_map_n[storage_map_b[contractHash] + contractHash]);\n    storage_map_b[contractHash] = storage_map_b[contractHash] + type(uint256).max;\n\n    storage_map_b[contractAddress] = 0;\n}",
    "ground_truth": "function unregisterContract(address _contract, uint256 index) public onlyOwner isRegisteredContract(_contract) {\\n        address[] storage arr = registeredOfType[registeredContracts[_contract]];\\n        arr[index] = arr[arr.length - 1];\\n        arr.pop();\\n        delete registeredContracts[_contract];\\n    }"
}