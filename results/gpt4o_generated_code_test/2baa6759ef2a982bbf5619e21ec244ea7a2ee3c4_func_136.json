{
    "contract_address": "0x2bAa6759eF2a982BBf5619E21eC244eA7a2Ee3C4",
    "heimdall_input": "function unstake(uint256 arg0) public payable {\n        require(arg0 == arg0);\n        address var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        address var_b = keccak256(var_a);\n        require(!(bytes1(storage_map_k[var_a] / 0x0100)), \"already unstaked\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x10;\n        var_g = 0x616c726561647920756e7374616b656400000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        require(storage_map_ad[var_a] < block.timestamp, \"cannot unstake after before duration\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x63616e6e6f7420756e7374616b65206166746572206265666f72652064757261;\n        var_h = 0x74696f6e00000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        require(bytes1(storage_map_k[var_a] / 0x01));\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        storage_map_k[var_a] = (0x01 * 0x0100) | (uint248(storage_map_k[var_a]));\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        var_c = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        address var_f = storage_map_ae[var_a];\n        require(address(stakeToken / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(stakeToken / 0x01).{ value: 0 ether }Unresolved_a9059cbb(var_d); // call\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        require(!(totalUnStakedToken > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - (storage_map_ae[var_a]))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(!((totalUnStakedToken + (storage_map_ae[var_a])) < totalUnStakedToken), \"SafeMath: addition overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x1b;\n        var_g = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        require(!(bytes1(storage_map_k[var_a] / 0x01)), \"already withdrawan\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x12;\n        var_g = 0x616c7265616479207769746864726177616e0000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        require(!(bytes1(storage_map_k[var_a] / 0x0100)), \"already unstaked\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x10;\n        var_g = 0x616c726561647920756e7374616b656400000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        require(bytes1(storage_map_k[var_a] / 0x01));\n        require(bytes1(storage_map_k[var_a] / 0x01));\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        storage_map_af[var_a] = 0;\n        var_c = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        var_f = 0;\n        require(address(rewardToken / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(rewardToken / 0x01).{ value: var_f ether }Unresolved_a9059cbb(var_d); // call\n        require(!(totalClaimedRewardToken > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(!((totalClaimedRewardToken + 0) < totalClaimedRewardToken), \"SafeMath: addition overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x1b;\n        var_g = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        totalClaimedRewardToken = totalClaimedRewardToken + 0;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        var_a = arg0;\n        var_b = keccak256(var_a);\n        uint256 var_e = 0x40 + var_e;\n        var_c = 0x1e;\n        var_j = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(0 > (storage_map_ag[var_a])), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_h = var_e.length;\n        require(!(0 > var_e.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_l = 0;\n        var_m = var_n;\n        require(!(0x20 > var_e.length), \"SafeMath: subtraction overflow\");\n        var_l = 0;\n        if (!(storage_map_ag[var_a]) < 0) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_i = 0x11;\n            var_a = address(msg.sender);\n            var_b = 0x16;\n            var_a = arg0;\n            var_b = keccak256(var_a);\n            require(!(storage_map_ag[var_a]) < 0);\n        }\n    }",
    "llm_output": "function unstake(uint256 index) public payable {\n    require(index == index); // Placeholder check, likely decompiler artifact\n    address stakerAddress = msg.sender;\n    bytes32 stakeKey = keccak256(abi.encodePacked(stakerAddress, index));\n\n    require(!(stakersRecord[stakerAddress][index].unstaked), \"already unstaked\");\n    require(stakersRecord[stakerAddress][index].unstaketime < block.timestamp, \"cannot unstake before duration\");\n\n    stakersRecord[stakerAddress][index].unstaked = true;\n\n    uint256 stakeAmount = stakersRecord[stakerAddress][index].amount;\n    require(stakeToken.transfer(stakerAddress, stakeAmount), \"Token transfer failed\");\n\n    totalUnStakedToken += stakeAmount;\n    require(totalUnStakedToken >= stakeAmount, \"SafeMath: addition overflow\");\n\n    uint256 rewardAmount = stakersRecord[stakerAddress][index].rewardTokenAmount;\n    require(rewardToken.transfer(stakerAddress, rewardAmount), \"Reward token transfer failed\");\n\n    totalClaimedRewardToken += rewardAmount;\n    require(totalClaimedRewardToken >= rewardAmount, \"SafeMath: addition overflow\");\n\n    emit UNSTAKE(stakerAddress, stakeAmount);\n}",
    "ground_truth": "function unstake(uint256 index) public {\r\n        require(!stakersRecord[msg.sender][index].unstaked, \"already unstaked\");\r\n        require(\r\n            stakersRecord[msg.sender][index].unstaketime < block.timestamp,\r\n            \"cannot unstake after before duration\"\r\n        );\r\n\r\n        if(!stakersRecord[msg.sender][index].withdrawan){\r\n            harvest(index);\r\n        }\r\n        stakersRecord[msg.sender][index].unstaked = true;\r\n\r\n        stakeToken.transfer(\r\n            msg.sender,\r\n            stakersRecord[msg.sender][index].amount\r\n        );\r\n        \r\n        totalUnStakedToken = totalUnStakedToken.add(\r\n            stakersRecord[msg.sender][index].amount\r\n        );\r\n        Stakers[msg.sender].totalUnstakedTokenUser = Stakers[msg.sender]\r\n            .totalUnstakedTokenUser\r\n            .add(stakersRecord[msg.sender][index].amount);\r\n\r\n        emit UNSTAKE(\r\n            msg.sender,\r\n            stakersRecord[msg.sender][index].amount\r\n        );\r\n    }"
}