{
    "contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b",
    "heimdall_input": "function tokenURI(uint256 arg0) public view {\n        require(!(!0x01 > arg0), \"ERC721Metadata: URI query for nonexistent token\");\n        require(!(arg0 < totalSupply), \"ERC721Metadata: URI query for nonexistent token\");\n        uint256 var_a = arg0;\n        var_b = 0x04;\n        require(!(bytes1(storage_map_n[var_a])), \"ERC721Metadata: URI query for nonexistent token\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2f;\n        var_f = 0x4552433732314d657461646174613a2055524920717565727920666f72206e6f;\n        var_g = 0x6e6578697374656e7420746f6b656e0000000000000000000000000000000000;\n        if (ownere) {\n            require(bytes1(ownere), \"ERC721Metadata: URI query for nonexistent token\");\n            require(bytes1(store_w), \"ERC721Metadata: URI query for nonexistent token\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x22;\n            uint256 var_i = var_i + (0x20 + (((0x1f + (store_w >> 0x01)) / 0x20) * 0x20));\n            bytes32 var_c = store_w >> 0x01;\n            require(!(bytes1(store_w) == ((store_w >> 0x01) < 0x20)), \"ERC721Metadata: URI query for nonexistent token\");\n            require(bytes1(store_w), \"ERC721Metadata: URI query for nonexistent token\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x22;\n            require(!(bytes1(store_w) == ((store_w >> 0x01) < 0x20)), \"ERC721Metadata: URI query for nonexistent token\");\n            require(!(store_w >> 0x01), \"ERC721Metadata: URI query for nonexistent token\");\n            var_a = 0x10;\n            uint256 var_j = storage_map_n[var_a];\n            require(0x1f < (store_w >> 0x01), \"ERC721Metadata: URI query for nonexistent token\");\n            require((0x20 + var_i) + (store_w >> 0x01) > (0x20 + (0x20 + var_i)), \"ERC721Metadata: URI query for nonexistent token\");\n            require(var_i.length > 0, \"ERC721Metadata: URI query for nonexistent token\");\n            require(arg0 < 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000, \"ERC721Metadata: URI query for nonexistent token\");\n            require((arg0 / 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000) < 0x04ee2d6d415b85acef8100000000, \"ERC721Metadata: URI query for nonexistent token\");\n            require(((arg0 / 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000) / 0x04ee2d6d415b85acef8100000000) < 0x2386f26fc10000, \"ERC721Metadata: URI query for nonexistent token\");\n            require((((arg0 / 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000) / 0x04ee2d6d415b85acef8100000000) / 0x2386f26fc10000) < 0x05f5e100, \"ERC721Metadata: URI query for nonexistent token\");\n            require(((((arg0 / 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000) / 0x04ee2d6d415b85acef8100000000) / 0x2386f26fc10000) / 0x05f5e100) < 0x2710, \"ERC721Metadata: URI query for nonexistent token\");\n            require((((((arg0 / 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000) / 0x04ee2d6d415b85acef8100000000) / 0x2386f26fc10000) / 0x05f5e100) / 0x2710) < 0x64, \"ERC721Metadata: URI query for nonexistent token\");\n            require(((((((arg0 / 0x184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000) / 0x04ee2d6d415b85acef8100000000) / 0x2386f26fc10000) / 0x05f5e100) / 0x2710) / 0x64) < 0x0a, \"ERC721Metadata: URI query for nonexistent token\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x41;\n            var_j = 0x80;\n            var_i = var_i + 0xa0;\n            require(!(0x80 > 0xffffffffffffffff), \"ERC721Metadata: URI query for nonexistent token\");\n            var_k = 0x3031323334353637383961626364656600000000000000000000000000000000;\n            require(!0x80, \"ERC721Metadata: URI query for nonexistent token\");\n            require(arg0 / 0x0a, \"ERC721Metadata: URI query for nonexistent token\");\n            uint256 var_l = 0;\n            require(!(0 > var_i.length), \"ERC721Metadata: URI query for nonexistent token\");\n            uint256 var_m = 0;\n            require(!(0 > var_i.length), \"ERC721Metadata: URI query for nonexistent token\");\n            require(bytes1(store_o), \"ERC721Metadata: URI query for nonexistent token\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x22;\n            require(!(bytes1(store_o) == ((store_o >> 0x01) < 0x20)), \"ERC721Metadata: URI query for nonexistent token\");\n            require(!(bytes1(store_o)), \"ERC721Metadata: URI query for nonexistent token\");\n            var_a = 0x11;\n            require(bytes1(store_o) == 0x01, \"ERC721Metadata: URI query for nonexistent token\");\n        }\n        require(arg0 < totalSupply, \"ERC721Metadata: URI query for nonexistent token\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2f;\n        var_f = 0x4552433732314d657461646174613a2055524920717565727920666f72206e6f;\n        var_g = 0x6e6578697374656e7420746f6b656e0000000000000000000000000000000000;\n    }",
    "llm_full_output": "The provided decompiled code is highly obfuscated and contains redundant checks, making it challenging to interpret directly. However, I'll attempt to analyze, rename, and refine the code to the best of my ability.\n\n---\n\n### Analysis:\nThis function appears to be the `tokenURI` function of an ERC-721 contract, which retrieves the metadata URI for a given token ID. It includes numerous checks to ensure the token ID is valid and exists.\n\n---\n\n### Rename Plan:\n| Original Name | Proposed Name          | Reason for Change                          |\n|---------------|------------------------|-------------------------------------------|\n| `arg0`        | `tokenId`             | Represents the token ID being queried.    |\n| `storage_map_n` | `tokenExists`        | Likely a mapping to check token existence.|\n| `totalSupply` | `totalSupply`         | Represents the total number of tokens.    |\n| `store_w`     | `baseURI`             | Likely the base URI for metadata.         |\n| `store_o`     | `metadataExists`      | Indicates if metadata exists for a token. |\n| `ownere`      | `owner`               | Represents the owner of the token.        |\n\n---\n\n### Refined Code:\n```solidity\npragma solidity ^0.8.0;\n\ncontract ERC721Metadata {\n    mapping(uint256 => bool) private tokenExists; // Tracks if a token exists\n    uint256 public totalSupply; // Total number of tokens\n    string private baseURI; // Base URI for metadata\n    mapping(uint256 => bool) private metadataExists; // Tracks if metadata exists for a token\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // Ensure the token ID is valid and exists\n        require(tokenId < totalSupply, \"ERC721Metadata: URI query for nonexistent token\");\n        require(tokenExists[tokenId], \"ERC721Metadata: URI query for nonexistent token\");\n\n        // Ensure metadata exists for the token\n        require(metadataExists[tokenId], \"ERC721Metadata: URI query for nonexistent token\");\n\n        // Construct the full URI by appending the token ID to the base URI\n        return string(abi.encodePacked(baseURI, uint2str(tokenId)));\n    }\n\n    // Helper function to convert uint256 to string\n    function uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(length);\n        uint256 k = length;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n```\n\n---\n\n### Explanation of Refinements:\n1. **Simplified Logic**: The original code had redundant checks and unnecessary complexity. I simplified it to focus on the core functionality of `tokenURI`.\n2. **Meaningful Names**: Replaced generic variable names with meaningful ones to improve readability and maintainability.\n3. **Helper Function**: Added a helper function `uint2str` to convert the token ID to a string for appending to the base URI.\n4. **Removed Obfuscation**: Removed unnecessary variables and operations that were likely artifacts of the decompilation process.\n\nThis refined code is a clean and functional implementation of the `tokenURI` function for an ERC-721 contract.",
    "llm_refined_code": "pragma solidity ^0.8.0;\n\ncontract ERC721Metadata {\n    mapping(uint256 => bool) private tokenExists; // Tracks if a token exists\n    uint256 public totalSupply; // Total number of tokens\n    string private baseURI; // Base URI for metadata\n    mapping(uint256 => bool) private metadataExists; // Tracks if metadata exists for a token\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        // Ensure the token ID is valid and exists\n        require(tokenId < totalSupply, \"ERC721Metadata: URI query for nonexistent token\");\n        require(tokenExists[tokenId], \"ERC721Metadata: URI query for nonexistent token\");\n\n        // Ensure metadata exists for the token\n        require(metadataExists[tokenId], \"ERC721Metadata: URI query for nonexistent token\");\n\n        // Construct the full URI by appending the token ID to the base URI\n        return string(abi.encodePacked(baseURI, uint2str(tokenId)));\n    }\n\n    // Helper function to convert uint256 to string\n    function uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(length);\n        uint256 k = length;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n```\n\n---\n\n### Explanation of Refinements:\n1. **Simplified Logic**: The original code had redundant checks and unnecessary complexity. I simplified it to focus on the core functionality of `tokenURI`.\n2. **Meaningful Names**: Replaced generic variable names with meaningful ones to improve readability and maintainability.\n3. **Helper Function**: Added a helper function `uint2str` to convert the token ID to a string for appending to the base URI.\n4. **Removed Obfuscation**: Removed unnecessary variables and operations that were likely artifacts of the decompilation process.\n\nThis refined code is a clean and functional implementation of the `tokenURI` function for an ERC-721 contract.",
    "ground_truth": "function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\n    }"
}