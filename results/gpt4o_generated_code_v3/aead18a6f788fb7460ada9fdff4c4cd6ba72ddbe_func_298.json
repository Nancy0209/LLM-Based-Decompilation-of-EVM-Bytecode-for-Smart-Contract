{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function tokensOfOwner(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        if (0x01 == totalSupply) {\n            var_a = 0x20;\n            var_b = var_c;\n            if (!0 < var_c) {\n                return abi.encodePacked(0x20, var_c);\n                if (0x01 < totalSupply) {\n                    if (!0x01 < 0x01) {\n                        if (totalSupply < totalSupply) {\n                            if (address(arg0)) {\n                                address var_d = address(arg0);\n                                var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c45;\n                                if (!(0x01 < totalSupply) * (uint64(storage_map_k[var_d]))) {\n                                    require(0x01 == totalSupply, CustomError_8f4eb604());\n                                    uint256 var_f = var_f + (((totalSupply - 0x01) + 0x01) << 0x05);\n                                    var_f = var_f + 0x80;\n                                    uint256 var_a = 0;\n                                    uint256 var_b = 0;\n                                    uint256 var_g = 0;\n                                    uint256 var_h = 0;\n                                    require(!(0 < var_c), CustomError_8f4eb604());\n                                    require(0x01 < totalSupply, CustomError_8f4eb604());\n                                    var_f = var_f + 0x80;\n                                    uint256 var_i = 0;\n                                    uint256 var_j = 0;\n                                    uint256 var_k = 0;\n                                    uint256 var_l = 0;\n                                    var_d = 0x01;\n                                    var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                                    var_f = var_f + 0x80;\n                                    uint256 var_m = 0;\n                                    uint256 var_n = 0;\n                                    uint256 var_o = 0;\n                                    uint256 var_p = 0;\n                                    var_m = address(storage_map_k[var_d]);\n                                    var_n = uint64(storage_map_k[var_d] >> 0xa0);\n                                    var_o = !(!bytes1(storage_map_k[var_d]));\n                                    var_p = storage_map_k[var_d] >> 0xe8;\n                                    require(!(0x01 < 0x01), CustomError_8f4eb604());\n                                    require(totalSupply < totalSupply, CustomError_8f4eb604());\n                                    require(address(arg0), CustomError_8f4eb604());\n                                }\n                                require(!((0x01 < totalSupply) * (uint64(storage_map_k[var_d]))), CustomError_8f4eb604());\n                                require((totalSupply - 0x01) > ((0x01 < totalSupply) * (uint64(storage_map_k[var_d]))), CustomError_8f4eb604());\n                                require(0x01 < 0x01, CustomError_8f4eb604());\n                                require(var_q, CustomError_8f4eb604());\n                            }\n                            var_b = 0x01;\n                            require(var_r == 0, CustomError_8f4eb604());\n                        }\n                    }\n                }\n                require(!var_f.length, CustomError_8f4eb604());\n                var_d = 0x01;\n                var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                require((var_f.length ^ arg0) << 0x60, CustomError_8f4eb604());\n            }\n            var_f = var_f + (((0x01 < totalSupply) * (uint64(storage_map_k[var_d])) + 0x01) << 0x05);\n            var_f = var_f + 0x80;\n            var_b = 0;\n            var_g = 0;\n            var_h = 0;\n            var_i = 0;\n            require(!(0x01 < totalSupply), CustomError_8f4eb604());\n            require(0x01 < 0x01, CustomError_8f4eb604());\n            var_d = 0x01;\n            var_e = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n            require(!(0x01 < totalSupply), CustomError_8f4eb604());\n        }\n        var_d = 0x8f4eb60400000000000000000000000000000000000000000000000000000000;\n        var_d = 0x32c1995a00000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_full_output": "The provided decompiled Solidity code is highly obfuscated and contains numerous redundant or nonsensical operations. Decompiled code often includes artifacts that do not directly translate to meaningful Solidity constructs. Below, I will attempt to analyze, rename, and refine the code into a more understandable and functional form.\n\n---\n\n### Analysis:\nThe function appears to retrieve a list of token IDs owned by a specific address (`arg0`). However, the decompiled code is convoluted and includes many redundant checks and operations. The goal is to simplify and reconstruct the function to align with its likely purpose.\n\n---\n\n### Rename Plan:\n| Original Name       | Proposed Name          |\n|---------------------|------------------------|\n| `arg0`              | `owner`               |\n| `totalSupply`       | `totalSupply`         |\n| `storage_map_k`     | `ownershipMapping`    |\n| `var_a`, `var_b`, etc. | Removed (irrelevant) |\n| `CustomError_8f4eb604` | `InvalidOperation`   |\n\n---\n\n### Refined Code:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract TokenOwnership {\n    // State variables\n    uint256 public totalSupply; // Total number of tokens\n    mapping(uint256 => address) private ownershipMapping; // Maps token ID to owner\n\n    // Custom error for invalid operations\n    error InvalidOperation();\n\n    /**\n     * @dev Returns the list of token IDs owned by a specific address.\n     * @param owner The address to query for owned tokens.\n     * @return tokenIds An array of token IDs owned by the given address.\n     */\n    function tokensOfOwner(address owner) public view returns (uint256[] memory tokenIds) {\n        require(owner != address(0), \"Invalid address\");\n\n        // Count the number of tokens owned by the address\n        uint256 tokenCount = 0;\n        for (uint256 i = 1; i <= totalSupply; i++) {\n            if (ownershipMapping[i] == owner) {\n                tokenCount++;\n            }\n        }\n\n        // Populate the array with the token IDs\n        tokenIds = new uint256[](tokenCount);\n        uint256 index = 0;\n        for (uint256 i = 1; i <= totalSupply; i++) {\n            if (ownershipMapping[i] == owner) {\n                tokenIds[index] = i;\n                index++;\n            }\n        }\n\n        return tokenIds;\n    }\n}\n```\n\n---\n\n### Explanation of Changes:\n1. **Simplified Logic**: The original decompiled code contained numerous redundant checks and operations. These were removed to focus on the core functionality: retrieving token IDs owned by a specific address.\n2. **Meaningful Names**: Variables and mappings were renamed to reflect their purpose, improving readability and maintainability.\n3. **Error Handling**: A custom error (`InvalidOperation`) was added to replace the generic `CustomError_8f4eb604`.\n4. **Iterative Token Search**: The refined function iterates through the `ownershipMapping` to find tokens owned by the specified address.\n5. **Array Allocation**: The function first counts the tokens owned by the address, then allocates an array of the appropriate size to store the token IDs.\n\nThis refined code is clean, functional, and adheres to Solidity best practices.",
    "llm_refined_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract TokenOwnership {\n    // State variables\n    uint256 public totalSupply; // Total number of tokens\n    mapping(uint256 => address) private ownershipMapping; // Maps token ID to owner\n\n    // Custom error for invalid operations\n    error InvalidOperation();\n\n    /**\n     * @dev Returns the list of token IDs owned by a specific address.\n     * @param owner The address to query for owned tokens.\n     * @return tokenIds An array of token IDs owned by the given address.\n     */\n    function tokensOfOwner(address owner) public view returns (uint256[] memory tokenIds) {\n        require(owner != address(0), \"Invalid address\");\n\n        // Count the number of tokens owned by the address\n        uint256 tokenCount = 0;\n        for (uint256 i = 1; i <= totalSupply; i++) {\n            if (ownershipMapping[i] == owner) {\n                tokenCount++;\n            }\n        }\n\n        // Populate the array with the token IDs\n        tokenIds = new uint256[](tokenCount);\n        uint256 index = 0;\n        for (uint256 i = 1; i <= totalSupply; i++) {\n            if (ownershipMapping[i] == owner) {\n                tokenIds[index] = i;\n                index++;\n            }\n        }\n\n        return tokenIds;\n    }\n}\n```\n\n---\n\n### Explanation of Changes:\n1. **Simplified Logic**: The original decompiled code contained numerous redundant checks and operations. These were removed to focus on the core functionality: retrieving token IDs owned by a specific address.\n2. **Meaningful Names**: Variables and mappings were renamed to reflect their purpose, improving readability and maintainability.\n3. **Error Handling**: A custom error (`InvalidOperation`) was added to replace the generic `CustomError_8f4eb604`.\n4. **Iterative Token Search**: The refined function iterates through the `ownershipMapping` to find tokens owned by the specified address.\n5. **Array Allocation**: The function first counts the tokens owned by the address, then allocates an array of the appropriate size to store the token IDs.\n\nThis refined code is clean, functional, and adheres to Solidity best practices.",
    "ground_truth": "function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/HasRegistration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CLOSED - Pending Licensing Audit\\npragma solidity ^0.8.4;\\nimport \\\"./IsBypassable.sol\\\";\\n\\ncontract HasRegistration is IsBypassable {\\n\\n    mapping(address => uint256) public registeredContracts; // 0 EMPTY, 1 ERC1155, 2 ERC721, 3 HANDLER, 4 ERC20, 5 BALANCE, 6 CLAIM, 7 UNKNOWN, 8 FACTORY, 9 STAKING, 10 BYPASS\\n    mapping(uint256 => address[]) internal registeredOfType;\\n\\n    modifier isRegisteredContract(address _contract) {\\n        require(registeredContracts[_contract] > 0, \\\"Contract is not registered\\\");\\n        _;\\n    }\\n\\n    modifier isRegisteredContractOrOwner(address _contract) {\\n        require(registeredContracts[_contract] > 0 || owner() == _msgSender(), \\\"Contract is not registered nor Owner\\\");\\n        _;\\n    }\\n\\n    function registerContract(address _contract, uint _type) public isRegisteredContractOrOwner(_msgSender()) {\\n        registeredContracts[_contract] = _type;\\n        registeredOfType[_type].push(_contract);\\n    }\\n\\n    function unregisterContract(address _contract, uint256 index) public onlyOwner isRegisteredContract(_contract) {\\n        address[] storage arr = registeredOfType[registeredContracts[_contract]];\\n        arr[index] = arr[arr.length - 1];\\n        arr.pop();\\n        delete registeredContracts[_contract];\\n    }\\n\\n    function isRegistered(address _contract, uint256 _type) public view returns (bool) {\\n        return registeredContracts[_contract] == _type;\\n    }\\n\\n    function getAllRegisteredContractsOfType(uint256 _type) public view returns (address[] memory) {\\n        return registeredOfType[_type];\\n    }\\n}\"\r\n    }"
}