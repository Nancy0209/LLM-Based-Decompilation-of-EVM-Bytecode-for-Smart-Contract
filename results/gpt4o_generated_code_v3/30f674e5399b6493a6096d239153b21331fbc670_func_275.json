{
    "contract_address": "0x30F674e5399B6493A6096d239153b21331fbC670",
    "heimdall_input": "function manualBurnLiquidityPairTokens(uint256 arg0) public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(lastManualLpBurnTime > ~(manualBurnFrequency)), \"Must wait for cooldown to finish\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(block.timestamp > (lastManualLpBurnTime + manualBurnFrequency), \"Must wait for cooldown to finish\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4d757374207761697420666f7220636f6f6c646f776e20746f2066696e697368;\n        require(!(arg0 > 0x03e8), \"May not nuke more than 10% of tokens in LP\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2a;\n        var_d = 0x4d6179206e6f74206e756b65206d6f7265207468616e20313025206f6620746f;\n        var_g = 0x6b656e7320696e204c5000000000000000000000000000000000000000000000;\n        lastManualLpBurnTime = block.timestamp;\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x54a875b040e5413f27fb1ebe7af5180daf5e264a;\n        (bool success, bytes memory ret0) = address(this).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!(((var_h + ret0.length) - var_h) < 0x20), \"ERC20: transfer from the zero address\");\n        require(!(var_h.length & (arg0 > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / var_h.length))), \"ERC20: transfer from the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710, \"ERC20: transfer from the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!((var_h.length * arg0) / 0x2710), \"ERC20: transfer from the zero address\");\n        require(0x54a875b040e5413f27fb1ebe7af5180daf5e264a, \"ERC20: transfer from the zero address\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(0xdead, \"ERC20: transfer to the zero address\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x54a875b040e5413f27fb1ebe7af5180daf5e264a;\n        uint256 var_k = 0;\n        require(!(storage_map_t[var_e] < ((var_h.length * arg0) / 0x2710)), \"ERC20: transfer amount exceeds balance\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_j = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_e = 0x54a875b040e5413f27fb1ebe7af5180daf5e264a;\n        var_k = 0;\n        storage_map_t[var_e] = storage_map_t[var_e] - ((var_h.length * arg0) / 0x2710);\n        var_e = 0xdead;\n        require(!storage_map_t[var_e] > (~((var_h.length * arg0) / 0x2710)));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        storage_map_t[var_e] = storage_map_t[var_e] + ((var_h.length * arg0) / 0x2710);\n        uint256 var_i = (var_h.length * arg0) / 0x2710;\n        emit Transfer(0x54a875b040e5413f27fb1ebe7af5180daf5e264a, 0xdead, (var_h.length * arg0) / 0x2710);\n        var_i = 0xfff6cae900000000000000000000000000000000000000000000000000000000;\n        require(address(0x54a875b040e5413f27fb1ebe7af5180daf5e264a).code.length);\n        (bool success, bytes memory ret0) = address(0x54a875b040e5413f27fb1ebe7af5180daf5e264a).{ value: var_k ether }sync(var_c); // call\n        emit ManualNukeLP();\n        var_i = 0x01;\n        return 0x01;\n    }",
    "llm_full_output": "### Analysis:\nThe function appears to be designed to allow the contract owner to manually burn liquidity pool (LP) tokens, with restrictions on the frequency and amount of tokens that can be burned. It also ensures proper accounting and emits relevant events.\n\n### Rename Plan:\n- `arg0` -> `amountToBurn`\n- `var_a`, `var_b`, `var_c`, `var_d`, etc. -> Removed (irrelevant variables from decompilation artifacts)\n- `lastManualLpBurnTime` -> `lastBurnTimestamp`\n- `manualBurnFrequency` -> `burnCooldown`\n- `storage_map_t` -> `balances`\n- `0x54a875b040e5413f27fb1ebe7af5180daf5e264a` -> `lpTokenAddress`\n- `0xdead` -> `burnAddress`\n- `emit ManualNukeLP()` -> `emit ManualBurnLP()`\n\n### Refined Code:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LiquidityBurner {\n    address public owner;\n    address public lpTokenAddress = 0x54a875b040e5413f27fb1ebe7af5180daf5e264a; // Replace with actual LP token address\n    address public constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n    uint256 public lastBurnTimestamp;\n    uint256 public burnCooldown = 1 days; // Example cooldown period\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event ManualBurnLP();\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function manualBurnLiquidityPairTokens(uint256 amountToBurn) public onlyOwner returns (bool) {\n        require(block.timestamp > lastBurnTimestamp + burnCooldown, \"Must wait for cooldown to finish\");\n        require(amountToBurn <= 1000, \"May not burn more than 10% of tokens in LP\");\n\n        // Get the balance of LP tokens held by the contract\n        uint256 lpBalance = IERC20(lpTokenAddress).balanceOf(address(this));\n        require(lpBalance >= amountToBurn, \"Insufficient LP token balance\");\n\n        // Update the last burn timestamp\n        lastBurnTimestamp = block.timestamp;\n\n        // Transfer LP tokens to the burn address\n        require(IERC20(lpTokenAddress).transfer(burnAddress, amountToBurn), \"LP token transfer failed\");\n\n        // Emit events\n        emit Transfer(address(this), burnAddress, amountToBurn);\n        emit ManualBurnLP();\n\n        return true;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\n### Explanation of Refinements:\n1. **Removed Decompilation Artifacts:** Variables like `var_a`, `var_b`, etc., were artifacts of the decompilation process and were removed for clarity.\n2. **Meaningful Names:** Replaced generic names with meaningful ones to improve readability and maintainability.\n3. **Simplified Logic:** Simplified the logic to focus on the core functionality of burning LP tokens.\n4. **Added Events:** Properly emitted events for transparency.\n5. **Used IERC20 Interface:** Added an interface for interacting with the LP token contract.\n6. **Cooldown and Limits:** Ensured cooldown and burn limits are enforced as per the original logic.\n\nThis refined code is clean, readable, and adheres to Solidity best practices.",
    "llm_refined_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LiquidityBurner {\n    address public owner;\n    address public lpTokenAddress = 0x54a875b040e5413f27fb1ebe7af5180daf5e264a; // Replace with actual LP token address\n    address public constant burnAddress = 0x000000000000000000000000000000000000dEaD;\n    uint256 public lastBurnTimestamp;\n    uint256 public burnCooldown = 1 days; // Example cooldown period\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event ManualBurnLP();\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function manualBurnLiquidityPairTokens(uint256 amountToBurn) public onlyOwner returns (bool) {\n        require(block.timestamp > lastBurnTimestamp + burnCooldown, \"Must wait for cooldown to finish\");\n        require(amountToBurn <= 1000, \"May not burn more than 10% of tokens in LP\");\n\n        // Get the balance of LP tokens held by the contract\n        uint256 lpBalance = IERC20(lpTokenAddress).balanceOf(address(this));\n        require(lpBalance >= amountToBurn, \"Insufficient LP token balance\");\n\n        // Update the last burn timestamp\n        lastBurnTimestamp = block.timestamp;\n\n        // Transfer LP tokens to the burn address\n        require(IERC20(lpTokenAddress).transfer(burnAddress, amountToBurn), \"LP token transfer failed\");\n\n        // Emit events\n        emit Transfer(address(this), burnAddress, amountToBurn);\n        emit ManualBurnLP();\n\n        return true;\n    }\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\n### Explanation of Refinements:\n1. **Removed Decompilation Artifacts:** Variables like `var_a`, `var_b`, etc., were artifacts of the decompilation process and were removed for clarity.\n2. **Meaningful Names:** Replaced generic names with meaningful ones to improve readability and maintainability.\n3. **Simplified Logic:** Simplified the logic to focus on the core functionality of burning LP tokens.\n4. **Added Events:** Properly emitted events for transparency.\n5. **Used IERC20 Interface:** Added an interface for interacting with the LP token contract.\n6. **Cooldown and Limits:** Ensured cooldown and burn limits are enforced as per the original logic.\n\nThis refined code is clean, readable, and adheres to Solidity best practices.",
    "ground_truth": "function manualBurnLiquidityPairTokens(uint256 percent)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            block.timestamp > lastManualLpBurnTime + manualBurnFrequency,\r\n            \"Must wait for cooldown to finish\"\r\n        );\r\n        require(percent <= 1000, \"May not nuke more than 10% of tokens in LP\");\r\n        lastManualLpBurnTime = block.timestamp;\r\n\r\n        // get balance of liquidity pair\r\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\r\n\r\n        // calculate amount to burn\r\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\r\n\r\n        // pull tokens from pancakePair liquidity and move to dead address permanently\r\n        if (amountToBurn > 0) {\r\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\r\n        }\r\n\r\n        //sync price since this is not in a swap transaction!\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n        pair.sync();\r\n        emit ManualNukeLP();\r\n        return true;\r\n    }"
}