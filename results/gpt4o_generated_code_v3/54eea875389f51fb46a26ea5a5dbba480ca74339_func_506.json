{
    "contract_address": "0x54eEA875389f51FB46A26Ea5a5DbBa480ca74339",
    "heimdall_input": "function withdrawStuckTokens(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(this);\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"No tokens\");\n        require(var_e.length > 0, \"No tokens\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x09;\n        var_g = 0x4e6f20746f6b656e730000000000000000000000000000000000000000000000;\n        var_f = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_c = address(this);\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_70a08231(var_c); // staticcall\n    }",
    "llm_full_output": "### Analysis:\nThe function appears to be designed to allow the contract owner to withdraw any ERC20 tokens that are accidentally sent to the contract, ensuring that only the owner can perform this action.\n\n### Rename Plan:\n- `arg0` -> `tokenAddress`\n- `var_a`, `var_f` -> `errorSignature`\n- `var_b`, `var_c` -> `contractAddress`\n- `var_d`, `var_g` -> `errorMessage`\n- `var_e` -> `balance`\n- `var_e.length` -> `balanceLength`\n\n### Refined Code:\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenRecovery {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdrawStuckTokens(address tokenAddress) public {\n        require(tokenAddress != address(0), \"Invalid token address\");\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n\n        bytes4 balanceOfSelector = bytes4(keccak256(\"balanceOf(address)\"));\n        address contractAddress = address(this);\n\n        (bool success, bytes memory balanceData) = tokenAddress.staticcall(abi.encodeWithSelector(balanceOfSelector, contractAddress));\n        require(success, \"Failed to get token balance\");\n\n        uint256 balance = abi.decode(balanceData, (uint256));\n        require(balance > 0, \"No tokens to withdraw\");\n\n        bytes4 transferSelector = bytes4(keccak256(\"transfer(address,uint256)\"));\n        (success, ) = tokenAddress.call(abi.encodeWithSelector(transferSelector, owner, balance));\n        require(success, \"Token transfer failed\");\n    }\n}\n```\n\n### Explanation:\n- The function checks if the caller is the contract owner.\n- It retrieves the balance of the specified token held by the contract.\n- If there are tokens, it transfers them to the owner.\n- The function uses the `balanceOf` and `transfer` functions of the ERC20 standard.",
    "llm_refined_code": "pragma solidity ^0.8.0;\n\ncontract TokenRecovery {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdrawStuckTokens(address tokenAddress) public {\n        require(tokenAddress != address(0), \"Invalid token address\");\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n\n        bytes4 balanceOfSelector = bytes4(keccak256(\"balanceOf(address)\"));\n        address contractAddress = address(this);\n\n        (bool success, bytes memory balanceData) = tokenAddress.staticcall(abi.encodeWithSelector(balanceOfSelector, contractAddress));\n        require(success, \"Failed to get token balance\");\n\n        uint256 balance = abi.decode(balanceData, (uint256));\n        require(balance > 0, \"No tokens to withdraw\");\n\n        bytes4 transferSelector = bytes4(keccak256(\"transfer(address,uint256)\"));\n        (success, ) = tokenAddress.call(abi.encodeWithSelector(transferSelector, owner, balance));\n        require(success, \"Token transfer failed\");\n    }\n}\n```\n\n### Explanation:\n- The function checks if the caller is the contract owner.\n- It retrieves the balance of the specified token held by the contract.\n- If there are tokens, it transfers them to the owner.\n- The function uses the `balanceOf` and `transfer` functions of the ERC20 standard.",
    "ground_truth": "function withdrawStuckTokens(address tkn) public onlyOwner {\r\n        require(IERC20(tkn).balanceOf(address(this)) > 0, \"No tokens\");\r\n        uint256 amount = IERC20(tkn).balanceOf(address(this));\r\n        IERC20(tkn).transfer(msg.sender, amount);\r\n    }"
}