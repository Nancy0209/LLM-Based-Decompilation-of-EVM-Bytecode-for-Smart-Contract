{
    "contract_address": "0x5Bfdf57678baFB4eBB2c09279ac382397F3006b6",
    "heimdall_input": "function manualsend() public {\n        require(address(msg.sender) == (address(store_p)));\n        require(address(msg.sender) == (address(store_q)));\n        (bool success, bytes memory ret0) = address(store_q).transfer(address(this).balance);\n    }",
    "llm_output": "function manualsend() public {\n    // Only allow the two authorised wallets to trigger this function.\n    // NOTE: The original decompiled logic required the caller to be **both** wallets,\n    // which is effectively impossible unless the two wallet addresses are identical.\n    // We preserve that exact behaviour here with two sequential `require` statements.\n    require(msg.sender == authorizedWallet1, \"Caller is not authorized wallet 1\");\n    require(msg.sender == authorizedWallet2, \"Caller is not authorized wallet 2\");\n\n    // Forward the entire ETH balance held by the contract to the second authorised wallet.\n    payable(authorizedWallet2).transfer(address(this).balance);\n}",
    "ground_truth": "function manualsend() external {\r\nrequire(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\r\nuint256 contractETHBalance = address(this).balance;\r\nsendETHToFee(contractETHBalance);\r\n}"
}