{
    "contract_address": "0x9E094200906d93a320D92C0eFb4a57436796DAb0",
    "heimdall_input": "function supportsInterface(bytes4 arg0) public pure returns (bool) {\n        require(arg0 == (uint32(arg0)));\n        require(uint32(arg0) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        require(uint32(arg0) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        uint32 var_a = !(!(uint32(arg0)) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        var_a = !(!(uint32(arg0)) == 0x0e89341c00000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x0e89341c00000000000000000000000000000000000000000000000000000000);\n    }",
    "llm_output": "function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n    // The original byte-code included these redundant but obligatory checks.\n    require(interfaceId == bytes4(uint32(interfaceId)), \"Invalid bytes4 value\");\n    require(uint32(interfaceId) == 0x01ffc9a7, \"Unsupported interface\");\n    require(uint32(interfaceId) == 0x01ffc9a7, \"Unsupported interface (duplicate check)\");\n\n    // First branch \u2013 satisfied after the double require above.\n    if (uint32(interfaceId) == 0x01ffc9a7) {\n        return true;\n    }\n\n    // Second branch \u2013 present in the decompiled logic even though it is\n    // effectively unreachable because of the earlier requires.\n    if (uint32(interfaceId) == 0x0e89341c) {\n        return true;\n    }\n\n    return false;\n}",
    "ground_truth": "function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            || interfaceId == 0xd9b67a26 // ERC165 Interface ID for ERC1155\\n            || interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }"
}