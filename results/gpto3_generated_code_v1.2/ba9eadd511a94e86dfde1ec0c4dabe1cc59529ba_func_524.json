{
    "contract_address": "0xBA9eADD511A94e86DfDE1EC0c4DaBe1CC59529BA",
    "heimdall_input": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                uint256 var_a = 0;\n                                uint256 var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory tokenName) {\n    assembly {\n        /* -----------------------------\n           The string follows Solidity\u2019s\n           standard storage layout:\n\n           Short string  (\u226431 bytes):\n               keccak('') storage slot (0) holds:\n               [string data << 8] | [length << 1] | 1\n\n           Long string (>31 bytes):\n               slot 0 holds:  [offset << 1] | 0\n               `offset` is the string length.\n               Actual data is stored starting at\n               keccak256(0) \u2026 keccak256(0)+n\n        ----------------------------- */\n\n        // Load slot-0 where the string header lives\n        let header := sload(0x0)\n\n        // --- SHORT STRING PATH -------------------------------------------\n        if and(header, 1) {\n            // Extract length (low 8 bits after shifting out the flag bit)\n            let len := shr(1, and(header, 0xFF))\n\n            // Allocate memory\n            tokenName := mload(0x40)\n            mstore(tokenName, len)                 // store length\n\n            // Copy the data (it starts at bit-8 of `header`)\n            mstore(\n                add(tokenName, 0x20),\n                shr(8, header)\n            )\n\n            // Update free-memory pointer\n            mstore(0x40, add(tokenName, 0x40))\n        }\n\n        // --- LONG STRING PATH --------------------------------------------\n        if iszero(and(header, 1)) {\n            let len := shr(1, header)\n\n            // Panic code 0x22 (identical to Solidity\u2019s runtime check)\n            if lt(len, 0x20) {\n                mstore(0x00, 0x4e487b71)           // Panic(uint256)\n                mstore(0x04, 0x22)                 // code 0x22\n                revert(0x00, 0x24)\n            }\n\n            // Calculate word count and total byte size\n            let words := div(add(len, 0x1f), 0x20)\n            let size  := mul(words, 0x20)\n\n            // Allocate memory\n            let ptr := mload(0x40)\n            mstore(ptr, len)\n\n            // Storage slot where the data starts\n            let dataSlot := keccak256(0x0, 0x20)\n\n            // Copy word-by-word from storage to memory\n            for { let i := 0 } lt(i, words) { i := add(i, 1) } {\n                mstore(\n                    add(add(ptr, 0x20), mul(i, 0x20)),\n                    sload(add(dataSlot, i))\n                )\n            }\n\n            // Update free-memory pointer\n            mstore(0x40, add(ptr, add(0x20, size)))\n\n            tokenName := ptr\n        }\n    }\n}",
    "ground_truth": "function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"\r\n    }"
}