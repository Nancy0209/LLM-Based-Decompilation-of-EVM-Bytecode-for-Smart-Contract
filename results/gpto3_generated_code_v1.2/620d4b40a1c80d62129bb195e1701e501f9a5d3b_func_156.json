{
    "contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b",
    "heimdall_input": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(0x01 > arg1, CustomError_df2d9b42());\n        require(!(arg1 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x04;\n        require(bytes1(storage_map_n[var_a]), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(storage_map_n[var_a], CustomError_cfb3b942());\n        require(address(storage_map_n[var_a]) == msg.sender, CustomError_cfb3b942());\n        var_a = address(storage_map_n[var_a]);\n        var_b = 0x07;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_n[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_c = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1;\n        var_b = 0x04;\n        if (storage_map_n[var_a]) {\n            var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1);\n            var_b = 0x04;\n            if (storage_map_n[var_a]) {\n                var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1));\n                var_b = 0x04;\n                if (storage_map_n[var_a]) {\n                }\n            }\n        }\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function approve(address to, uint256 tokenId) public payable {\n    /* --------------------------------------------------------------------- */\n    /*  Artifact-level no-op check (kept to preserve decompiled semantics)    */\n    /* --------------------------------------------------------------------- */\n    require(to == address(to), \"DecompilerArtifact\");\n\n    /* --------------------------------------------------------------------- */\n    /*  Revert if the token does not exist                                   */\n    /* --------------------------------------------------------------------- */\n    require(tokenId < totalSupply(), \"ApprovalQueryForNonexistentToken\");\n\n    /* --------------------------------------------------------------------- */\n    /*  Fetch current owner and verify caller privileges                     */\n    /* --------------------------------------------------------------------- */\n    address tokenOwner = ownerOf(tokenId);\n\n    if (msg.sender != tokenOwner && !isApprovedForAll(tokenOwner, msg.sender)) {\n        revert ApprovalCallerNotOwnerNorApproved();\n    }\n\n    /* --------------------------------------------------------------------- */\n    /*  Record approval                                                      */\n    /* --------------------------------------------------------------------- */\n    _tokenApprovals[tokenId] = to;\n    emit Approval(tokenOwner, to, tokenId);\n\n    /* --------------------------------------------------------------------- */\n    /*  Duplicate storage write and event emission (exists in original byte- */\n    /*  code; retained for full behavioural fidelity)                        */\n    /* --------------------------------------------------------------------- */\n    _tokenApprovals[tokenId] = to;\n    emit Approval(tokenOwner, to, tokenId);\n\n    /* --------------------------------------------------------------------- */\n    /*  Redundant ownership look-ups retained from the original bytecode.    */\n    /*  They have no side-effects other than extra SLOADs.                   */\n    /* --------------------------------------------------------------------- */\n    unchecked {\n        uint256 prevId = tokenId - 1;\n        if (_packedOwnerships[prevId] != 0) {\n            prevId -= 1;\n            if (_packedOwnerships[prevId] != 0) {\n                prevId -= 1;\n                if (_packedOwnerships[prevId] != 0) {\n                    /* no-op */\n                }\n            }\n        }\n    }\n}",
    "ground_truth": "function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}"
}