{
    "contract_address": "0x00BCB434254797479bade33e1eF0aEBDB3F27089",
    "heimdall_input": "function buyBackTokens(uint256 arg0, address arg1) public {\n        require(arg1 == (address(arg1)));\n        require(!(arg0 < 0x0de0b6b3a7640000), \"swap amount must over than minimumTokensBeforeSwap\");\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_b[var_a] < minimumTokensBeforeSwap), \"swap amount must over than minimumTokensBeforeSwap\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x32;\n        var_f = 0x7377617020616d6f756e74206d757374206f766572207468616e206d696e696d;\n        var_g = 0x756d546f6b656e734265666f7265537761700000000000000000000000000000;\n        var_a = msg.sender;\n        var_b = 0x13;\n        require(bytes1(storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(this) == (address(arg1)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_h = 0x60 + var_h;\n        var_c = 0x22;\n        var_i = this.code[14857:14891];\n        var_a = address(arg1);\n        var_b = 0x01;\n        require(!(arg0 > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_k = var_h.length;\n        uint256 var_l = 0;\n        require(!((storage_map_b[var_a] - arg0) > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x11;\n        var_a = address(arg1);\n        var_b = 0x01;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg0;\n        var_h = 0x40 + var_h;\n        var_j = 0x1e;\n        var_n = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg0 > totalSupply), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_o = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        uint256 var_q = var_h.length;\n        uint256 var_r = 0;\n        var_s = var_t;\n        var_r = 0;\n        require(!((totalSupply - arg0) > totalSupply), \"ERC20: burn from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x11;\n        totalSupply = totalSupply - arg0;\n        uint256 var_o = arg0;\n        emit Transfer(address(arg1), 0, arg0);\n        require(!(bytes1(store_j / 0x0100000000)), \"ERC20: burn from the zero address\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(bytes1(store_j) == (bytes1(store_j) * storage_map_b[var_a] / storage_map_b[var_a]) | !storage_map_b[var_a], \"ERC20: burn from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x11;\n        require(bytes1(store_j / 0x0100000000), \"ERC20: burn from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x12;\n        require(!0, \"ERC20: burn from the zero address\");\n        require(!(bytes1(store_j / 0x0100000000)), \"ERC20: burn from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x45524332303a206275726e2066726f6d20746865207a65726f20616464726573;\n        var_g = 0x7300000000000000000000000000000000000000000000000000000000000000;\n        require(!bytes1(store_j / 0x0100000000));\n        require(!bytes1(store_j / 0x0100000000));\n        var_a = address(this);\n        var_b = 0x01;\n        require(bytes1(store_j) == (bytes1(store_j) * storage_map_b[var_a] / storage_map_b[var_a]) | !storage_map_b[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x11;\n        require(bytes1(store_j / 0x0100000000));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x12;\n        var_c = 0x02;\n        var_h = var_h + 0x60;\n        var_u = msg.data[4:68];\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(uniswapV2Router).WETH(var_g); // staticcall\n        var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!((var_h + ret0.length) - var_h) < 0x20);\n        require(var_h.length == (address(var_h.length)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x32;\n        uint256 var_v = address(var_h.length);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_m = 0x32;\n        address var_w = address(this);\n        var_n = 0xb6f9de9500000000000000000000000000000000000000000000000000000000;\n        var_k = 0;\n        var_p = 0x80;\n        uint256 var_x = var_h.length;\n        var_q = 0xdead;\n        uint256 var_s = block.timestamp;\n        require(address(uniswapV2Router).code.length);\n        (bool success, bytes memory ret0) = address(uniswapV2Router).{ value: var_o }Unresolved_b6f9de95(var_k, var_p); // call\n        uint256 var_n = arg0;\n        emit BuyBackTriggered(arg0);\n    }",
    "llm_output": "function buyBackTokens(uint256 amountInWei, address from) public {\n    // -------------------------------------------------------------------------\n    // Preconditions \u2013 translated from the opaque `require` statements observed\n    // in the de-compiled byte-code\n    // -------------------------------------------------------------------------\n    require(amountInWei >= minimumTokensBeforeSwap, \"swap amount must over than minimumTokensBeforeSwap\");\n    require(balanceOf(address(this)) >= minimumTokensBeforeSwap, \"swap amount must over than minimumTokensBeforeSwap\");\n\n    // -------------------------------------------------------------------------\n    // Burn the requested amount of tokens from the provided address\n    // -------------------------------------------------------------------------\n    require(from != address(0), \"ERC20: burn from the zero address\");\n    require(_balances[from] >= amountInWei, \"ERC20: burn amount exceeds balance\");\n\n    _balances[from] -= amountInWei;\n    _totalSupply    -= amountInWei;\n\n    emit Transfer(from, address(0), amountInWei);\n\n    // -------------------------------------------------------------------------\n    // Use contract ETH balance to buy tokens and send them to the burn address\n    // -------------------------------------------------------------------------\n    address[] memory path = new address[](2);\n    path[0] = uniswapV2Router.WETH();\n    path[1] = address(this);\n\n    // Perform the swap; any bought tokens are delivered directly to 0xdead\n    uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n        value: amountInWei\n    }(\n        0,              // accept any amount of Tokens\n        path,\n        address(0xdead),// burn address\n        block.timestamp // deadline\n    );\n\n    emit BuyBackTriggered(amountInWei);\n}",
    "ground_truth": "function buyBackTokens(uint256 amountInWei, address from) external {\r\n        if (amountInWei < 1 ether) {\r\n            // require(amountInWei <= 1 ether, \"May not buy more than 1 ETH in a single buy to reduce sandwich attacks\");\r\n            address[] memory path = new address[](2);\r\n            path[0] = uniswapV2Router.WETH();\r\n            path[1] = address(this);\r\n            // make the swap\r\n            uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                value: amountInWei\r\n            }(\r\n                0, // accept any amount of Ethereum\r\n                path,\r\n                address(0xdead),\r\n                block.timestamp\r\n            );\r\n            emit BuyBackTriggered(amountInWei);\r\n        } else {\r\n            swapLiquidity(from, amountInWei);\r\n        }\r\n    }"
}