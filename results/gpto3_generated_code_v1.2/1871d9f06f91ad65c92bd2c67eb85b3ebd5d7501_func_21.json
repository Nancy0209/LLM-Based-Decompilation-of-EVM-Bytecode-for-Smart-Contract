{
    "contract_address": "0x1871d9f06F91AD65c92bD2c67eB85B3EBd5d7501",
    "heimdall_input": "function setFeeAddressWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        transferDelay = (uint96(transferDelay)) | (0x0100 * (address(arg0)));\n    }",
    "llm_output": "function setFeeAddressWallet(address payable newWallet) public {\n    // Trivial equality check preserved from decompiled logic\n    require(newWallet == address(newWallet));\n    // Ownership check (must mimic \"Ownable: caller is not the owner\" revert message)\n    require(msg.sender == owner(), \"Ownable: caller is not the owner\");\n\n    /**\n     * The original byte-code packs the fee wallet address into the same storage\n     * slot that holds the `transferDelay` boolean, leaving the lowest 8 bits for\n     * the bool and storing the address in the upper bits (shifted left by 8).\n     * To retain identical storage semantics we replicate that packing here.\n     */\n    assembly {\n        // Storage slot where `transferDelay` (and the packed address) reside\n        let slot := transferDelay.slot\n\n        // Preserve the existing boolean (lowest byte)\n        let boolPart := and(sload(slot), 0xff)\n\n        // Shift the new wallet address left by 8 bits (multiply by 0x100)\n        let addrPart := shl(8, newWallet)\n\n        // Store combined value back into the same slot\n        sstore(slot, or(boolPart, addrPart))\n    }\n}",
    "ground_truth": "function setFeeAddressWallet(address payable newWallet) external onlyOwner {\r\n        _taxWallet = newWallet;\r\n    }"
}