{
    "contract_address": "0xF47024a2e10D77927767cBE5aADf5F8BB02782c9",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"Value exceeds balance\");\n        require(address(arg0) - 0, \"Value exceeds balance\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"Value exceeds balance\");\n        address var_a = address(msg.sender);\n        var_b = 0x97;\n        require(!(!bytes1(storage_map_d[var_a] / 0x01)), \"Value exceeds balance\");\n        require(!(!bytes1(storage_map_d[var_a] / 0x01)), \"Value exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x65;\n        require(!(storage_map_d[var_a] < arg1), \"Value exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x15;\n        var_g = 0x56616c756520657863656564732062616c616e63650000000000000000000000;\n        if (address(msg.sender) == (address(owner / 0x01))) {\n            var_a = address(msg.sender);\n            var_b = 0x97;\n            if (storage_map_d[var_a] / 0x01) {\n                if (storage_map_d[var_a] / 0x01) {\n                    var_a = address(msg.sender);\n                    var_b = 0x65;\n                    require(bytes1(storage_map_d[var_a] / 0x01));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    var_a = address(msg.sender);\n                    var_b = 0x65;\n                    storage_map_d[var_a] = storage_map_d[var_a] - arg1;\n                    var_a = address(arg0);\n                    var_b = 0x65;\n                    require(bytes1(storage_map_d[var_a] / 0x01));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    var_a = address(arg0);\n                    var_b = 0x65;\n                    storage_map_d[var_a] = storage_map_d[var_a] + arg1;\n                    uint256 var_c = arg1;\n                    emit Transfer(address(msg.sender), address(arg0), arg1);\n                    var_c = 0x01;\n                    return 0x01;\n                    require(!(storage_map_d[var_a] - arg1) > storage_map_d[var_a]);\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    require(!storage_map_d[var_a] > (storage_map_d[var_a] + arg1));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x12;\n                    require(!(arg1) & (fee > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / arg1)));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    require(0x64);\n                }\n                require(!(arg1 - ((arg1 * fee) / 0x64)) > arg1);\n            }\n        }\n        var_a = address(msg.sender);\n        var_b = 0x98;\n        require(!bytes1(storage_map_d[var_a] / 0x01));\n        require(!numbers > 0);\n        require(!arg1 > numbers);\n        require(!(bytes1(reward / 0x01)), \"Error\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x05;\n        var_g = 0x4572726f72000000000000000000000000000000000000000000000000000000;\n        require(!limits > 0);\n        var_a = address(msg.sender);\n        var_b = 0x65;\n        require(!storage_map_d[var_a] > limits);\n        if (!autoCoal / 0x01) {\n        }\n        if (address(msg.sender) == (address(owner / 0x01))) {\n            if (address(msg.sender) == (address(owner / 0x01))) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transfer(address recipient, uint256 amount) public returns (bool) {\n    /*\n        NOTE:\n        -----\n        The original byte-code contained many redundant or always-true/false checks.\n        They are kept (in simplified form) to preserve _exact_ logical behaviour,\n        even though they appear to do nothing useful.\n    */\n\n    // No-op self\u2013equality checks (present in byte-code)\n    require(recipient == recipient, \"Decompiler artifact\");\n    require(amount    == amount,    \"Decompiler artifact\");\n\n    // Zero-address checks\n    require(msg.sender != address(0), \"Value exceeds balance\");\n    require(recipient  != address(0), \"Value exceeds balance\");\n\n    // The decompiler produced an obscure construct that effectively reverts\n    // when `msg.sender == owner`.  We preserve that behaviour verbatim.\n    require(msg.sender != owner(),   \"Value exceeds balance\");\n\n    // Slot 0x97 \u2013 addresses that are not allowed to transfer ( \u201ccandy\u201d list? )\n    require(!_isCandy[msg.sender],   \"Value exceeds balance\");\n\n    // Sufficient balance\n    require(_balances[msg.sender] >= amount, \"Value exceeds balance\");\n\n    /*************************************************************************\n     *  OWNER PATH\n     *************************************************************************/\n    if (msg.sender == owner()) {\n        // Deduct sender balance\n        _balances[msg.sender] -= amount;\n        // Credit recipient balance\n        _balances[recipient]  += amount;\n\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /*************************************************************************\n     *  NON-OWNER PATH\n     *************************************************************************/\n\n    // Slot 0x98 \u2013 another blacklist (\u201ccoal\u201d list?)\n    require(!_isCoal[msg.sender], \"Value exceeds balance\");\n\n    // `numbers` is a global amount-cap that must be zero OR the transfer\n    // amount must be \u2264 the cap.\n    require(numbers == 0 || amount <= numbers, \"Value exceeds balance\");\n\n    // A global flag that, when true, disallows transfers.\n    require(!reward, \"Error\");\n\n    // `limits` is a per-wallet balance cap that must be zero OR\n    // the sender\u2019s balance must be \u2264 the cap.\n    require(limits == 0 || _balances[msg.sender] <= limits, \"Value exceeds balance\");\n\n    // The byte-code contained an empty branch that was executed only when\n    // `autoCoal == true`; we preserve the stub for logical fidelity.\n    if (autoCoal) {\n        // (intentionally left blank)\n    }\n\n    // Perform the actual token movement\n    _balances[msg.sender] -= amount;\n    _balances[recipient]  += amount;\n\n    emit Transfer(msg.sender, recipient, amount);\n    return true;\n}",
    "ground_truth": "function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}"
}