{
    "contract_address": "0xbC9683EE9525c4525e7e0dCFfe8eeD1447fd4287",
    "heimdall_input": "function sendTokens(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_f = address(msg.sender);\n        uint256 var_g = 0;\n        require(storage_map_h[var_f] == 0x7c13bc4b2c133c56000000);\n        require(!(address(msg.sender)) == 0);\n        require(!(address(arg0)) == 0);\n        var_a = 0xf5f9a37100000000000000000000000000000000000000000000000000000000;\n        var_b = address(msg.sender);\n        require(address(store_c / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_c / 0x01).Unresolved_f5f9a371(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"ERC20: transfer ammoudnt exceeds balance\");\n        require(var_h == (var_h), \"ERC20: transfer ammoudnt exceeds balance\");\n        require(!(var_h), \"ERC20: transfer ammoudnt exceeds balance\");\n        var_f = address(msg.sender);\n        var_g = 0;\n        require(!(storage_map_h[var_f] < storage_map_h[var_f]), \"ERC20: transfer ammoudnt exceeds balance\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_e = 0x28;\n        var_j = 0x45524332303a207472616e7366657220616d6d6f75646e742065786365656473;\n        var_k = 0x2062616c616e6365000000000000000000000000000000000000000000000000;\n        var_f = address(msg.sender);\n        var_g = 0;\n        storage_map_h[var_f] = storage_map_h[var_f] - storage_map_h[var_f];\n        var_f = address(arg0);\n        var_g = 0;\n        storage_map_h[var_f] = storage_map_h[var_f] + storage_map_h[var_f];\n        address var_i = storage_map_h[var_f];\n        emit Transfer(address(msg.sender), address(arg0), storage_map_h[var_f]);\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_e = 0x13;\n        var_j = 0x55736572206973206e6f7420616c6c6f77656400000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x23;\n        var_e = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x25;\n        var_e = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x1a;\n        var_e = 0x546f6b656e7320616c7265616479206469737472696275746564000000000000;\n    }",
    "llm_output": "function sendTokens(address recipient) external payable {\n    /* ---------------------------------------------------------------------- */\n    /* 1. Trivial self-equality check (present in original byte-code)         */\n    /* ---------------------------------------------------------------------- */\n    require(recipient == address(recipient));\n\n    /* ---------------------------------------------------------------------- */\n    /* 2. Ownership check                                                     */\n    /* ---------------------------------------------------------------------- */\n    require(owner == msg.sender, \"Ownable: caller is not the owner\");\n\n    /* ---------------------------------------------------------------------- */\n    /* 3. Dummy assignments that existed only to build revert data            */\n    /* ---------------------------------------------------------------------- */\n    bytes4  _errorSelector = 0x08c379a0;\n    bytes32 _unusedReason  = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n\n    /* ---------------------------------------------------------------------- */\n    /* 4. Balance and zero-address validations                                */\n    /* ---------------------------------------------------------------------- */\n    require(_balances[msg.sender] == 0x7c13bc4b2c133c56000000);\n    require(msg.sender != address(0));\n    require(recipient  != address(0));\n\n    /* ---------------------------------------------------------------------- */\n    /* 5. External static-call with selector 0xf5f9a371                       */\n    /* ---------------------------------------------------------------------- */\n    bytes4  _selector = 0xf5f9a371;           // function selector\n    address _target   = externalStore;        // formerly \u201cstore_c / 0x01\u201d\n    require(_target.code.length > 0);\n\n    (bool _success, bytes memory _ret) = _target.staticcall(\n        abi.encodeWithSelector(_selector, msg.sender)\n    );\n    require(_success);\n\n    /* ---------------------------------------------------------------------- */\n    /* 6. Obfuscated arithmetic & redundant checks (kept verbatim)            */\n    /* ---------------------------------------------------------------------- */\n    uint256 _scratch = 0;\n    _scratch += _ret.length + 0x1f;\n\n    require(!(((_scratch + _ret.length) - _scratch) < 0x20), \"ERC20: transfer ammoudnt exceeds balance\");\n\n    bool _flag = false;\n    require(_flag == _flag, \"ERC20: transfer ammoudnt exceeds balance\");\n    require(!_flag,          \"ERC20: transfer ammoudnt exceeds balance\");\n\n    require(!(_balances[msg.sender] < _balances[msg.sender]), \"ERC20: transfer ammoudnt exceeds balance\");\n\n    /* ---------------------------------------------------------------------- */\n    /* 7. Additional revert-data constants preserved for parity               */\n    /* ---------------------------------------------------------------------- */\n    bytes32 _err1 = 0x45524332303a207472616e7366657220616d6d6f75646e7420657863656564732062616c616e6365000000000000000000000000000000000000000000000000;\n    bytes32 _err2 = 0x55736572206973206e6f7420616c6c6f77656400000000000000000000000000;\n    bytes32 _err3 = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472657373000000000000000000000000000000000000000000;\n    bytes32 _err4 = 0x45524332303a207472616e736665722066726f6d20746865207a65726f2061646472657373000000000000000000000000000000000000000000;\n    bytes32 _err5 = 0x546f6b656e7320616c7265616479206469737472696275746564000000000000;\n\n    /* ---------------------------------------------------------------------- */\n    /* 8. Balance bookkeeping (matches original byte-code)                    */\n    /* ---------------------------------------------------------------------- */\n    uint256 senderBalance    = _balances[msg.sender];\n    _balances[msg.sender]    = senderBalance - senderBalance;          // sets sender balance to zero\n\n    uint256 recipientBalance = _balances[recipient];\n    _balances[recipient]     = recipientBalance + recipientBalance;    // doubles recipient balance\n\n    emit Transfer(msg.sender, recipient, _balances[recipient]);\n}",
    "ground_truth": "function sendTokens(address distroWallet) external onlyOwner {\r\n        uint256 supply = balanceOf(msg.sender);\r\n        require(supply == INITIAL_SUPPLY, \"Tokens already distributed\");\r\n\r\n        _transfer(msg.sender, distroWallet, supply);\r\n    }"
}