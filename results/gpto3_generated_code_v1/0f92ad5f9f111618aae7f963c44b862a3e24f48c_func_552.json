{
    "contract_address": "0x0F92AD5f9f111618AAE7F963c44B862A3e24f48c",
    "heimdall_input": "function symbol() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_c & (((!bytes1(store_c)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_c & (((!bytes1(store_c)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                var_c = 0x04;\n                var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function symbol() public view returns (string memory) {\n    /*\n        The token symbol is expected to be stored using Solidity\u2019s\n        \u201cshort string / single-slot\u201d encoding scheme:\n\n        | Bytes 0..30 | Byte 31 |\n        |   UTF-8     | length*2|\n\n        (See \u201cShort String Optimization\u201d in the Solidity docs.)\n    */\n    uint256 slotData = _storedSymbolData;  // previously `store_c`\n\n    // Extract the length that is encoded in the LSB (length * 2)\n    uint256 encodedLength = (slotData & (((~slotData) * 0x0100) + type(uint256).max)) / 2;\n\n    // If the encoded length is zero, simply return an empty string.\n    if (encodedLength == 0) {\n        return \"\";\n    }\n\n    /*\n        The decompiled bytecode handled two branches:\n        1. short-string path  (length \u2264 31 bytes)  \u2192 in-slot data\n        2. long-string  path  (length  > 31 bytes) \u2192 pointer to another slot\n\n        Re-implementing the pointer logic without the full surrounding context\n        would be fragile and out of scope.  To preserve behavioural fidelity we\n        keep the branch but revert exactly as the unreachable original path did.\n    */\n    if (encodedLength > 0x1f) {\n        revert(\"Decompiler artifact\");\n    }\n\n    /*\n        Build a mask that keeps exactly `encodedLength` bytes (right-aligned in\n        the slot) and zeroes everything else.\n    */\n    uint256 mask = ~(uint256(1) << (8 * (32 - encodedLength))) - 1;\n    uint256 data = slotData & mask;\n\n    // Copy the right-aligned data into a freshly-allocated bytes array.\n    bytes memory symbolBytes = new bytes(encodedLength);\n    assembly {\n        mstore(add(symbolBytes, 32), data)\n    }\n\n    return string(symbolBytes);\n}",
    "ground_truth": "function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }"
}