{
    "contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B",
    "heimdall_input": "function mintForPublic(uint256 arg0) public payable {\n        require(store_d - 0x02, CustomError_2c5a460a());\n        store_d = 0x02;\n        require(0x02 == salePhase, CustomError_2c5a460a());\n        require(!(arg0 > 0x03), CustomError_2c5a460a());\n        var_a = 0x2c5a460a00000000000000000000000000000000000000000000000000000000;\n        address var_b = msg.sender;\n        var_c = 0x17;\n        require(!(storage_map_t[var_b] > (arg0 + storage_map_t[var_b])), CustomError_30db1f08());\n        var_b = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_d = 0x11;\n        require(!((arg0 + storage_map_t[var_b]) > 0x03), CustomError_30db1f08());\n        var_a = 0x30db1f0800000000000000000000000000000000000000000000000000000000;\n        var_a = 0xb7b2409700000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1f;\n        var_g = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n    }",
    "llm_output": "error PhaseOrReentrancyError();\nerror WalletLimitError();\n\nfunction mintForPublic(uint256 quantity) external payable {\n    // Re-entrancy guard (equivalent to `require(_status != _ENTERED, ...)`)\n    if (_reentrancyStatus == 2) revert PhaseOrReentrancyError();\n    _reentrancyStatus = 2;\n\n    // Sale phase must be public (phase 2)\n    if (_salePhase != 2) revert PhaseOrReentrancyError();\n\n    // Per-transaction mint limit (max 3)\n    if (quantity > 3) revert PhaseOrReentrancyError();\n\n    uint256 alreadyMinted = _mintedPerWallet[msg.sender];\n\n    // Overflow-safe check kept for logical fidelity with decompiled bytecode\n    if (alreadyMinted > alreadyMinted + quantity) revert WalletLimitError();\n\n    // Per-wallet mint limit (max 3)\n    if (alreadyMinted + quantity > 3) revert WalletLimitError();\n\n    // NOTE: Actual minting logic was not present in the decompiled snippet.\n}",
    "ground_truth": "function mintForPublic(uint256 amount) external payable nonReentrant {\\n        if (salePhase != 2) revert SaleNotActive();\\n        if (amount > maxBatchSizeForWL) revert ExceedsMaxPerTransaction();\\n        if (_mintedPerAddress[msg.sender] + amount > maxBatchSizeForWL) revert ExceedsMaxPerAddress();\\n        if (totalSupply() + amount > AmountForPublic) revert ExceedsMaxPerPublic();\\n\\n        _mintedPerAddress[msg.sender] += amount; \\n\\n        uint256 totalPrice = MINT_PRICE * amount ; \\n        if (msg.value < totalPrice) revert InsufficientPayment();\\n        \\n        _safeMint(msg.sender, amount);\\n        \\n    }"
}