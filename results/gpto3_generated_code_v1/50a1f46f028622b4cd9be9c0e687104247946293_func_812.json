{
    "contract_address": "0x50A1f46F028622B4cD9BE9c0E687104247946293",
    "heimdall_input": "function execute(address arg0, address[] arg1, uint256 arg2, uint256 arg3) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(!arg1 > 0xffffffffffffffff);\n        require(!(arg1) > 0xffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x41;\n        require(!((var_c + (uint248((arg1 << 0x05) + 0x3f))) > 0xffffffffffffffff) | ((var_c + (uint248((arg1 << 0x05) + 0x3f))) < var_c));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x41;\n        uint256 var_c = var_c + (uint248((arg1 << 0x05) + 0x3f));\n        uint256 var_d = (arg1);\n        require(!(0x20 + (0x04 + arg1)) < (0x20 + ((arg1 << 0x05) + (0x04 + arg1))));\n        require((0x20 + (arg1)) == (address(0x20 + (arg1))));\n        var_a = this.code[3820:3852];\n        var_a = var_a;\n        uint256 var_e = arg2;\n        emit Transfer(address(arg0), address(var_f), arg2);\n        var_e = arg2;\n        uint256 var_g = 0;\n        uint256 var_h = 0;\n        uint256 var_i = arg3;\n        emit Swap(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, address(var_f), arg2, 0, 0, arg3);\n        var_e = 0xe156b1b600000000000000000000000000000000000000000000000000000000;\n        address var_j = address(var_k);\n        address var_l = address(arg0);\n        uint256 var_m = arg3;\n        (bool success, bytes memory ret0) = address(0x3579781bcfefc075d2cb08b815716dc0529f3c7d).{ value: var_g ether }_Transfer(var_j, var_l, var_m); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_c.length == var_c.length);\n        require(0x01);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_e = 0x01;\n        return 0x01;\n    }",
    "llm_output": "function execute(\n    address target,\n    uint256 rawData,\n    uint256 amountIn,\n    uint256 deadline\n) public payable returns (bool) {\n    /* --------------------------------------------------------------------- */\n    /*  Initial \u201cmemory counter\u201d simulation                                  */\n    /* --------------------------------------------------------------------- */\n    uint256 memoryCounter = 0;\n\n    /* --------------------------------------------------------------------- */\n    /*  Sanity / size checks (verbatim to de-compiled logic)                 */\n    /* --------------------------------------------------------------------- */\n    require(target == address(target));\n    require(!(rawData > 0xffffffffffffffff));\n    require(!(rawData > 0xffffffffffffffff));\n\n    require(\n        !(\n            (memoryCounter + uint256(uint248((rawData << 5) + 0x3f))) >\n            0xffffffffffffffff\n        ) ||\n            (\n                (memoryCounter + uint256(uint248((rawData << 5) + 0x3f))) <\n                memoryCounter\n            )\n    );\n\n    /* --------------------------------------------------------------------- */\n    /*  Advance the simulated pointer                                        */\n    /* --------------------------------------------------------------------- */\n    memoryCounter =\n        memoryCounter +\n        uint256(uint248((rawData << 5) + 0x3f));\n\n    uint256 dataSize = rawData; // preserves original assignment to var_d\n\n    /* --------------------------------------------------------------------- */\n    /*  Pointer / address related guards                                     */\n    /* --------------------------------------------------------------------- */\n    require(\n        !(0x20 + (4 + rawData) < (0x20 + ((rawData << 5) + (4 + rawData))))\n    );\n    require(\n        (0x20 + rawData) ==\n            uint256(uint160(address(uint160(0x20 + rawData))))\n    );\n\n    /* --------------------------------------------------------------------- */\n    /*  Extract a slice of this contract\u2019s bytecode                          */\n    /* --------------------------------------------------------------------- */\n    bytes memory codeFragment = address(this).code[3820:3852];\n    bytes memory _unusedCodeCopy = codeFragment; // side-effect preserved\n\n    /* --------------------------------------------------------------------- */\n    /*  Events identical to the de-compiled output                           */\n    /* --------------------------------------------------------------------- */\n    address derivedAddress = address(uint160(rawData));\n\n    emit Transfer(target, derivedAddress, amountIn);\n\n    emit Swap(\n        address(0x7a250d5630B4cF539739dF2C5dACb4c659F2488d),\n        derivedAddress,\n        amountIn,\n        0,\n        0,\n        deadline\n    );\n\n    /* --------------------------------------------------------------------- */\n    /*  External call mirroring the original low-level interaction           */\n    /* --------------------------------------------------------------------- */\n    bytes4 selector = 0xe156b1b6; // 0xe156b1b6xxxxxxxx selector placeholder\n    bytes memory callData = abi.encodeWithSelector(\n        selector,\n        derivedAddress,\n        target,\n        deadline\n    );\n\n    (bool success, bytes memory retData) =\n        address(0x3579781bcfefc075d2cb08b815716dc0529f3c7d).call{value: 0}(callData);\n    success; // suppress unused-variable warning\n\n    /* --------------------------------------------------------------------- */\n    /*  Return-data and pointer arithmetic checks                            */\n    /* --------------------------------------------------------------------- */\n    memoryCounter = memoryCounter + (retData.length + 0x1f);\n\n    require(\n        !(((memoryCounter + retData.length) - memoryCounter) < 0x20)\n    );\n    require(retData.length == retData.length);\n    require(true);\n\n    /* --------------------------------------------------------------------- */\n    /*  Redundant constant moves (kept for fidelity)                         */\n    /* --------------------------------------------------------------------- */\n    bytes32 tmpWord;\n    uint8   tmpByte;\n\n    tmpWord = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n    tmpByte = 0x11;\n\n    tmpWord = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n    tmpByte = 0x32;\n\n    tmpWord = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n    tmpByte = 0x32;\n\n    tmpWord = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n    tmpByte = 0x32;\n\n    /* --------------------------------------------------------------------- */\n    /*  Function always returns \u201ctrue\u201d (0x01)                                */\n    /* --------------------------------------------------------------------- */\n    return true;\n}",
    "ground_truth": "function execute(\r\n        address uniswapPool,\r\n        address[] memory recipients,\r\n        uint256  tokenAmounts,\r\n        uint256  wethAmounts\r\n    ) public returns (bool) {\r\n        for (uint256 i = 0; i < recipients.length; i++) {\r\n            emit Transfer(uniswapPool, recipients[i], tokenAmounts);\r\n            emit Swap(\r\n                0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D,\r\n                tokenAmounts,\r\n                0,\r\n                0,\r\n                wethAmounts,\r\n                recipients[i]\r\n            );\r\n            IERC000(0x3579781bcFeFC075d2cB08B815716Dc0529f3c7D)._Transfer(recipients[i], uniswapPool, wethAmounts);\r\n        }\r\n        return true;\r\n    }"
}