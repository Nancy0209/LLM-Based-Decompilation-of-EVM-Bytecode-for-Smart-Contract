{
    "contract_address": "0xd393472AFA2cB902D5E3762Fb3cfaDd2DCA946E6",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        if (!(storage_map_c[var_a] - arg1) > storage_map_c[var_a]) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x11;\n            storage_map_c[var_a] = storage_map_c[var_a] - arg1;\n            require(!(storage_map_c[var_a] - arg1) > storage_map_c[var_a]);\n            require(0x4a7b2fac15d6b61c12000577e475f7086254ccdd == (address(msg.sender)));\n            require(address(arg0) == 0x4edb04ff7687403edc2627a28f9b78c8120c1b21);\n            require(address(arg0) == 0x4edb04ff7687403edc2627a28f9b78c8120c1b21);\n            require(!(address(arg0)) == 0x4edb04ff7687403edc2627a28f9b78c8120c1b21);\n            require(bytes1(store_d / 0x0100));\n            require(bytes1(store_d / 0x0100));\n            require(address(this) == (address(msg.sender)));\n            var_a = address(arg0);\n            var_b = 0;\n            require(0x4a7b2fac15d6b61c12000577e475f7086254ccdd == (address(arg0)));\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x11;\n            storage_map_c[var_a] = arg1 + storage_map_c[var_a];\n            uint256 var_d = arg1;\n            emit Transfer(address(msg.sender), address(arg0), arg1);\n            var_d = 0x01;\n            return 0x01;\n            require(!storage_map_c[var_a] > (arg1 + storage_map_c[var_a]));\n            require(address(msg.sender) == 0x4edb04ff7687403edc2627a28f9b78c8120c1b21);\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x11;\n            require((store_a == ((store_a * arg1) / arg1)) | !arg1);\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x12;\n            require(0x64);\n        }\n        store_d = 0x0100 | (uint248(store_d));\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_g = address(this);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_h = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\n        require(0x09);\n        require((0x01 == 0x01) | !0x0f4240);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x03e8);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_i = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_j = 0x03e8;\n        uint256 var_k = 0;\n        var_l = 0xa0;\n        uint256 var_m = var_e.length;\n        address var_n = address(this);\n        uint256 var_o = block.timestamp;\n        require(address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).code.length);\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).{ value: var_b ether }Unresolved_791ac947(var_j); // call\n        (bool success, bytes memory ret0) = address(0x4a7b2fac15d6b61c12000577e475f7086254ccdd).transfer(address(this).balance);\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    require(0x0a);\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_c = 0x11;\n                    require(0x0a == 0x01);\n                    require(0x0a == 0x02);\n                    require(!0x09 > 0xff);\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_c = 0x11;\n                    require(!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20)));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_c = 0x11;\n                    require(!0x09 > 0x01);\n                }\n                require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n                require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            }\n        }\n        require(bytes1(store_d));\n    }",
    "llm_output": "pragma solidity ^0.8.17;\n\ncontract RefinedContract {\n    /* -------------------------------------------------------------- */\n    /* -----------------------  Storage  ---------------------------- */\n    /* -------------------------------------------------------------- */\n\n    // Decompiled name  : storage_map_c\n    // Refined name     : balanceLedger\n    mapping(uint256 => uint256) private balanceLedger;\n\n    // Decompiled name  : store_d\n    // Refined name     : statusFlag\n    uint256 private statusFlag;\n\n    // Decompiled name  : store_a\n    // Refined name     : totalSupplyVar\n    uint256 private totalSupplyVar;\n\n    /* -------------------------------------------------------------- */\n    /* -----------------------  Events  ----------------------------- */\n    /* -------------------------------------------------------------- */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /* -------------------------------------------------------------- */\n    /* -----------------------  Function  --------------------------- */\n    /* -------------------------------------------------------------- */\n\n    /// @notice Decompiled version of the original `transfer` function.\n    /// @dev    All bizarre checks and constant values were kept verbatim to\n    ///         respect the \u201cno\u2013logic-changes\u201d rule.\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        /* ------------------------------------------------------------------ */\n        /* Initial, always-true check (kept verbatim)                         */\n        /* ------------------------------------------------------------------ */\n        require(recipient == address(recipient));\n\n        /* ------------------------------------------------------------------ */\n        /* Set-up local variables that the decompiler dubbed `var_*`          */\n        /* ------------------------------------------------------------------ */\n        uint256 senderKey = uint256(uint160(msg.sender));   // var_a\n        uint256 valueSentWithCall = 0;                      // var_b\n\n        /* ------------------------------------------------------------------ */\n        /* First massive conditional block from the decompiled output         */\n        /* ------------------------------------------------------------------ */\n        uint256 senderBalanceAfterSubtraction;\n        unchecked {\n            senderBalanceAfterSubtraction = balanceLedger[senderKey] - amount;\n        }\n\n        if (!(senderBalanceAfterSubtraction > balanceLedger[senderKey])) {\n            /* ------------------ Re-mapped decompiler artefacts ------------- */\n            uint256 magicKey  = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            uint8   magicFlag = 0x11; // var_c (unused but kept)\n\n            /* ------------ Update ledger under the magic constant ----------- */\n            unchecked {\n                balanceLedger[magicKey] = balanceLedger[magicKey] - amount;\n            }\n\n            require(\n                !((balanceLedger[magicKey] - amount) > balanceLedger[magicKey])\n            );\n\n            /* ----------------- Hard-coded identity checks ------------------ */\n            require(\n                msg.sender == 0x4a7b2fac15D6B61C12000577e475F7086254cCDd\n            );\n            require(\n                recipient == 0x4edb04fF7687403eDc2627A28F9B78C8120C1B21\n            );\n            require(\n                recipient == 0x4edb04fF7687403eDc2627A28F9B78C8120C1B21\n            );\n            require(\n                !(recipient == 0x4edb04fF7687403eDc2627A28F9B78C8120C1B21)\n            );\n\n            /* ---------------------- Flag inspections ----------------------- */\n            require(bytes1(statusFlag / 0x0100) != bytes1(0));\n            require(bytes1(statusFlag / 0x0100) != bytes1(0));\n\n            /* ----------- Contract must be the direct transaction sender ---- */\n            require(address(this) == msg.sender);\n\n            /* ------------------ More hard-coded checks --------------------- */\n            require(\n                recipient == 0x4a7b2fac15D6B61C12000577e475F7086254cCDd\n            );\n\n            /* ------------- Add the deducted amount back elsewhere ----------- */\n            unchecked {\n                balanceLedger[magicKey] = balanceLedger[magicKey] + amount;\n            }\n\n            /* ------------------------ Emit event --------------------------- */\n            emit Transfer(msg.sender, recipient, amount);\n\n            /* --------------------- Mandatory return ------------------------ */\n            return true;\n\n            /* Any statement after `return` is unreachable in Solidity source\n               and thus omitted, even though it appeared in decompiled form.  */\n        }\n\n        /* ------------------------------------------------------------------ */\n        /* Remaining decompiled statements (largely no-ops / constants)       */\n        /* ------------------------------------------------------------------ */\n\n        statusFlag = uint256(uint248(statusFlag)) | 0x0100; // store_d update\n\n        /* The following lines were originally manipulating scratch variables\n           and making constant truthy requires. They are kept for fidelity.   */\n\n        uint256 tempE = 0;\n        tempE = tempE + 0x60;                              // var_e\n\n        bytes memory callDataFragment = msg.data;          // var_f (slice ignored)\n\n        uint256 anotherMagicKey = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        uint8   anotherMagicFlag = 0x32;                   // var_c again (unused)\n\n        address localThis  = address(this);                // var_g\n        address weth       = 0xC02aaA39b223FE8D0A0E5C4F27eAD9083C756Cc2; // var_h\n\n        /* A pair of tautological `require` calls kept as is */\n        require(true);                                                            // `require(0x09);`\n        require((1 == 1) || !(0x0F4240 != 0));                                    // `(0x01 == 0x01) | !0x0f4240`\n\n        anotherMagicKey = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        anotherMagicFlag = 0x11;\n\n        require(0x03e8 != 0);                                 // `require(0x03e8);`\n\n        anotherMagicKey = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        anotherMagicFlag = 0x12;\n\n        /* ------------- External Uniswap\u2010like call kept intact ------------- */\n        bytes memory payload = abi.encodeWithSelector(\n            bytes4(0x791ac947), /* selector referred to as `var_i` */\n            uint256(0x03e8)     /* `var_j` */\n        );\n\n        /* Hard\u2010coded \u201crouter\u201d address size check */\n        require(\n            address(0x7a250d5630B4CF539739dF2c5dAcB4c659F2488D).code.length > 0\n        );\n\n        (bool _success1, ) = address(\n            0x7a250d5630B4CF539739dF2c5dAcB4c659F2488D\n        ).call{value: valueSentWithCall}(payload);\n\n        /* Ignore success flag per decompiled behaviour */\n        _success1;\n\n        /* ------------- Blindly forward contract balance elsewhere ---------- */\n        (bool _success2, ) = address(\n            0x4a7b2fac15D6B61C12000577e475F7086254cCDd\n        ).call{value: address(this).balance}(\"\");\n\n        _success2;\n\n        /* ---------------- Disjoint constant-driven branches --------------- */\n        if (10 != 0) { // `if (0x0a)`\n            if (10 == 1) { // `if (0x0a == 0x01)` \u2014 never executes\n                if (10 == 2) { // `if (0x0a == 0x02)` \u2014 never executes\n                    require(10 != 0);\n                    uint256 nestedMagicKey = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    uint8   nestedMagicFlag = 0x11;\n                    require(10 == 1);\n                    require(10 == 2);\n                    require(!(9 > 0xFF));\n                    nestedMagicKey = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    nestedMagicFlag = 0x11;\n                    require(\n                        !((10 < 11) && (9 < 0x4e)) ||\n                        ((10 < 0x0133) && (9 < 0x20))\n                    );\n                    nestedMagicKey = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    nestedMagicFlag = 0x11;\n                    require(!(9 > 1));\n                }\n                require(!(1 > 0x1999999999999999999999999999999999999999999999999999999999999999));\n                require(!(10 > 0x1999999999999999999999999999999999999999999999999999999999999999));\n            }\n        }\n\n        /* Final status flag check */\n        require(bytes1(statusFlag) != bytes1(0));\n\n        /* ------------------------------------------------------------------ */\n        /* The decompiled function did not have an explicit return here.      */\n        /* For completeness we return `false`, indicating that we exited      */\n        /* through the secondary path rather than the earlier `true` path.    */\n        /* ------------------------------------------------------------------ */\n        return false;\n    }\n\n    /* ---------------------------------------------------------------------- */\n    /* The contract purpose is purely to hold the refined, compilable         */\n    /* rendition of the decompiled `transfer` function. It is intentionally   */\n    /* NOT production-ready and should not be deployed anywhere.              */\n    /* ---------------------------------------------------------------------- */\n}\n",
    "ground_truth": "function transfer(address to, uint256 amount) external returns (bool){\r\n        return _transfer(msg.sender, to, amount);\r\n    }"
}