{
    "contract_address": "0x4884709C72961015D2f9e97D123f4a2E480B9014",
    "heimdall_input": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_c >> 0x01;\n                if (store_c) {\n                    if (store_c - ((store_c >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c >> 0x01) {\n                            if (0x1f < (store_c >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "pragma solidity ^0.8.20;\n\ncontract DecompiledSymbolReader {\n    // Storage slot that actually holds the symbol string.\n    // The constructor or another function in the original contract should\n    // populate this variable; we merely read from it.\n    string private _tokenSymbol;\n\n    /*\n     * The decompiler produced a very convoluted piece of code for this\n     * function.  All it really does is read a `string` from storage and\n     * return it.  The following implementation performs the same low-level\n     * operations in readable form and without altering the original logic.\n     */\n    function symbol() public view returns (string memory result) {\n        assembly {\n            // -------------------------------------------------------------\n            // Resolve the slot that the Solidity compiler assigned to the\n            // `_tokenSymbol` storage variable.\n            // -------------------------------------------------------------\n            let symbolSlot := _tokenSymbol.slot\n\n            // Load the first storage word.  For Solidity\u2010encoded strings,\n            // this word uses the following scheme:\n            //\n            //  \u2011 short strings (<= 31 bytes):\n            //      bits[7:0]   \u2014 length * 2\n            //      bits[255:8] \u2014 actual UTF-8 bytes, right-aligned\n            //\n            //  \u2011 long strings (> 31 bytes):\n            //      bits[255:1] \u2014 keccak256(slot) (pointer to data)\n            //      bit[0]      \u2014 set to 1\n            //\n            // We branch on the low bit to decide which layout is in use.\n            let firstWord := sload(symbolSlot)\n\n            // Allocate a new memory area for the return value.\n            let memPtr := mload(0x40)\n\n            // -----------------------------------------------------------------\n            // BRANCH 1 \u2014 short string (<= 31 bytes)\n            // -----------------------------------------------------------------\n            switch and(firstWord, 1)\n            case 0 {\n                // Extract the length (stored in the lower byte, divided by 2)\n                let strLength := shr(1, firstWord)\n\n                // Reserve enough memory (32 bytes length word + padded data)\n                let paddedLen := and(add(add(strLength, 0x20), 0x1f), not(0x1f))\n                mstore(0x40, add(memPtr, paddedLen))\n\n                // Store the length\n                mstore(memPtr, strLength)\n\n                // Shift the actual bytes so they become left-aligned inside\n                // their 32-byte word, then write them to memory.\n                let shiftedData := shr(8, firstWord)\n                let alignedData := shl(mul(sub(32, strLength), 8), shiftedData)\n                mstore(add(memPtr, 0x20), alignedData)\n\n                result := memPtr\n            }\n            // -----------------------------------------------------------------\n            // BRANCH 2 \u2014 long string (> 31 bytes)\n            // -----------------------------------------------------------------\n            default {\n                // Compute the storage location that holds the length and the\n                // first word of data: keccak256(slot)\n                let dataSlot := keccak256(symbolSlot, 1)\n\n                // The first word at `dataSlot` is the string length\n                let strLength := sload(dataSlot)\n\n                // Calculate the total number of storage words that contain the\n                // actual string data:\n                //   ceil(strLength / 32) words + 1 word for the length\n                let totalWords := add(1, div(add(strLength, 31), 32))\n\n                // Allocate the required memory: (totalWords * 32 bytes)\n                let allocSize := mul(totalWords, 0x20)\n                mstore(0x40, add(memPtr, allocSize))\n\n                // Store the length\n                mstore(memPtr, strLength)\n\n                // Copy each 32-byte chunk from storage to memory\n                for { let i := 0 } lt(i, totalWords) { i := add(i, 1) } {\n                    mstore(\n                        add(memPtr, mul(add(i, 1), 0x20)),\n                        sload(add(dataSlot, i))\n                    )\n                }\n\n                result := memPtr\n            }\n        }\n    }\n}",
    "ground_truth": "function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }"
}