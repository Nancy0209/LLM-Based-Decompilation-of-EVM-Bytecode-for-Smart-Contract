{
    "contract_address": "0x5c22A66eEf970887AD301Ab39D551F18f756c9f5",
    "heimdall_input": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory tokenName) {\n    assembly {\n        // Load the storage slot that is assumed to hold the string.\n        // For most standard ERC-20/ERC-721 contracts, the name is\n        // stored at slot 0.  If the original source used another slot\n        // the compiler will remap this automatically.\n        let raw := sload(0)\n\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        //  Empty string quick-return\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if iszero(raw) {\n            tokenName := mload(0x40)      // free memory pointer\n            mstore(tokenName, 0)          // zero length\n            mstore(0x40, add(tokenName, 0x20))\n            leave\n        }\n\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        //  Short-string branch (LSB == 1)\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if and(raw, 1) {\n            let length := shr(1, raw)     // extract length\n\n            // Allocate length + 32 bytes (aligned to 32-byte words)\n            tokenName := mload(0x40)\n            let allocSize := and(add(add(length, 0x20), 0x1f), not(0x1f))\n            mstore(0x40, add(tokenName, allocSize))\n\n            // Store length\n            mstore(tokenName, length)\n\n            // Store data (right-aligned in the slot)\n            let mask := sub(shl(mul(8, sub(32, length)), 1), 1)\n            mstore(add(tokenName, 0x20), and(raw, mask))\n            leave\n        }\n\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        //  Long-string branch (LSB == 0)\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        // The slot now holds the location where the data starts.\n        // The actual data lives at keccak256(slot)\n        mstore(0x00, 0)\n        let dataSlot := keccak256(0x00, 0x20)\n\n        let length := sload(dataSlot)      // first word is the length\n\n        // Calculate the number of 32-byte words to copy\n        let words := div(add(length, 31), 32)\n\n        // Allocate memory (length + 32 bytes for the length prefix)\n        tokenName := mload(0x40)\n        let allocSize := and(add(add(length, 0x20), 0x1f), not(0x1f))\n        let newFreePtr := add(tokenName, allocSize)\n\n        // Panic if memory pointer would overflow (Solidity\u2019s behaviour)\n        if lt(newFreePtr, tokenName) {\n            // Panic(uint256) selector = 0x4e487b71, error code 0x22\n            mstore(0x00, 0x4e487b71)\n            mstore(0x04, 0x22)\n            revert(0x00, 0x24)\n        }\n\n        // Update free-memory pointer\n        mstore(0x40, newFreePtr)\n\n        // Store length\n        mstore(tokenName, length)\n\n        // Copy data word-by-word from storage to memory\n        {\n            let src := add(dataSlot, 1)    // first word of actual data\n            let dst := add(tokenName, 0x20)\n            for { let i := 0 } lt(i, words) { i := add(i, 1) } {\n                mstore(dst, sload(src))\n                dst := add(dst, 0x20)\n                src := add(src, 1)\n            }\n        }\n    }\n}",
    "ground_truth": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }"
}