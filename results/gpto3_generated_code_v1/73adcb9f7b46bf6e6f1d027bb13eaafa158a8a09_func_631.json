{
    "contract_address": "0x73adcB9F7B46BF6E6f1D027BB13eAAfa158A8A09",
    "heimdall_input": "function stake(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(secondsToNextEpoch > block.timestamp);\n        var_a = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        address var_c = address(this);\n        uint256 var_d = arg1;\n        (bool success, bytes memory ret0) = address(0x0a2746d0fe88eeb9538183408295c061593e478e).Unresolved_23b872dd(var_b); // call\n        uint256 var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        require(var_f == (var_f));\n        var_g = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_c = address(arg0);\n        var_d = arg1;\n        (bool success, bytes memory ret0) = address(0x0a2746d0fe88eeb9538183408295c061593e478e).Unresolved_a9059cbb(var_c); // call\n        var_a = 0x058ecdb400000000000000000000000000000000000000000000000000000000;\n        var_b = store_d;\n        var_c = store_e;\n        (bool success, bytes memory ret0) = address(0x0a2746d0fe88eeb9538183408295c061593e478e).Unresolved_058ecdb4(var_b, var_c); // call\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        require(var_f == (var_f));\n        require(!secondsToNextEpoch > (secondsToNextEpoch + epoch));\n        var_h = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        secondsToNextEpoch = secondsToNextEpoch + epoch;\n        require(store_e - 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        var_h = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        store_e = store_e + 0x01;\n        require(address(distributor / 0x01) == 0);\n        var_g = 0xe4fc6b6d00000000000000000000000000000000000000000000000000000000;\n        require(address(distributor / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(distributor / 0x01).distribute(var_c); // call\n        var_g = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_c = address(this);\n        (bool success, bytes memory ret0) = address(0x0a2746d0fe88eeb9538183408295c061593e478e).Unresolved_70a08231(var_c); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        require(var_f == (var_f));\n        var_j = 0x9358928b00000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(0x0a2746d0fe88eeb9538183408295c061593e478e).circulatingSupply(var_d); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        require(var_f == (var_f));\n        require(var_f > (var_f));\n        require(!(var_f - (var_f)) > (var_f));\n        store_d = (var_f) - (var_f);\n        var_k = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        address var_l = address(msg.sender);\n        address var_m = address(this);\n        uint256 var_n = arg1;\n        (bool success, bytes memory ret0) = address(0x0a2746d0fe88eeb9538183408295c061593e478e).Unresolved_23b872dd(var_l); // call\n        var_h = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n    }",
    "llm_output": "pragma solidity ^0.8.17;\n\ninterface IERC20Rebasing {\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function circulatingSupply() external view returns (uint256);\n    function rebase(uint256 profit, uint256 epoch) external returns (uint256);\n}\n\ninterface IDistributor {\n    function distribute(uint256 amount) external returns (bool);\n}\n\ncontract DecompiledStake {\n    IERC20Rebasing private constant TOKEN = IERC20Rebasing(0x0a2746d0fe88eeb9538183408295c061593e478e);\n\n    uint256 public secondsToNextEpoch;\n    uint256 public epoch;\n    address public distributor;\n\n    uint256 public gonsPerFragment;\n    uint256 public index;\n\n    /**\n     * Decompiler refined: stake function.\n     * NOTE: Logic is preserved exactly as observed in the decompiled byte-code.\n     */\n    function stake(address recipient, uint256 amount) external payable {\n        require(recipient == address(recipient), \"Self-check 1\");\n        require(amount == amount, \"Self-check 2\");\n        require(secondsToNextEpoch > block.timestamp, \"Epoch not started\");\n\n        uint256 memCounter = 0;\n        uint256 dummy      = 0;\n\n        /* -------------------------------- transferFrom -------------------------------- */\n        (bool success, bytes memory retData) = address(TOKEN).call(\n            abi.encodeWithSelector(\n                IERC20Rebasing.transferFrom.selector,\n                msg.sender,\n                address(this),\n                amount\n            )\n        );\n        require(success, \"transferFrom failed\");\n\n        memCounter += (retData.length + 0x1f);\n        require(!(((memCounter + retData.length) - memCounter) < 0x20), \"Mem check 1\");\n        require(dummy == dummy, \"Consistency 1\");\n\n        /* -------------------------------- transfer -------------------------------- */\n        (success, retData) = address(TOKEN).call(\n            abi.encodeWithSelector(\n                IERC20Rebasing.transfer.selector,\n                recipient,\n                amount\n            )\n        );\n        require(success, \"transfer failed\");\n\n        /* -------------------------------- rebase -------------------------------- */\n        (success, retData) = address(TOKEN).call(\n            abi.encodeWithSelector(\n                bytes4(0x058ecdb4),               // selector: 0x058ecdb4\n                gonsPerFragment,\n                index\n            )\n        );\n        require(success, \"rebase failed\");\n\n        memCounter += (retData.length + 0x1f);\n        require(!(((memCounter + retData.length) - memCounter) < 0x20), \"Mem check 2\");\n        require(dummy == dummy, \"Consistency 2\");\n\n        require(!(secondsToNextEpoch > (secondsToNextEpoch + epoch)), \"Epoch logic\");\n\n        /* ---- opaque error variables preserved from decompile ---- */\n        bytes4  _selectorError = 0x4e487b71;\n        uint256 _errorCode     = 0x11;\n\n        secondsToNextEpoch = secondsToNextEpoch + epoch;\n\n        unchecked {\n            require(index - type(uint256).max != 0, \"Index check\");\n        }\n\n        _selectorError = 0x4e487b71;\n        _errorCode     = 0x11;\n\n        index = index + 1;\n\n        /* -------------------------------- distributor checks -------------------------------- */\n        uint256 distributorNumeric = uint256(uint160(distributor)) / 0x01;\n        address processedDistributor = address(uint160(distributorNumeric));\n\n        require(processedDistributor == address(0), \"Distributor zero check\");\n\n        bytes4 distributeSelector = 0xe4fc6b6d;\n\n        require(processedDistributor.code.length > 0, \"No code at distributor\");\n\n        (success, retData) = processedDistributor.call(\n            abi.encodeWithSelector(distributeSelector, index)\n        );\n        require(success, \"distribute failed\");\n\n        /* -------------------------------- balanceOf -------------------------------- */\n        (success, retData) = address(TOKEN).staticcall(\n            abi.encodeWithSelector(\n                IERC20Rebasing.balanceOf.selector,\n                address(this)\n            )\n        );\n        require(success, \"balanceOf failed\");\n\n        memCounter += (retData.length + 0x1f);\n        require(!(((memCounter + retData.length) - memCounter) < 0x20), \"Mem check 3\");\n        require(dummy == dummy, \"Consistency 3\");\n\n        /* ---------------------------- circulatingSupply ---------------------------- */\n        (success, retData) = address(TOKEN).staticcall(\n            abi.encodeWithSelector(\n                bytes4(0x9358928b),               // selector: 0x9358928b\n                amount\n            )\n        );\n        require(success, \"circulatingSupply failed\");\n\n        memCounter += (retData.length + 0x1f);\n        require(!(((memCounter + retData.length) - memCounter) < 0x20), \"Mem check 4\");\n        require(dummy == dummy, \"Consistency 4\");\n\n        /* --- Decompiler artifact: unreachable / failing branch --- */\n        revert(\"Decompiler artifact\");\n    }\n}",
    "ground_truth": "function stake(address _to, uint256 _amount) external {\r\n        rebase();\r\n        GRP.transferFrom(msg.sender, address(this), _amount);\r\n        sGRP.transfer(_to, _amount);\r\n    }"
}