{
    "contract_address": "0x3e628c6678825195453B33f713147B8fb641248b",
    "heimdall_input": "function name() public view returns (string memory) {\n        if (store_w) {\n            if (store_w - ((store_w >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_w >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_w >> 0x01;\n                if (store_w) {\n                    if (store_w - ((store_w >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_w >> 0x01) {\n                            if (0x1f < (store_w >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_c[var_a];\n                                if ((0x20 + var_c) + (store_w >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory) {\n    // `_name` is assumed to be a `string` defined elsewhere in contract storage.\n    string storage storedName = _name;\n\n    assembly {\n        let slotPtr := storedName.slot\n        let slotVal := sload(slotPtr)\n\n        // If the stored slot is zero, the string is empty.\n        switch slotVal\n        case 0 {\n            // Allocate 64 bytes for the standard ABI-encoded empty string.\n            let retPtr := mload(0x40)\n            mstore(retPtr, 0x20)         // offset\n            mstore(add(retPtr, 0x20), 0) // length\n            return(retPtr, 0x40)\n        }\n        default {\n            // Extract the string length (lower 255 bits / >>1).\n            let inlineLen := shr(1, slotVal)\n\n            // ------------------------------------------------------------\n            // CASE 1 \u2014 Short string (< 32 bytes): data packed in the slot.\n            // ------------------------------------------------------------\n            if lt(inlineLen, 0x20) {\n                let retPtr := mload(0x40)\n                let totalSize := add(inlineLen, 0x40) // offset + length + data\n                mstore(0x40, add(retPtr, totalSize))\n\n                mstore(retPtr, 0x20)                // offset to data payload\n                mstore(add(retPtr, 0x20), inlineLen) // length\n\n                // Shift packed data so it is left-aligned in a 32-byte word.\n                let shifted := shl(mul(sub(0x20, inlineLen), 8), slotVal)\n                mstore(add(retPtr, 0x40), shifted)\n\n                return(retPtr, totalSize)\n            }\n\n            // ------------------------------------------------------------\n            // CASE 2 \u2014 Long string (\u2265 32 bytes): data in separate storage.\n            // ------------------------------------------------------------\n            {\n                // Starting storage index of string bytes.\n                let dataPtr := keccak256(slotPtr, 0x20)\n                let fullLen := inlineLen\n                let words := div(add(fullLen, 0x1f), 0x20) // ceil(len / 32)\n\n                let retPtr := mload(0x40)\n                let totalSize := add(0x40, mul(words, 0x20))\n                mstore(0x40, add(retPtr, totalSize))\n\n                mstore(retPtr, 0x20)                 // offset\n                mstore(add(retPtr, 0x20), fullLen)   // length\n\n                // Copy each 32-byte word from storage to memory.\n                let dest := add(retPtr, 0x40)\n                for { let i := 0 } lt(i, words) { i := add(i, 1) } {\n                    mstore(dest, sload(add(dataPtr, i)))\n                    dest := add(dest, 0x20)\n                }\n\n                return(retPtr, totalSize)\n            }\n        }\n    }\n}",
    "ground_truth": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }"
}