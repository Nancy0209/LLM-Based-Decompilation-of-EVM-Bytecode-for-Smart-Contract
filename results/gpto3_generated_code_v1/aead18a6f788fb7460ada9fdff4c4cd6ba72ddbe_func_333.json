{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!address(0xaaeb6d7670e522a718067333cd4e).code.length, CustomError_df2d9b42());\n        require(0x01 > arg1, CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(0 - storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(!0x01, CustomError_cfb3b942());\n        require(!0x01, CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c46;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c47;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c46;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_a = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        require(!(!(address(storage_map_b[var_a])) == msg.sender), CustomError_df2d9b42());\n        var_a = arg1;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c46;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        require(arg1 < totalSupply, CustomError_df2d9b42());\n        var_a = arg1 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = (arg1 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = ((arg1 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = (((arg1 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xc617113400000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        address var_e = address(arg0);\n        (bool success, bytes memory ret0) = address(0xaaeb6d7670e522a718067333cd4e).Unresolved_c6171134(var_d); // staticcall\n        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));\n        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_ede71dcc());\n        require(var_f.length == var_f.length, CustomError_ede71dcc());\n        require(var_f.length, CustomError_ede71dcc());\n        var_g = 0xede71dcc00000000000000000000000000000000000000000000000000000000;\n        var_e = address(arg0);\n    }",
    "llm_output": "function approve(address spender, uint256 amount) public payable {\n    /* solhint-disable no-inline-assembly */\n\n    // 1. Trivial equality check\n    if (spender != address(spender)) {\n        revert CustomError_df2d9b42();\n    }\n\n    // 2. Target contract must be non-existent (code size == 0)\n    if (address(0xaaeb6d7670e522a718067333cd4e).code.length != 0) {\n        revert CustomError_df2d9b42();\n    }\n\n    // 3. Only amounts strictly smaller than 1 are accepted\n    if (!(1 > amount)) {\n        revert CustomError_df2d9b42();\n    }\n\n    uint256 slotIndex = amount;\n\n    // 4. Series of arithmetic / byte-level checks on the storage slot\n    unchecked {\n        uint256 diff = 0 - _storageMap[slotIndex];\n        if (diff == 0) {\n            revert CustomError_df2d9b42();\n        }\n\n        bytes1 lowestByte = bytes1(bytes32(_storageMap[slotIndex]));\n        uint256 diffByte = 0 - uint8(lowestByte);\n        if (diffByte == 0) {\n            revert CustomError_df2d9b42();\n        }\n    }\n\n    // 5. Hard-coded constant seen in the original bytecode\n    uint256 constantSelector = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n\n    // 6. Two unconditional failures (`require(!0x01, \u2026)` in the byte-code)\n    revert CustomError_cfb3b942();\n    revert CustomError_cfb3b942();\n\n    // ----------------------------------------------------------------------------------\n    // NOTE: The original byte-code never reaches the logic below because of the\n    //       unconditional reverts above. It is kept here purely for semantic parity\n    //       and will therefore be dead-code in practice.\n    // ----------------------------------------------------------------------------------\n\n    // 7. Store the spender address in the mapping & emit Approval\n    _storageMap[slotIndex] =\n        uint256(uint160(spender)) |\n        uint256(uint96(_storageMap[slotIndex]));\n\n    emit Approval(address(uint160(_storageMap[slotIndex])), spender, amount);\n\n    // 8. Miscellaneous hashing and byte checks\n    address ownerAddress = address(uint160(_storageMap[slotIndex]));\n    bytes32 callerHash = keccak256(abi.encodePacked(msg.sender));\n\n    bytes1 storedByte = bytes1(bytes32(_storageMap[slotIndex]));\n    if (storedByte == 0) {\n        revert CustomError_cfb3b942();\n    }\n\n    // 9. Repeat the write & event (as in original byte-code)\n    _storageMap[slotIndex] =\n        uint256(uint160(spender)) |\n        uint256(uint96(_storageMap[slotIndex]));\n\n    emit Approval(address(uint160(_storageMap[slotIndex])), spender, amount);\n\n    // 10. Comparison between a stored address and `msg.sender`\n    if (!(address(uint160(_storageMap[constantSelector])) != msg.sender)) {\n        revert CustomError_df2d9b42();\n    }\n\n    // 11. Third write & event emission\n    _storageMap[slotIndex] =\n        uint256(uint160(spender)) |\n        uint256(uint96(_storageMap[slotIndex]));\n\n    emit Approval(address(uint160(_storageMap[slotIndex])), spender, amount);\n\n    // 12. Supply-based check\n    if (!(amount < totalSupply)) {\n        revert CustomError_df2d9b42();\n    }\n\n    // 13. Repetitive storage slot checks with underflow arithmetic\n    uint256 previousSlot = amount + type(uint256).max;\n    unchecked {\n        if (_storageMap[previousSlot] != 0) revert CustomError_df2d9b42();\n        if (uint8(bytes1(bytes32(_storageMap[previousSlot]))) == 0) revert CustomError_df2d9b42();\n    }\n\n    previousSlot = previousSlot + type(uint256).max;\n    unchecked {\n        if (_storageMap[previousSlot] != 0) revert CustomError_df2d9b42();\n        if (uint8(bytes1(bytes32(_storageMap[previousSlot]))) == 0) revert CustomError_df2d9b42();\n    }\n\n    previousSlot = previousSlot + type(uint256).max;\n    unchecked {\n        if (_storageMap[previousSlot] != 0) revert CustomError_df2d9b42();\n        if (uint8(bytes1(bytes32(_storageMap[previousSlot]))) == 0) revert CustomError_df2d9b42();\n    }\n\n    previousSlot = previousSlot + type(uint256).max;\n    unchecked {\n        if (_storageMap[previousSlot] != 0) revert CustomError_df2d9b42();\n        if (uint8(bytes1(bytes32(_storageMap[previousSlot]))) == 0) revert CustomError_df2d9b42();\n    }\n\n    // 14. External static-call using selector 0xc6171134\n    (bool ok, bytes memory ret) =\n        address(0xaaeb6d7670e522a718067333cd4e).staticcall(\n            abi.encodeWithSelector(0xc6171134, address(this))\n        );\n\n    if (!ok) {\n        revert CustomError_ede71dcc();\n    }\n\n    uint256 offset;\n    unchecked {\n        offset += ((ret.length + 0x1f) & (~uint256(0x1f)));\n    }\n\n    if (((offset + ret.length) - offset) < 0x20) {\n        revert CustomError_ede71dcc();\n    }\n    if (ret.length != ret.length) {\n        revert CustomError_ede71dcc();\n    }\n    if (ret.length == 0) {\n        revert CustomError_ede71dcc();\n    }\n\n    // 15. Final variable preserved from decompiler output (no functional impact)\n    address _finalSpender = spender;\n\n    /* solhint-enable no-inline-assembly */\n}",
    "ground_truth": "function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}"
}