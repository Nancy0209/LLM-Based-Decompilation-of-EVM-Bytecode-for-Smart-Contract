{
    "contract_address": "0xe3023a720d6f4d03b78763EDB3587f123565Cc6D",
    "heimdall_input": "function investorOrderIds(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x08;\n        address var_c = 0x20 + (var_c + (0x20 * storage_map_c[var_a]));\n        address var_d = storage_map_c[var_a];\n        require(!storage_map_c[var_a]);\n        var_a = keccak256(var_a);\n        address var_e = storage_map_c[var_a];\n        require((var_c + 0x20) + (0x20 * storage_map_c[var_a]) > (0x20 + (var_c + 0x20)));\n        var_e = 0x20;\n        address var_f = var_c.length;\n        return abi.encodePacked(0x20, var_c.length);\n    }",
    "llm_output": "function investorOrderIds(address investor) public view returns (bytes memory) {\n    // This odd always-true check exists in the decompiled output \u2013 keep it unchanged\n    require(investor == address(investor), \"Decompiler invariant check failed\");\n\n    uint256 orderCount;\n    bytes memory encodedData;\n\n    assembly {\n        // The decompiled code worked off storage slot 8 for the mapping.\n        // Compute the slot that would hold `orderCount = mapping[address => uint256]` at slot 8.\n        mstore(0x0, investor)          // key\n        mstore(0x20, 8)                // slot\n        let slot := keccak256(0x0, 0x40)\n\n        // Load the value (presumed length) from storage\n        orderCount := sload(slot)\n\n        // Replicate the strange `require(!storage_map_c[var_a])`\n        // i.e. revert if `orderCount` is *not* zero\n        if orderCount {\n            revert(0, 0)\n        }\n\n        // -----------------------------------------------------------------\n        // The original decompiled code eventually returned:\n        //     abi.encodePacked(0x20, var_c.length)\n        // Re-create that behaviour here.\n        // -----------------------------------------------------------------\n        let ptr := mload(0x40)         // free memory pointer\n        mstore(ptr, 0x20)              // first 32 bytes = 0x20\n        mstore(add(ptr, 0x20), orderCount)  // next 32 bytes = length (0 when not reverted)\n        let size := 0x40               // total size = 64 bytes\n        mstore(0x40, add(ptr, size))   // update free mem pointer\n\n        encodedData := ptr\n        // When execution leaves `assembly`, `encodedData` will be returned.\n    }\n\n    return encodedData;\n}",
    "ground_truth": "function investorOrderIds(address investor)\r\n        external\r\n        view\r\n        returns (uint256[] memory ids)\r\n    {\r\n        uint256[] memory arr = orderIds[investor];\r\n        return arr;\r\n    }"
}