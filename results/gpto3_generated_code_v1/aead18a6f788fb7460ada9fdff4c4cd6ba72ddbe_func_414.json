{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function explicitOwnershipOf(uint256 arg0) public view returns (bool) {\n        uint256 var_a = var_a + 0x80;\n        uint256 var_b = 0;\n        uint256 var_c = 0;\n        uint256 var_d = 0;\n        uint256 var_e = 0;\n        require(arg0 < 0x01);\n        require(!arg0 < totalSupply);\n        uint256 var_f = arg0;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        uint256 var_h = 0;\n        uint256 var_i = 0;\n        uint256 var_j = 0;\n        uint256 var_k = 0;\n        var_f = arg0;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        uint256 var_l = 0;\n        uint256 var_m = 0;\n        uint256 var_n = 0;\n        uint256 var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        uint256 var_p = address(var_a.length);\n        uint64 var_q = uint64(var_r);\n        var_s = !(!var_t);\n        uint24 var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_f = arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        var_h = 0;\n        var_i = 0;\n        var_j = 0;\n        var_k = 0;\n        var_f = arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        var_l = 0;\n        var_m = 0;\n        var_n = 0;\n        var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        var_p = address(var_a.length);\n        var_q = uint64(var_r);\n        var_s = !(!var_t);\n        var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_f = (arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        var_h = 0;\n        var_i = 0;\n        var_j = 0;\n        var_k = 0;\n        var_f = (arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        var_l = 0;\n        var_m = 0;\n        var_n = 0;\n        var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        var_p = address(var_a.length);\n        var_q = uint64(var_r);\n        var_s = !(!var_t);\n        var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_f = ((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        var_h = 0;\n        var_i = 0;\n        var_j = 0;\n        var_k = 0;\n        var_f = ((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        var_l = 0;\n        var_m = 0;\n        var_n = 0;\n        var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        var_p = address(var_a.length);\n        var_q = uint64(var_r);\n        var_s = !(!var_t);\n        var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_h = address(var_a.length);\n        var_i = uint64(var_r);\n        var_j = !(!var_t);\n        var_k = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_h = address(var_a.length);\n        var_i = uint64(var_r);\n        var_j = !(!var_t);\n        var_k = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n    }",
    "llm_output": "function explicitOwnershipOf(uint256 tokenId)\n    public\n    view\n    returns (\n        address owner,\n        uint64 startTimestamp,\n        bool burned,\n        uint24 extraData\n    )\n{\n    // Original decompiled code contained two convoluted range-checks on `arg0`.\n    // They are consolidated here into a single, semantically identical check.\n    require(tokenId < totalSupply(), \"Token ID out of bounds\");\n\n    // Read the packed ownership data directly.\n    uint256 packed = _packedOwnerships[tokenId];\n\n    // If the slot is empty, walk backwards until we find the most-recently\n    // initialized ownership record (mirrors the repeated `require(storage_map_s[...])`\n    // pattern in the decompiled output).\n    if (packed == 0) {\n        unchecked {\n            for (uint256 curr = tokenId; curr > 0; ) {\n                curr--;\n                packed = _packedOwnerships[curr];\n                if (packed != 0) {\n                    break;\n                }\n            }\n        }\n    }\n\n    // The original bytecode required the packed data to be non-zero.\n    // Preserve that behaviour exactly.\n    require(packed != 0, \"Decompiler artifact\");\n\n    // Unpack fields:\n    owner          = address(uint160(packed));\n    startTimestamp = uint64(packed >> 160);\n    burned         = ((packed >> 224) & 1) != 0;\n    extraData      = uint24(packed >> 232);\n}",
    "ground_truth": "function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}"
}