{
    "contract_address": "0x30F674e5399B6493A6096d239153b21331fbC670",
    "heimdall_input": "function symbol() public view returns (string memory) {\n        if (store_w) {\n            if (!(store_w) == ((store_w >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_w >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_w >> 0x01;\n                if (store_w) {\n                    if (!(store_w) == ((store_w >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_w >> 0x01) {\n                            if (0x1f < (store_w >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_d[var_a];\n                                if ((0x20 + var_c) + (store_w >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function symbol() public view returns (string memory) {\n    assembly {\n        // Storage slot that holds the `_symbol` string.\n        // For a standard ERC-20 implementation this is `1`\n        // (slot `0` is usually `_name`, slot `1` is `_symbol`).\n        let slot := 1\n\n        // Load the raw storage word.\n        let data := sload(slot)\n\n        // `ptr` will be our main memory pointer.\n        let ptr := mload(0x40)\n\n        // ------------------------------------------------------------------ //\n        // Case 0: empty string                                               //\n        // ------------------------------------------------------------------ //\n        if iszero(data) {\n            mstore(ptr, 0x20)           // offset to the data part\n            mstore(add(ptr, 0x20), 0)   // zero length\n            return(ptr, 0x40)\n        }\n\n        // ------------------------------------------------------------------ //\n        // Case 1: string length \u2264 31 bytes (stored in the slot itself)       //\n        // ------------------------------------------------------------------ //\n        if eq(and(data, 1), 1) {\n            // Length is stored in the least-significant byte, multiplied by 2\n            let len := shr(1, and(data, 0xFF))\n\n            // ABI \u2011 encode: first the offset, then the actual data\n            mstore(ptr, 0x20)               // offset to data\n            mstore(add(ptr, 0x20), len)     // length\n\n            let strPtr := add(ptr, 0x40)    // where the bytes will be written\n\n            // Drop the least-significant byte (len*2+1 flag) and right-align\n            mstore(strPtr, shr(8, data))\n\n            // Zero-pad unused memory (cleanliness, matches compiler output)\n            mstore(add(strPtr, len), 0)\n\n            // Update free memory pointer (32 bytes for the word we just used)\n            mstore(0x40, add(strPtr, 0x20))\n\n            return(ptr, sub(mload(0x40), ptr))\n        }\n\n        // ------------------------------------------------------------------ //\n        // Case 2: string length > 31 bytes                                   //\n        // ------------------------------------------------------------------ //\n        {\n            // Actual length is stored in all but the lowest bit.\n            let len := shr(1, data)\n\n            // Compute the slot where the data begins: keccak256(slot)\n            let temp := add(ptr, 0x80)   // temporary memory for hashing\n            mstore(temp, slot)\n            let dataSlot := keccak256(temp, 0x20)\n\n            // ABI \u2011 encode header (offset and length)\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), len)\n\n            let strPtr := add(ptr, 0x40)\n\n            // Number of 32-byte words to copy\n            let words := div(add(len, 31), 32)\n\n            // Copy loop\n            for { let i := 0 } lt(i, words) { i := add(i, 1) } {\n                mstore(add(strPtr, mul(i, 0x20)), sload(add(dataSlot, i)))\n            }\n\n            // Zero-pad the tail for cleanliness\n            mstore(add(strPtr, len), 0)\n\n            // Update free memory pointer\n            mstore(0x40, add(strPtr, mul(words, 0x20)))\n\n            return(ptr, sub(mload(0x40), ptr))\n        }\n    }\n}",
    "ground_truth": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }"
}