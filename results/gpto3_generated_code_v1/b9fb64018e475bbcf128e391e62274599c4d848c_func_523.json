{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function getMintStats(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = uint64(storage_map_b[var_a] >> 0x40);\n        uint256 var_d = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + totalSupply;\n        var_e = maxSupply;\n        return abi.encodePacked(uint64(storage_map_b[var_a] >> 0x40), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + totalSupply, maxSupply);\n    }",
    "llm_output": "function getMintStats(address user) public view returns (bytes memory) {\n    // Redundant check preserved from the decompiled code\n    require(user == address(user));\n\n    // Unused constant, kept to maintain perfect logical fidelity\n    uint256 _constant = 0x05;\n    _constant; // suppress \u201cunused\u201d warning\n\n    // Extract the user-specific data (upper 64 bits starting at bit 64)\n    uint64 userMintCount = uint64(storage_map_b[user] >> 64);\n\n    // Equivalent to (type(uint256).max + totalSupply) with wrapping arithmetic\n    uint256 totalSupplyMinusOne;\n    unchecked {\n        totalSupplyMinusOne = type(uint256).max + totalSupply;\n    }\n\n    return abi.encodePacked(\n        userMintCount,\n        totalSupplyMinusOne,\n        maxSupply\n    );\n}",
    "ground_truth": "function getMintStats(address minter)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 minterNumMinted,\\n            uint256 currentTotalSupply,\\n            uint256 maxSupply\\n        )\\n    {\\n        minterNumMinted = _numberMinted(minter);\\n        currentTotalSupply = _totalMinted();\\n        maxSupply = _maxSupply;\\n    }"
}