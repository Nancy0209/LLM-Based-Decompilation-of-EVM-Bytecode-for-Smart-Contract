{
    "contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b",
    "heimdall_input": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(0x01 > arg1, CustomError_df2d9b42());\n        require(!(arg1 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x04;\n        require(bytes1(storage_map_n[var_a]), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(storage_map_n[var_a], CustomError_cfb3b942());\n        require(address(storage_map_n[var_a]) == msg.sender, CustomError_cfb3b942());\n        var_a = address(storage_map_n[var_a]);\n        var_b = 0x07;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_n[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_c = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1;\n        var_b = 0x04;\n        if (storage_map_n[var_a]) {\n            var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1);\n            var_b = 0x04;\n            if (storage_map_n[var_a]) {\n                var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1));\n                var_b = 0x04;\n                if (storage_map_n[var_a]) {\n                }\n            }\n        }\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function approve(address to, uint256 tokenId) public payable {\n        // Redundant cast check (kept for logical fidelity)\n        require(to == address(to));\n\n        // Original: require(0x01 > tokenId, CustomError_df2d9b42());\n        if (!(tokenId < 1)) revert CustomError_df2d9b42();\n\n        // Original: require(!(tokenId < totalSupply), CustomError_df2d9b42());\n        if (tokenId < totalSupply) revert CustomError_df2d9b42();\n\n        // Ensure token data exists\n        if (bytes1(bytes32(_tokenData[tokenId])) == bytes1(0)) revert CustomError_df2d9b42();\n\n        // Additional ownership checks\n        if (_tokenData[tokenId] == 0) revert CustomError_cfb3b942();\n        if (address(uint160(_tokenData[tokenId])) != msg.sender) revert CustomError_cfb3b942();\n\n        // Hash calculated but unused in original logic\n        bytes32 _unusedHash = keccak256(abi.encodePacked(msg.sender));\n        _unusedHash; // suppress unused variable warning\n\n        // Further redundant check replicated exactly\n        if (bytes1(bytes32(_tokenData[uint256(uint160(msg.sender))])) == bytes1(0)) revert CustomError_cfb3b942();\n\n        // Update approval information\n        _tokenData[tokenId] = uint256(uint160(to)) | uint256(uint96(_tokenData[tokenId]));\n        emit Approval(address(uint160(_tokenData[tokenId])), to, tokenId);\n\n        // Duplicate store and event (present in original byte-code)\n        _tokenData[tokenId] = uint256(uint160(to)) | uint256(uint96(_tokenData[tokenId]));\n        emit Approval(address(uint160(_tokenData[tokenId])), to, tokenId);\n\n        // Series of overflowing index manipulations replicated with unchecked blocks\n        uint256 index;\n        unchecked { index = type(uint256).max + tokenId; }\n\n        if (_tokenData[index] != 0) {\n            unchecked { index = type(uint256).max + index; }\n            if (_tokenData[index] != 0) {\n                unchecked { index = type(uint256).max + index; }\n                if (_tokenData[index] != 0) {\n                    // No-op as per decompiled logic\n                }\n            }\n        }\n\n        // Trailing constant assignments in original code had no effect; omitted here.\n    }",
    "ground_truth": "function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}"
}