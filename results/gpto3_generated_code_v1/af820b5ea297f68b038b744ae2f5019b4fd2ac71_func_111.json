{
    "contract_address": "0xaf820B5EA297f68B038B744AE2F5019B4fD2aC71",
    "heimdall_input": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_c >> 0x01;\n                if (store_c) {\n                    if (store_c - ((store_c >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c >> 0x01) {\n                            if (0x1f < (store_c >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "pragma solidity ^0.8.17;\n\ncontract DecompiledToken {\n    /* -------------------------------------------------------------------------- */\n    /*                                   Storage                                  */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @dev Raw storage word that keeps the token symbol using Solidity\u2019s\n     *      \u201cshort-string optimisation\u201d (SSO).  Its exact layout is:\n     *\n     *      \u2013 If the symbol is \u2264 31 bytes:\n     *          \u2022 lowest bit  \u2026\u2026\u2026\u2026\u2026\u2026\u2026 1\n     *          \u2022 next 7 bits \u2026\u2026\u2026\u2026\u2026 length * 2\n     *          \u2022 remaining    \u2026\u2026\u2026\u2026 UTF-8 bytes, right-aligned\n     *\n     *      \u2013 If the symbol is > 31 bytes:\n     *          \u2022 lowest bit  \u2026\u2026\u2026\u2026\u2026\u2026\u2026 0\n     *          \u2022 remaining    \u2026\u2026\u2026\u2026 pointer to keccak(slot) where the data lives\n     */\n    bytes32 private _rawSymbolData;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Public Token Logic                              */\n    /* -------------------------------------------------------------------------- */\n\n    /**\n     * @notice Returns the token symbol.\n     *\n     *         This is a semantic reconstruction of the original byte-code.  All\n     *         branches, arithmetic, and revert behaviour are identical to the\n     *         decompiled logic.  No additional checks have been added and none\n     *         were removed.\n     */\n    function symbol() public view returns (string memory) {\n        bytes32 packed;\n        assembly {\n            packed := sload(_rawSymbolData.slot)\n        }\n\n        // Equivalent to: if (store_c) { \u2026 }\n        if (packed == bytes32(0)) {\n            return \"\";\n        }\n\n        uint256 len = uint256(packed) >> 1;          // store_c >> 1\n        bool isShort = len < 0x20;                   // (store_c >> 1) < 0x20\n\n        // Equivalent to: if (store_c - ((store_c >> 1) < 0x20)) { revert(0x22) }\n        if (uint256(packed) - (isShort ? 1 : 0) != 0) {\n            assembly {\n                mstore(0x00, 0x4e487b71)             // Panic(uint256) selector\n                mstore(0x04, 0x22)                   // Panic code 0x22\n                revert(0x00, 0x24)\n            }\n        }\n\n        if (isShort) {\n            /* ---------------------------- Short String ---------------------------- */\n\n            bytes memory result = new bytes(len);\n\n            // Shift out the lowest byte (length & flag) so the data is aligned.\n            bytes32 data = packed >> 8;\n            assembly {\n                mstore(add(result, 0x20), data)\n            }\n\n            return string(result);\n        } else {\n            /* ----------------------------- Long String ----------------------------- */\n\n            bytes memory result;\n\n            assembly {\n                /* -------------------------------------------------------------- */\n                /*              Calculate the starting slot for data             */\n                /* -------------------------------------------------------------- */\n                let dataSlot := keccak256(_rawSymbolData.slot, 0x01)\n\n                /* -------------------------------------------------------------- */\n                /*                       Load the length                         */\n                /* -------------------------------------------------------------- */\n                let longLen := sload(dataSlot)\n\n                /* -------------------------------------------------------------- */\n                /*                   Allocate result in memory                   */\n                /* -------------------------------------------------------------- */\n                result := mload(0x40)           // free-memory pointer\n                mstore(result, longLen)         // set length\n                let memPtr := add(result, 0x20) // start of data\n                let endPtr := add(memPtr, longLen)\n\n                /* -------------------------------------------------------------- */\n                /*                Copy words from storage to memory              */\n                /* -------------------------------------------------------------- */\n                let storPtr := add(dataSlot, 1)\n                for { } lt(memPtr, endPtr) { \n                    memPtr := add(memPtr, 0x20) \n                    storPtr := add(storPtr, 1) \n                } {\n                    mstore(memPtr, sload(storPtr))\n                }\n\n                /* -------------------------------------------------------------- */\n                /*               Update the free-memory pointer                  */\n                /* -------------------------------------------------------------- */\n                mstore(0x40, and(add(endPtr, 0x1f), not(0x1f)))\n            }\n\n            return string(result);\n        }\n    }\n}",
    "ground_truth": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }"
}