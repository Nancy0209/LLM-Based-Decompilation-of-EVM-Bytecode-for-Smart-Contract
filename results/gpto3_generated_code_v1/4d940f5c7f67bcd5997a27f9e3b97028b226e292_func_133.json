{
    "contract_address": "0x4d940f5C7f67BcD5997a27F9E3b97028B226e292",
    "heimdall_input": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (!(store_c) == ((store_c / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_c / 0x02;\n                if (store_c) {\n                    if (!(store_c) == ((store_c / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c / 0x02) {\n                            if (0x1f < (store_c / 0x02)) {\n                                var_a = 0x05;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function symbol() public view returns (string memory) {\n    assembly {\n        /**\n         * In the original contract the ERC-20 symbol is stored in slot 2.\n         * The de-compilation produced a large amount of convoluted logic;\n         * the following inline assembly keeps that logic intact while\n         * translating it into valid, compilable Solidity.\n         */\n        let SYMBOL_SLOT := 0x02\n        let raw := sload(SYMBOL_SLOT)     // == store_c in the de-compiled output\n\n        /* ------------------------------------------------------------ */\n        /*               EXACT REPRODUCTION OF ORIGINAL CHECKS          */\n        /* ------------------------------------------------------------ */\n\n        if raw {\n            /* first \u201cpanic\u201d branch */\n            if eq(iszero(raw), lt(div(raw, 2), 0x20)) {\n                mstore(0x00, 0x4e487b71)    // Panic(uint256) selector\n                mstore(0x04, 0x22)          // panic code 0x22 (index out of bounds)\n                revert(0x00, 0x24)\n            }\n\n            /* these variables have no observable effect but were present\n               in the decompiled control flow; they are left here to keep\n               semantic parity with the original byte-code. */\n            let _tmpOffset := add(\n                0x20,\n                mul(\n                    div(add(0x1f, div(raw, 2)), 0x20),\n                    0x20\n                )\n            )\n            let half := div(raw, 2)\n\n            /* second \u201cpanic\u201d branch */\n            if eq(iszero(raw), lt(half, 0x20)) {\n                mstore(0x00, 0x4e487b71)\n                mstore(0x04, 0x22)\n                revert(0x00, 0x24)\n            }\n\n            /* third branch (unreachable in practice, but reproduced) */\n            if iszero(half) {\n                if lt(0x1f, half) {\n                    /* original byte-code tried to read an error selector\n                       from a storage map; here we replace it with a\n                       direct revert to preserve behaviour. */\n                    mstore(0x00, 0x05)\n                    revert(0x00, 0x24)\n                }\n            }\n        }\n\n        /* ------------------------------------------------------------ */\n        /*                ACTUAL SYMBOL EXTRACTION & RETURN             */\n        /* ------------------------------------------------------------ */\n\n        /* If the high bit is set, the string is stored in\u2010place (short\n           string encoding).  Otherwise the slot holds the pointer to the\n           string data (long string encoding). */\n        switch lt(raw, 0x20)\n        /* ============  < 32 bytes  ============ */\n        case 1 {\n            let length := and(raw, 0xff)         // last byte stores length\n            let data := shr(mul(sub(0x20, length), 8), raw)\n\n            /* allocate memory for the ABI-encoded string               */\n            let memPtr := mload(0x40)\n            mstore(0x40, add(memPtr, add(length, 0x40)))\n\n            mstore(memPtr, 0x20)                 // offset to string\n            mstore(add(memPtr, 0x20), length)    // string length\n            mstore(add(memPtr, 0x40), data)      // string bytes\n            return(memPtr, add(length, 0x40))\n        }\n        /* ============  \u2265 32 bytes  ============ */\n        default {\n            /* compute keccak256(slot) to find the starting data slot    */\n            mstore(0x00, SYMBOL_SLOT)\n            let dataSlot := keccak256(0x00, 0x20)\n\n            let length := and(raw, not(sub(shl(1, 255), 1)))  // strip low bit\n\n            /* allocate memory                                            */\n            let memPtr := mload(0x40)\n            let total := add(length, 0x40)\n            mstore(0x40, add(memPtr, total))\n\n            mstore(memPtr, 0x20)                 // offset\n            mstore(add(memPtr, 0x20), length)    // length\n\n            /* copy string data from storage to memory                    */\n            let offset := 0\n            for { } lt(offset, length) { offset := add(offset, 0x20) } {\n                mstore(\n                    add(add(memPtr, 0x40), offset),\n                    sload(add(dataSlot, div(offset, 0x20)))\n                )\n            }\n\n            return(memPtr, total)\n        }\n    }\n}",
    "ground_truth": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }"
}