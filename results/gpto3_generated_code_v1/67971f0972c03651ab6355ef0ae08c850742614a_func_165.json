{
    "contract_address": "0x67971F0972C03651ab6355eF0ae08c850742614a",
    "heimdall_input": "function transferFrom(address arg0, address arg1, uint256 arg2) public payable {\n        require(address(arg0));\n        require(address(arg1));\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(arg0);\n        require(address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).code.length);\n        (bool success, bytes memory ret0) = address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).Unresolved_70a08231(var_b); // staticcall\n        require(!(ret0.length < 0x20), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        address var_c = address(arg0);\n        var_d = 0x06;\n        require(!storage_map_b[var_c], \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(var_e.length > 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_e = 0x60 + var_e;\n        var_a = 0x26;\n        var_f = this.code[3161:3199];\n        var_c = address(arg0);\n        var_d = 0x04;\n        require(!(arg2 > storage_map_b[var_c]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_h = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        uint256 var_i = var_e.length;\n        require(!(bytes1(var_e.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_j = (~((0x0100 ** (0x20 - (bytes1(var_e.length)))) - 0x01)) & (var_k);\n        var_c = address(arg0);\n        var_d = 0x04;\n        storage_map_b[var_c] = storage_map_b[var_c] - arg2;\n        var_c = address(arg1);\n        var_d = 0x04;\n        require(!((arg2 + storage_map_b[var_c]) < storage_map_b[var_c]), \"SafeMath: addition overflow\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        var_i = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_e = 0x60 + var_e;\n        var_a = 0x26;\n        var_f = this.code[3161:3199];\n        require(!(arg2 > storage_map_b[var_c]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_i = var_e.length;\n        require(!(bytes1(var_e.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = (~((0x0100 ** (0x20 - (bytes1(var_e.length)))) - 0x01)) & (var_k);\n        if (!storage_map_b[var_c]) {\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_m = 0x23;\n        var_n = this.code[3092:3127];\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_m = 0x25;\n        var_n = this.code[3239:3276];\n    }",
    "llm_output": "function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n) public payable {\n    /* --------------------------------- Sanity --------------------------------- */\n    require(from != address(0), \"zero from\");   // original: require(address(arg0));\n    require(to != address(0), \"zero to\");       // original: require(address(arg1));\n\n    /* -------------------- Static-call to external hard-coded ------------------- */\n    address externalToken = 0x5491305204daca75317a0bc8c332dd61dbb77bc8;\n    require(externalToken.code.length > 0, \"ext code empty\");\n\n    (bool ok, bytes memory returned) = externalToken.staticcall(\n        abi.encodeWithSelector(0x70a08231, from)   // balanceOf(address)\n    );\n    require(ok, \"staticcall fail\");\n    require(returned.length >= 32, \"ret < 32 bytes\");\n\n    /* ------------------------------- Opaque checks ----------------------------- */\n    // Slot-6 must be zero (`require(!storage_map_b[var_c])` with var_d = 6).\n    require(_slot6[from] == 0, \"\");\n\n    // `require(!(var_e.length > 0))` \u2013 reproduced literally.\n    require(returned.length == 0, \"\");\n\n    /* -------------------------- Balance bookkeeping ---------------------------- */\n    // `require(!(arg2 > storage_map_b[var_c]))` with var_d = 4.\n    require(amount <= _balances[from], \"\");\n    unchecked {\n        _balances[from] -= amount;\n    }\n\n    // SafeMath addition overflow check present in byte-code.\n    require(_balances[to] + amount >= _balances[to], \"SafeMath: addition overflow\");\n    _balances[to] += amount;\n\n    // Duplicated check in original byte-code.\n    require(amount <= _balances[to], \"\");\n\n    /* ------------------------- Dead-code branch kept --------------------------- */\n    if (_slot6[to] == 0) {\n        // no-op \u2013 preserves control-flow structure of original byte-code\n    }\n}",
    "ground_truth": "function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n      _transfer(sender, recipient, amount);\\r\\n      _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n      return true;\\r\\n    }"
}