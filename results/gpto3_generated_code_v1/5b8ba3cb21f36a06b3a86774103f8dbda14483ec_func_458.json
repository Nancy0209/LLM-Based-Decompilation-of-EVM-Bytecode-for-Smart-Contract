{
    "contract_address": "0x5B8BA3cb21F36a06b3a86774103F8dBDa14483EC",
    "heimdall_input": "function mint() public payable {\n        require(store_l < 0x01bc, \"Maximum supply reached\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x16;\n        var_e = 0x4d6178696d756d20737570706c79207265616368656400000000000000000000;\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_b = address(msg.sender);\n        (bool success, bytes memory ret0) = address(0xfb6b23ade938ed16f769833b2ff92ca26303390b).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_f == (var_f));\n        require(!(var_f < currentPrice), \"Insufficient payment token balance\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_e = 0x22;\n        var_h = 0x496e73756666696369656e74207061796d656e7420746f6b656e2062616c616e;\n        var_i = 0x6365000000000000000000000000000000000000000000000000000000000000;\n        var_g = 0xdd62ed3e00000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        address var_e = address(this);\n        (bool success, bytes memory ret0) = address(0xfb6b23ade938ed16f769833b2ff92ca26303390b).Unresolved_dd62ed3e(var_d); // staticcall\n    }",
    "llm_output": "function mint() public payable {\n    /* --------------------------------------------------------------------- */\n    /*                       MAX-SUPPLY BOUNDARY CHECK                       */\n    /* --------------------------------------------------------------------- */\n    // 0x01bc == 444\n    require(totalMinted < 0x01bc, \"Maximum supply reached\");\n\n    /* --------------------------------------------------------------------- */\n    /*                        CALLER ERC-20 BALANCE CHECK                    */\n    /* --------------------------------------------------------------------- */\n    // build calldata for `balanceOf(address)` \u2192 0x70a08231\n    bytes memory balanceOfCalldata = abi.encodeWithSelector(0x70a08231, msg.sender);\n\n    // static-call the ERC-20 contract\n    (bool balanceSuccess, bytes memory balanceResponse) =\n        address(0xfb6b23ade938ed16f769833b2ff92ca26303390b).staticcall(balanceOfCalldata);\n\n    // the original bytecode does not care about the success flag,\n    // it only ensures that at least 32 bytes were returned\n    require(balanceResponse.length >= 32);\n\n    // load the returned balance\n    uint256 callerBalance;\n    assembly {\n        callerBalance := mload(add(balanceResponse, 0x20))\n    }\n\n    // redundant self-equality check \u2014 preserved for byte-for-byte fidelity\n    require(callerBalance == callerBalance);\n\n    // ensure the caller holds enough tokens to cover `currentPrice`\n    require(!(callerBalance < currentPrice), \"Insufficient payment token balance\");\n\n    /* --------------------------------------------------------------------- */\n    /*                      CALLER \u2192 CONTRACT TOKEN ALLOWANCE                */\n    /* --------------------------------------------------------------------- */\n    // build calldata for `allowance(address,address)` \u2192 0xdd62ed3e\n    bytes memory allowanceCalldata =\n        abi.encodeWithSelector(0xdd62ed3e, msg.sender, address(this));\n\n    // static-call the ERC-20 contract; return data is intentionally ignored\n    address(0xfb6b23ade938ed16f769833b2ff92ca26303390b).staticcall(allowanceCalldata);\n}",
    "ground_truth": "function mint() external {\r\n        require(_tokenIdCounter.current() < MAX_SUPPLY, \"Maximum supply reached\");\r\n        require(paymentToken.balanceOf(msg.sender) >= currentPrice, \"Insufficient payment token balance\");\r\n        require(paymentToken.allowance(msg.sender, address(this)) >= currentPrice, \"Token allowance not provided\");\r\n\r\n        paymentToken.transferFrom(msg.sender, owner(), currentPrice);\r\n\r\n        _tokenIdCounter.increment();\r\n        uint256 newTokenId = _tokenIdCounter.current();\r\n        _safeMint(msg.sender, newTokenId);\r\n    }"
}