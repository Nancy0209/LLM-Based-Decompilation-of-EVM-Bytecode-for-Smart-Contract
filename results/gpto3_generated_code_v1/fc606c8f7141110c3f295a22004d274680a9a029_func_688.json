{
    "contract_address": "0xfc606C8F7141110c3f295a22004D274680A9A029",
    "heimdall_input": "function bond(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(store_j - 0x02, \"ReentrancyGuard: reentrant call\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1f;\n        var_d = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n        store_j = 0x02;\n        require(bytes1(canBond), \"Cannot refer to self\");\n        require(!(msg.value < 0x016345785d8a0000), \"Cannot refer to self\");\n        require(address(arg0) - msg.sender, \"Cannot refer to self\");\n        address var_e = msg.sender;\n        var_f = 0x04;\n        uint256 var_g = var_g + 0x60;\n        address var_a = storage_map_k[var_e];\n        address var_h = storage_map_l[var_e];\n        address var_i = address(storage_map_m[var_e]);\n        require(0 - (storage_map_l[var_e]), \"Cannot refer to self\");\n        require(!(var_j > (msg.value + (var_j))), \"Cannot refer to self\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x11;\n        var_g = 0x60 + var_g;\n        uint256 var_l = msg.value;\n        require(!(0x0e10 > (block.timestamp + 0x0e10)), \"Cannot refer to self\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x11;\n        uint256 var_m = block.timestamp + 0x0e10;\n        address var_n = address(arg0);\n        var_e = msg.sender;\n        var_f = 0x04;\n        storage_map_k[var_e] = var_g.length;\n        storage_map_l[var_e] = var_o;\n        storage_map_m[var_e] = (address(var_p)) | (uint96(storage_map_m[var_e]));\n        store_j = 0x01;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x14;\n        var_d = 0x43616e6e6f7420726566657220746f2073656c66000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x13;\n        var_d = 0x4d696e20626f6e6420697320302e312065746800000000000000000000000000;\n    }",
    "llm_output": "function bond(address referrer) public payable {\n    /* -------------------------------------------------------------------------- */\n    /*                              Reentrancy guard                              */\n    /* -------------------------------------------------------------------------- */\n    require(_status != 2, \"ReentrancyGuard: reentrant call\");\n    _status = 2;\n\n    /* -------------------------------------------------------------------------- */\n    /*                             Parameter validation                           */\n    /* -------------------------------------------------------------------------- */\n    require(canBond, \"Cannot refer to self\");                       // bytes1(canBond)\n    require(msg.value >= 0x016345785d8a0000, \"Cannot refer to self\"); // 0.1 ether\n    require(referrer != msg.sender, \"Cannot refer to self\");          // no self-referral\n\n    /* -------------------------------------------------------------------------- */\n    /*                        Checks against existing records                     */\n    /* -------------------------------------------------------------------------- */\n    uint256 existingAmount   = _bondAmount[msg.sender];  // storage_map_k\n    address existingReferrer = _referrer[msg.sender];    // storage_map_l\n\n    /* 0 - storage_map_l[msg.sender] : underflow if existingReferrer != 0x0 */\n    require(existingReferrer == address(0), \"Cannot refer to self\");\n\n    /* !(var_j > (msg.value + var_j)) \u2013 always true but kept for fidelity */\n    require(!(existingAmount > msg.value + existingAmount), \"Cannot refer to self\");\n\n    /* !(0x0e10 > (block.timestamp + 0x0e10)) \u2013 always true but kept for fidelity */\n    require(!(0x0e10 > (block.timestamp + 0x0e10)), \"Cannot refer to self\");\n\n    /* -------------------------------------------------------------------------- */\n    /*                               State updates                                */\n    /* -------------------------------------------------------------------------- */\n    uint256 expiry = block.timestamp + 0x0e10;               // 3600-second lock\n    _bondAmount[msg.sender] = msg.value;                     // storage_map_k\n    _referrer[msg.sender]   = referrer;                      // storage_map_l\n    _packedBondInfo[msg.sender] =\n        uint256(uint160(referrer)) | uint256(uint96(expiry)); // storage_map_m\n\n    /* -------------------------------------------------------------------------- */\n    /*                              Reset guard flag                              */\n    /* -------------------------------------------------------------------------- */\n    _status = 1;\n}",
    "ground_truth": "function bond(address ref) public payable nonReentrant {\r\n        require(canBond);\r\n        require(msg.value >= 0.1 ether, \"Min bond is 0.1 eth\");\r\n        require(ref != msg.sender, \"Cannot refer to self\");\r\n        BondEntry memory currentBond = bonds[msg.sender];\r\n        if(currentBond.withdrawTime == 0) {\r\n            BondEntry memory b = BondEntry(\r\n                msg.value,\r\n                block.timestamp + 1 hours,\r\n                ref\r\n            );\r\n            bonds[msg.sender] = b;\r\n        } else {\r\n            currentBond.ethAmount += msg.value;\r\n            currentBond.withdrawTime = block.timestamp + 1 hours;\r\n            currentBond.referrer = ref;\r\n        }\r\n        \r\n    }"
}