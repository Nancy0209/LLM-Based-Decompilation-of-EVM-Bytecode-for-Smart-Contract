{
    "contract_address": "0x6ddfeC08B7597e9392abbC41CB8a74A0d59188C1",
    "heimdall_input": "function getBaseTokenReserve(address arg0) public returns (uint112) {\n        require(arg0 == (address(arg0)));\n        var_a = 0x0902f1ac00000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_h / 0x01).getReserves(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x60);\n        require(var_c.length == (uint112(var_c.length)));\n        require(var_d == (uint112(var_d)));\n        require(var_e == (uint32(var_e)));\n        var_f = 0x0dfe168100000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_h / 0x01).token0(var_g); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_c.length == (address(var_c.length)));\n        require(address(var_c.length) == (address(arg0)));\n        uint112 var_h = uint112(var_d);\n        return uint112(var_d);\n        var_h = uint112(var_c.length);\n        return uint112(var_c.length);\n    }",
    "llm_output": "function getBaseTokenReserve(address baseToken) public view returns (uint112) {\n    // Redundant self-check preserved from decompiled logic\n    require(baseToken == address(baseToken), \"Self-address check failed\");\n\n    // ---------------------------------------------------------------------\n    // 1.  getReserves() call\n    // ---------------------------------------------------------------------\n    (bool /*success*/, bytes memory reservesData) =\n        liquidityPool.staticcall(abi.encodeWithSelector(0x0902f1ac)); // getReserves()\n    require(reservesData.length >= 96, \"Bad getReserves response\");\n\n    (uint112 reserve0, /*uint112 reserve1*/, uint32 blockTimestampLast) =\n        abi.decode(reservesData, (uint112, uint112, uint32));\n\n    // Overflow/size checks mirrored from decompiled code\n    require(reserve0 == uint112(reserve0), \"reserve0 overflow check\");\n    require(blockTimestampLast == uint32(blockTimestampLast), \"timestamp overflow check\");\n\n    // ---------------------------------------------------------------------\n    // 2.  token0() call\n    // ---------------------------------------------------------------------\n    (/*bool success*/, bytes memory token0Data) =\n        liquidityPool.staticcall(abi.encodeWithSelector(0x0dfe1681)); // token0()\n    require(token0Data.length >= 32, \"Bad token0 response\");\n\n    address token0 = abi.decode(token0Data, (address));\n\n    // Enforce that the supplied token is token0; this matches the original\n    require(token0 == baseToken, \"token0 mismatch\");\n\n    // Since token0 matches the supplied token, return reserve0\n    return reserve0;\n}",
    "ground_truth": "function getBaseTokenReserve(address token) public view returns (uint256) {\r\n        (uint112 reserve0, uint112 reserve1,) = _pair.getReserves();\r\n        uint256 baseTokenReserve = (_pair.token0() == token) ? uint256(reserve0) : uint256(reserve1);\r\n        return baseTokenReserve;\r\n    }"
}