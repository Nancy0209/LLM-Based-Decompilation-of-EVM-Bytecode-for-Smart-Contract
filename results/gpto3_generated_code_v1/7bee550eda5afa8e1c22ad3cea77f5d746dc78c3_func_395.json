{
    "contract_address": "0x7BEe550EDa5afA8E1C22Ad3Cea77f5D746dC78c3",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        var_b = 0x04;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        if (!(storage_map_b[var_a] - arg1) > storage_map_b[var_a]) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            var_a = address(msg.sender);\n            var_b = 0x04;\n            storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n            require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"ERC20: transfer to the zero address\");\n            var_a = address(msg.sender);\n            var_b = 0x02;\n            require(tx.origin == (address(arg0)), \"ERC20: transfer to the zero address\");\n            require(!(!0x01 == (bytes1(storage_map_b[var_a]))), \"ERC20: transfer to the zero address\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            require((0 == ((0 * arg1) / arg1)) | !arg1, \"ERC20: transfer to the zero address\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x12;\n            require(0x64, \"ERC20: transfer to the zero address\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            require(!(0 > (((0 * arg1) / 0x64) + 0)), \"ERC20: transfer to the zero address\");\n            var_a = address(store_d);\n            var_b = 0x04;\n            require(!(((0 * arg1) / 0x64) + 0), \"ERC20: transfer to the zero address\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            require(!(storage_map_b[var_a] > ((((0 * arg1) / 0x64) + 0) + storage_map_b[var_a])), \"ERC20: transfer to the zero address\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            require(!((arg1 - (((0 * arg1) / 0x64) + 0)) > arg1), \"ERC20: transfer to the zero address\");\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transfer(address recipient, uint256 amount) public payable {\n    /*\n     * NOTE\n     * ----\n     * The original, de-compiled byte-code is heavily corrupted.  Numerous\n     * operations either always evaluate to `true`/`false` or rely on type\n     * conversions that are illegal in Solidity source.  \n     *\n     * Where an expression in the raw output would have produced an\n     * unconditional revert at run-time (e.g. `require(false)` or\n     * invalid boolean/bytes comparisons), it is replaced by  \n     * `revert(\"Decompiler artifact\")` in accordance with the\n     * specification for \u201cbroken logic\u201d.\n     */\n\n    /* ------------- Solidity-legal transcription of the raw checks ------------- */\n\n    /* Trivial identity check (always true) */\n    require(recipient == address(recipient));\n\n    /* These two checks correspond to `require(address(msg.sender))`\n       and `require(address(arg0))` in the de-compiled listing.        */\n    require(msg.sender != address(0), \"ERC20: transfer amount exceeds balance\");\n    require(recipient  != address(0), \"ERC20: transfer amount exceeds balance\");\n\n    /* `storage_map_b`  \u2192 `_balances`                                          */\n    address  sender  = msg.sender;\n    uint256  _dummy1 = 0x04;          // `var_b` \u2013 value is unused but kept\n\n    require(!(_balances[sender] < amount),\n            \"ERC20: transfer amount exceeds balance\");\n\n    /* ------------------------------------------------------------------------- */\n    /*            The large, de-compiled branch with multiple checks             */\n    /* ------------------------------------------------------------------------- */\n    if (!((_balances[sender] - amount) > _balances[sender])) {\n\n        /* Ghost variables that have no real effect but are preserved. */\n        address  _ghostAddr  = 0x4e487b7100000000000000000000000000000000;\n        uint256  _ghostConst = 0x11;\n\n        /* Balance mutation mirrored from the raw listing. */\n        _balances[sender] = _balances[sender] - amount;\n\n        require(!((_balances[sender] - amount) > _balances[sender]),\n                \"ERC20: transfer to the zero address\");\n\n        _dummy1 = 0x02;                       // `var_b` reassignment\n\n        require(tx.origin == recipient,\n                \"ERC20: transfer to the zero address\");\n\n        /*\n         * The next instruction in the de-compiled code is:\n         *     require(!(!0x01 == bytes1(storage_map_b[var_a])),\n         *             \"ERC20: transfer to the zero address\");\n         *\n         * This is syntactically impossible in Solidity source and, when\n         * emulated at the EVM level, would *always* revert.  It is therefore\n         * replaced with an explicit revert carrying a fixed reason-string.\n         */\n        revert(\"Decompiler artifact\");\n    }\n\n    /*\n     * The tail of the original de-compiled output consists solely of\n     * additional `revert` payload data that is never reached in practice.\n     * To preserve the observable behaviour we issue the same revert here.\n     */\n    revert(\"ERC20: transfer to the zero address\");\n}",
    "ground_truth": "function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}"
}