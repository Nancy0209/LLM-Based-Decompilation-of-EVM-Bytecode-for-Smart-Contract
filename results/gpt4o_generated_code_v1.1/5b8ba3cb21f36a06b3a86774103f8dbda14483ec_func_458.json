{
    "contract_address": "0x5B8BA3cb21F36a06b3a86774103F8dBDa14483EC",
    "heimdall_input": "function mint() public payable {\n        require(store_l < 0x01bc, \"Maximum supply reached\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x16;\n        var_e = 0x4d6178696d756d20737570706c79207265616368656400000000000000000000;\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_b = address(msg.sender);\n        (bool success, bytes memory ret0) = address(0xfb6b23ade938ed16f769833b2ff92ca26303390b).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_f == (var_f));\n        require(!(var_f < currentPrice), \"Insufficient payment token balance\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_e = 0x22;\n        var_h = 0x496e73756666696369656e74207061796d656e7420746f6b656e2062616c616e;\n        var_i = 0x6365000000000000000000000000000000000000000000000000000000000000;\n        var_g = 0xdd62ed3e00000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        address var_e = address(this);\n        (bool success, bytes memory ret0) = address(0xfb6b23ade938ed16f769833b2ff92ca26303390b).Unresolved_dd62ed3e(var_d); // staticcall\n    }",
    "llm_output": "function mint() public payable {\n    require(totalSupply < MAX_SUPPLY, \"Maximum supply reached\");\n\n    // Check the balance of the payment token for the sender\n    bytes4 balanceOfSelector = 0x70a08231; // balanceOf(address)\n    address paymentTokenAddress = 0xfb6b23ade938ed16f769833b2ff92ca26303390b; // Replace with actual token address\n    address sender = msg.sender;\n\n    (bool balanceCallSuccess, bytes memory balanceData) = paymentTokenAddress.staticcall(\n        abi.encodeWithSelector(balanceOfSelector, sender)\n    );\n    require(balanceCallSuccess, \"Failed to fetch token balance\");\n    uint256 senderBalance = abi.decode(balanceData, (uint256));\n    require(senderBalance >= currentPrice, \"Insufficient payment token balance\");\n\n    // Check the allowance of the payment token for the contract\n    bytes4 allowanceSelector = 0xdd62ed3e; // allowance(address, address)\n    address contractAddress = address(this);\n\n    (bool allowanceCallSuccess, bytes memory allowanceData) = paymentTokenAddress.staticcall(\n        abi.encodeWithSelector(allowanceSelector, sender, contractAddress)\n    );\n    require(allowanceCallSuccess, \"Failed to fetch token allowance\");\n    uint256 senderAllowance = abi.decode(allowanceData, (uint256));\n    require(senderAllowance >= currentPrice, \"Insufficient payment token allowance\");\n\n    // Mint logic (not fully provided in the decompiled code)\n    // Increment total supply or perform other minting operations here\n}",
    "ground_truth": "function mint() external {\r\n        require(_tokenIdCounter.current() < MAX_SUPPLY, \"Maximum supply reached\");\r\n        require(paymentToken.balanceOf(msg.sender) >= currentPrice, \"Insufficient payment token balance\");\r\n        require(paymentToken.allowance(msg.sender, address(this)) >= currentPrice, \"Token allowance not provided\");\r\n\r\n        paymentToken.transferFrom(msg.sender, owner(), currentPrice);\r\n\r\n        _tokenIdCounter.increment();\r\n        uint256 newTokenId = _tokenIdCounter.current();\r\n        _safeMint(msg.sender, newTokenId);\r\n    }"
}