{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function burn(uint256 arg0) public {\n        address var_a = msg.sender;\n        var_b = 0x68;\n        require(storage_map_b[var_a], CustomError_df2d9b42());\n        require(storage_map_b[var_a], CustomError_df2d9b42());\n        require(0x01 > arg0, CustomError_df2d9b42());\n        var_a = arg0;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(0 - storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = arg0;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c46;\n        require(!0x01);\n        require(!storage_map_b[var_a]);\n        storage_map_b[var_a] = 0;\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c45;\n        storage_map_b[var_a] = storage_map_b[var_a] + 0xffffffffffffffffffffffffffffffff;\n        var_a = arg0;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        storage_map_b[var_a] = (address(storage_map_b[var_a])) | ((block.timestamp << 0xa0) | 0x0300000000000000000000000000000000000000000000000000000000);\n        require(0 - (bytes1(storage_map_b[var_a])));\n        var_a = this.code[13919:13951];\n        var_a = var_a;\n        emit Transfer(address(storage_map_b[var_a]), 0, arg0);\n        store_g = 0x01 + store_g;\n        var_a = 0x03;\n        var_b = 0x69;\n        var_a = this.code[13887:13919];\n        var_a = var_a;\n        require(!store_i);\n        var_a = 0x03;\n        var_b = 0x69;\n        var_a = this.code[13887:13919];\n        var_a = var_a;\n        require(store_i);\n        var_a = var_a;\n        require(address(storage_map_j[var_a]) == 0);\n        var_a = 0x03;\n        var_b = 0x69;\n        var_a = this.code[13887:13919];\n        var_a = var_a;\n        require(store_i);\n        var_a = var_a;\n        var_c = 0xb68c437900000000000000000000000000000000000000000000000000000000;\n        address var_d = address(msg.sender);\n        uint256 var_e = 0;\n        uint256 var_f = arg0;\n        require(0x03 < 0x05);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x21;\n        var_h = 0x03;\n        require(address(storage_map_j[var_a]).code.length);\n        (bool success, bytes memory ret0) = address(storage_map_j[var_a]).{ value: var_e ether }Unresolved_b68c4379(var_d); // call\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_a = var_f + 0x01;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        if (0 - storage_map_b[var_a]) {\n            require(0 - storage_map_b[var_a], CustomError_59c896be());\n        }\n        require(storage_map_b[var_a] == (address(msg.sender)) | (address(msg.sender) == (address(storage_map_b[var_a]))), CustomError_59c896be());\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c47;\n        var_a = address(msg.sender);\n        address var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), CustomError_59c896be());\n        var_a = 0x59c896be00000000000000000000000000000000000000000000000000000000;\n        require(arg0 < totalSupply, CustomError_df2d9b42());\n        var_a = var_f + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = (arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = ((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = (((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x436f6e7472616374206973206e6f742072656769737465726564206e6f72204f;\n        var_h = 0x776e657200000000000000000000000000000000000000000000000000000000;\n        require(address(owner) == msg.sender, \"Contract is not registered nor Owner\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x436f6e7472616374206973206e6f742072656769737465726564206e6f72204f;\n        var_h = 0x776e657200000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function burn(uint256 tokenId) public {\n    address caller = msg.sender;\n\n    // Ensure the caller is authorized to burn tokens\n    if (!authorizedAddresses[caller]) {\n        revert(\"CallerNotAuthorized\");\n    }\n\n    // Ensure the tokenId is valid\n    if (tokenId >= totalSupply) {\n        revert(\"InvalidTokenId\");\n    }\n\n    // Retrieve ownership data for the token\n    TokenOwnership memory ownership = tokenOwnerships[tokenId];\n\n    // Ensure the token is not already burned\n    if (ownership.burned) {\n        revert(\"TokenAlreadyBurned\");\n    }\n\n    // Ensure the caller is the owner of the token\n    if (ownership.addr != caller) {\n        revert(\"CallerNotTokenOwner\");\n    }\n\n    // Mark the token as burned\n    ownership.burned = true;\n    ownership.addr = address(0);\n    ownership.startTimestamp = uint64(block.timestamp);\n\n    // Update the token ownership mapping\n    tokenOwnerships[tokenId] = ownership;\n\n    // Decrease the balance of the token owner\n    balances[caller] -= 1;\n\n    // Emit the Transfer event to indicate the token was burned\n    emit Transfer(caller, address(0), tokenId);\n\n    // Update the total supply of tokens\n    totalSupply -= 1;\n}",
    "ground_truth": "function burn(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/IERC721AQueryableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721AUpgradeable.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryableUpgradeable is IERC721AUpgradeable {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    }"
}