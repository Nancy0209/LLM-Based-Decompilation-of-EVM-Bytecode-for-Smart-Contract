{
    "contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421",
    "heimdall_input": "function pendingRewards(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x03;\n        require(!0 < storage_map_k[var_a]);\n        var_a = address(arg0);\n        var_b = 0x04;\n        require(0 < storage_map_k[var_a]);\n        var_a = keccak256(var_a);\n        require(!(storage_map_n[var_a]) & (time > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / (storage_map_n[var_a]))));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(arg0);\n        var_b = 0x05;\n        require(0 < storage_map_k[var_a]);\n        var_a = keccak256(var_a);\n        require(!(storage_map_n[var_a]) > (~(storage_map_n[var_a] * time)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!block.timestamp > (storage_map_n[var_a] + (storage_map_n[var_a] * time)));\n        require(!0 == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(arg0);\n        var_b = 0x03;\n        require(0 < storage_map_k[var_a]);\n        var_a = keccak256(var_a);\n        var_a = address(arg0);\n        var_b = 0x04;\n        require(0 < storage_map_k[var_a]);\n        var_a = keccak256(var_a);\n        var_a = storage_map_n[var_a];\n        var_b = 0x02;\n        require(storage_map_k[var_a]);\n        require(!(storage_map_k[var_a]) & (storage_map_n[var_a] > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / storage_map_k[var_a])));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(storage_map_k[var_a]);\n        require(storage_map_k[var_a] * (storage_map_n[var_a]) / storage_map_k[var_a] == (storage_map_n[var_a]));\n        require(0x64 > 0);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        uint256 var_d = 0;\n        return 0;\n    }",
    "llm_output": "function pendingRewards(address userAddress) public view returns (uint256) {\n    require(userAddress == address(userAddress), \"Invalid address\");\n\n    uint256 reward = 0;\n\n    // Check if the user has deposited tokens\n    require(Users[userAddress].DepositeToken > 0, \"No deposit found\");\n\n    // Calculate pending rewards\n    uint256 depositTime = Users[userAddress].depositeTime;\n    uint256 lockableDays = Users[userAddress].lockableDays;\n    uint256 lastUpdated = Users[userAddress].lastUpdated;\n\n    require(depositTime > 0, \"Invalid deposit time\");\n    require(lockableDays > 0, \"Invalid lockable days\");\n\n    uint256 elapsedTime = block.timestamp - depositTime;\n    require(elapsedTime > 0, \"Elapsed time must be greater than zero\");\n\n    uint256 rewardRate = allocation[lockableDays];\n    require(rewardRate > 0, \"Invalid reward rate\");\n\n    uint256 calculatedReward = (Users[userAddress].DepositeToken * rewardRate * elapsedTime) / time;\n    require(calculatedReward >= reward, \"Reward calculation error\");\n\n    reward = calculatedReward;\n\n    return reward;\n}",
    "ground_truth": "function pendingRewards(address _add) public view returns(uint256 reward)\r\n    {\r\n        uint256 Reward;\r\n        for(uint256 z=0 ; z< depositeToken[_add].length;z++){\r\n        uint256 lockTime = depositetime[_add][z]+(lockabledays[_add][z]*time);\r\n        if(block.timestamp > lockTime ){\r\n        reward = (allocation[lockabledays[_add][z]].mul(depositeToken[_add][z]).div(100)).div(1e18);\r\n        Reward += reward;\r\n        }\r\n    }\r\n    return Reward;\r\n    }"
}