{
    "contract_address": "0xBA9eADD511A94e86DfDE1EC0c4DaBe1CC59529BA",
    "heimdall_input": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                uint256 var_a = 0;\n                                uint256 var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "llm_output": "function name() public view returns (string memory) {\n    if (nameStorage) {\n        if (nameStorage - ((nameStorage >> 1) < 32)) {\n            uint256 errorCode = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            uint256 errorOffset = 34;\n            uint256 offset = offset + (32 + (((31 + (nameStorage >> 1)) / 32) * 32));\n            bytes32 nameData = nameStorage >> 1;\n            if (nameStorage) {\n                if (nameStorage - ((nameStorage >> 1) < 32)) {\n                    errorCode = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    errorOffset = 34;\n                    if (!(nameStorage >> 1)) {\n                        if (31 < (nameStorage >> 1)) {\n                            uint256 index = 0;\n                            uint256 data = nameStorageMap[index];\n                            if ((32 + offset) + (nameStorage >> 1) > (32 + (32 + offset))) {\n                                data = 32;\n                                uint256 length = offset.length;\n                                uint256 start = 0;\n                                return abi.encodePacked(32, offset.length);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
    "ground_truth": "function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"\r\n    }"
}