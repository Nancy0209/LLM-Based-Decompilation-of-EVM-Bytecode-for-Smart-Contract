{
    "contract_address": "0x9361CD557C1db79830F118364E5009B3A2738fD3",
    "heimdall_input": "function withdrawEarnings() public view {\n        address var_a = address(msg.sender);\n        var_b = 0x0f;\n        require(!storage_map_a[var_a] > block.timestamp);\n        require(0x3c > 0);\n        require(0x3c);\n        var_a = address(msg.sender);\n        var_b = 0x0b;\n        require(storage_map_a[var_a] == 0);\n        require(storage_map_a[var_a]);\n        require((storage_map_a[var_a] * dailyROI) / storage_map_a[var_a] == dailyROI);\n    }",
    "llm_output": "function withdrawEarnings() external returns (bool success) {\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function withdrawEarnings() external returns (bool success) {\r\n        uint totalReward = (referralRewards[msg.sender]).add(stakeRewards[msg.sender]).add(calculateEarnings(msg.sender));\r\n        require(totalReward > 0, 'No reward to withdraw');\r\n        require(block.timestamp > lockTime[msg.sender], \"lock time has not expired\"); \r\n        require((IERC20(momo_tokenV2).balanceOf(address(this))).sub(totalStaked) >= totalReward, 'Insufficient  balance in pool');\r\n        stakeRewards[msg.sender] = 0;\r\n        referralRewards[msg.sender] = 0;\r\n        referralCount[msg.sender] = 0;\r\n        uint remainder = (now.sub(lastClock[msg.sender])).mod(60);\r\n        lastClock[msg.sender] = now.sub(remainder);\r\n        IERC20(momo_tokenV2).transfer(msg.sender, totalReward);\r\n        emit OnWithdrawal(msg.sender, totalReward);\r\n        return true;\r\n    }"
}