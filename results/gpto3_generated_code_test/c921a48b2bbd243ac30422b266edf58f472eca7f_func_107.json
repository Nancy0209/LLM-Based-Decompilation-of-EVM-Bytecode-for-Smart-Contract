{
    "contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F",
    "heimdall_input": "function rescueERC20(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(store_m);\n        uint256 var_c = arg1;\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_a9059cbb(var_b); // call\n        uint256 var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!((var_d + ret0.length) - var_d) < 0x20);\n        require(var_d.length == var_d.length);\n    }",
    "llm_output": "function rescueERC20(address tokenAddress, uint256 amount) public {\n    // Redundant check kept to preserve original logic\n    require(tokenAddress == address(tokenAddress));\n\n    // transfer(address,uint256) selector\n    bytes4 selector = 0xa9059cbb;\n\n    // Perform low-level call to the token contract\n    (bool success, bytes memory returnData) =\n        tokenAddress.call(abi.encodeWithSelector(selector, msg.sender, amount));\n\n    // Obscure return-data size checks preserved from decompiled logic\n    uint256 temp = returnData.length + 0x1f;\n    uint256 check = temp + returnData.length;\n    require(!((check - temp) < 0x20));\n    require(returnData.length == returnData.length);\n\n    // Silence compiler warning about unused variable\n    success;\n}",
    "ground_truth": "function rescueERC20(address tokenAdd, uint256 amount) external {\\r\\n        IERC20(tokenAdd).transfer(devWallet, amount);\\r\\n    }"
}