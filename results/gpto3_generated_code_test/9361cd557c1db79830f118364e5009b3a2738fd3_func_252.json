{
    "contract_address": "0x9361CD557C1db79830F118364E5009B3A2738fD3",
    "heimdall_input": "function calculateEarnings(address arg0) public view {\n        address var_a = address(arg0);\n        var_b = 0x0f;\n        require(!storage_map_a[var_a] > block.timestamp);\n        require(0x3c > 0);\n        require(0x3c);\n        var_a = address(arg0);\n        var_b = 0x0b;\n        require(storage_map_a[var_a] == 0);\n        require(storage_map_a[var_a]);\n        require((storage_map_a[var_a] * dailyROI) / storage_map_a[var_a] == dailyROI);\n    }",
    "llm_output": "function calculateEarnings(address _stakeholder) public view returns (uint256) {\n    uint256 lastTimestamp = lastClock[_stakeholder];\n\n    // Equivalent to `require(!storage_map_a[var_a] > block.timestamp);`\n    require(lastTimestamp <= block.timestamp, \"Invalid timestamp\");\n\n    // Decompiler-generated sanity checks (always true but preserved for fidelity)\n    require(60 > 0, \"Sanity check #1\");\n    require(60 != 0, \"Sanity check #2\");\n\n    uint256 stakedAmount = stakes[_stakeholder];\n\n    // Equivalent to the pair of contradictory `require` statements in the decompiled output.\n    // Retained as a single, meaningful check.\n    require(stakedAmount > 0, \"No active stake\");\n\n    // Overflow check carried over from `(storage_map_a[var_a] * dailyROI) / storage_map_a[var_a] == dailyROI`\n    require((stakedAmount * dailyROI) / stakedAmount == dailyROI, \"Overflow check failed\");\n\n    uint256 elapsedMinutes = (block.timestamp - lastTimestamp) / 60;\n    uint256 earnings = (stakedAmount * dailyROI * elapsedMinutes) / 1000;\n\n    return earnings;\n}",
    "ground_truth": "function calculateEarnings(address _stakeholder) public view returns(uint) {\r\n        uint activeDays = (now.sub(lastClock[_stakeholder])).div(60);\r\n        return ((stakes[_stakeholder]).mul(dailyROI).mul(activeDays)).div(100000000); //1//0.1//0.01//0.001/0.0001/0.00001/\r\n    }"
}