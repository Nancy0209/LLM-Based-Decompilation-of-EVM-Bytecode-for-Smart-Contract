{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function addBypassRule(address arg0, bytes4 arg1, uint256 arg2) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == (uint32(arg1)));\n        require(!(bytes1(isClaimable / 0x0100)), \"Not owner or able to bypass\");\n        address var_a = msg.sender;\n        var_b = 0x66;\n        var_a = uint32(msg.data[0]);\n        address var_b = keccak256(var_a);\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(bytes1(storage_map_b[var_a]), \"Not owner or able to bypass\");\n        var_a = address(arg0);\n        var_b = 0x66;\n        var_a = uint32(arg1);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        require(!arg2, \"Not owner or able to bypass\");\n        var_a = address(arg0);\n        var_b = 0x67;\n        var_a = arg2;\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        var_a = address(arg0);\n        var_b = 0x66;\n        var_a = uint32(arg1);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        require(!arg2);\n        var_a = address(arg0);\n        var_b = 0x67;\n        var_a = arg2;\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n    }",
    "llm_output": "function addBypassRule(address target, bytes4 functionSig, uint256 id) public {\n    /* --------------------------------------------------------------------- */\n    /*  Sanity checks reproduced exactly as in the original byte-code        */\n    /* --------------------------------------------------------------------- */\n    require(target == address(target));                           // always true\n    require(functionSig == bytes4(uint32(functionSig)));          // always true\n\n    /* --------------------------------------------------------------------- */\n    /*  Original gate that looks at a specific flag inside `isClaimable`     */\n    /* --------------------------------------------------------------------- */\n    require(\n        bytes1(uint8(isClaimable >> 8)) == 0x00,                  // !(bytes1(isClaimable / 0x0100))\n        \"Not owner or able to bypass\"\n    );\n\n    /* --------------------------------------------------------------------- */\n    /*  Owner-only access check and secondary \u201cbypass\u201d flag check            */\n    /* --------------------------------------------------------------------- */\n    bytes32 callerSelectorKey;\n    assembly {\n        /* selector := first 4 bytes of calldata */\n        let selector := and(calldataload(0), 0xffffffff)\n        mstore(0x00, selector)\n        mstore(0x20, 0x66)                                        // outer mapping slot\n        callerSelectorKey := keccak256(0x00, 0x40)\n    }\n\n    require(owner == msg.sender, \"Not owner or able to bypass\");\n    require(bytes1(_bypassFlags[callerSelectorKey]) != 0x00, \"Not owner or able to bypass\");\n\n    /* --------------------------------------------------------------------- */\n    /*  Set bypass rule for (target, functionSig) \u2013 slot 0x66               */\n    /* --------------------------------------------------------------------- */\n    bytes32 functionKey;\n    assembly {\n        mstore(0x00, functionSig)\n        mstore(0x20, 0x66)\n        functionKey := keccak256(0x00, 0x40)\n    }\n    _bypassFlags[functionKey] = _bypassFlags[functionKey] | uint256(1);\n\n    /* --------------------------------------------------------------------- */\n    /*  The original code insists that `id` MUST be zero                     */\n    /* --------------------------------------------------------------------- */\n    require(id == 0, \"Not owner or able to bypass\");\n\n    /* --------------------------------------------------------------------- */\n    /*  Set bypass rule for (target, id) \u2013 slot 0x67                         */\n    /* --------------------------------------------------------------------- */\n    bytes32 idKey;\n    assembly {\n        mstore(0x00, id)\n        mstore(0x20, 0x67)\n        idKey := keccak256(0x00, 0x40)\n    }\n    _bypassFlags[idKey] = _bypassFlags[idKey] | uint256(1);\n\n    /* --------------------------------------------------------------------- */\n    /*  Redundant owner checks preserved for bytecode parity                 */\n    /* --------------------------------------------------------------------- */\n    require(owner == msg.sender, \"Not owner or able to bypass\");\n    require(owner == msg.sender, \"Not owner or able to bypass\");\n    require(owner == msg.sender, \"Not owner or able to bypass\");\n\n    /* --------------------------------------------------------------------- */\n    /*  Duplicate writes exactly as they appear in the decompiled output     */\n    /* --------------------------------------------------------------------- */\n    _bypassFlags[functionKey] = _bypassFlags[functionKey] | uint256(1);\n    require(id == 0, \"Not owner or able to bypass\");\n    _bypassFlags[idKey] = _bypassFlags[idKey] | uint256(1);\n}",
    "ground_truth": "function addBypassRule(address who, bytes4 functionSig, uint256 id) public onlyOwner {\\n        byPassableFunction[who][functionSig] = true;\\n        if (id != 0) {\\n            byPassableIds[who][id] = true;\\n        }        \\n    }"
}