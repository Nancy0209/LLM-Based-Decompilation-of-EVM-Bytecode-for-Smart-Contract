{
    "contract_address": "0xfC37E6b475e0522fc5B8FBc319dB80a4555B5AeD",
    "heimdall_input": "function buyTicket(uint256 arg0, uint256 arg1) public payable {\n        require(arg1 < store_e);\n        var_a = 0x0b;\n        require((bytes1(lotteryStatus)) == 0x01);\n        var_b = 0xdd62ed3e00000000000000000000000000000000000000000000000000000000;\n        address var_c = msg.sender;\n        address var_d = address(this);\n        (bool success, bytes memory ret0) = address(storage_map_v[arg1 * 0x02]).Unresolved_dd62ed3e(var_c); // staticcall\n        uint256 var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        allow = var_e.length;\n        require((arg0 == ((arg0 * (storage_map_x[(arg1 * 0x02) + keccak256(var_a)])) / (storage_map_x[(arg1 * 0x02) + keccak256(var_a)]))) | (!storage_map_x[(arg1 * 0x02) + keccak256(var_a)]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_g = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        var_d = address(msg.sender);\n        address var_h = address(this);\n        uint256 var_i = arg0 * (storage_map_x[(arg1 * 0x02) + keccak256(var_a)]);\n        (bool success, bytes memory ret0) = address(storage_map_v[arg1 * 0x02]).{ value: 0 ether }Unresolved_23b872dd(var_d); // call\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        require(var_e.length == var_e.length);\n        address var_a = msg.sender;\n        var_j = 0x01;\n        require(!storage_map_y[var_a] > (arg0 + storage_map_y[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x16;\n        var_h = 0x4c6f7474657279206973206e6f742072756e6e696e6700000000000000000000;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n    }",
    "llm_output": "function buyTicket(uint256 numberOfTickets, uint256 _pid) external payable {\n    /* --------------------------------- Validations --------------------------------- */\n    // `_pid` must be a valid index within the `allowedCrypto` array\n    require(_pid < allowedCrypto.length, \"Invalid currency id\");\n\n    // The lottery must be running\n    require(lotteryStatus, \"Lottery not running\");\n\n    /* --------------------------- Fetch token/cost details --------------------------- */\n    IERC20 paymentToken   = allowedCrypto[_pid].paytoken;\n    uint256 costPerTicket = allowedCrypto[_pid].costvalue;\n\n    /* ---------------------------- Overflow-safe math check --------------------------- */\n    // (numberOfTickets * costPerTicket) / costPerTicket == numberOfTickets  \u21e2  no overflow\n    require(\n        costPerTicket == 0 || (numberOfTickets * costPerTicket) / costPerTicket == numberOfTickets,\n        \"Mul overflow\"\n    );\n\n    uint256 totalCost = numberOfTickets * costPerTicket;\n\n    /* ------------------------------- Allowance & pull ------------------------------- */\n    require(\n        paymentToken.allowance(msg.sender, address(this)) >= totalCost,\n        \"Insufficient allowance\"\n    );\n\n    bool transferOk = paymentToken.transferFrom(msg.sender, address(this), totalCost);\n    require(transferOk, \"Transfer failed\");\n\n    /* ------------------------------ State bookkeeping ------------------------------- */\n    // Overflow-safe addition (original bytecode check)\n    require(\n        entryCounts[msg.sender] + numberOfTickets >= entryCounts[msg.sender],\n        \"Add overflow\"\n    );\n\n    entryCounts[msg.sender] += numberOfTickets;\n    totalEntries          += numberOfTickets;\n\n    for (uint256 i = 0; i < numberOfTickets; ++i) {\n        players.push(msg.sender);\n    }\n\n    emit NewTicketBought(msg.sender);\n}",
    "ground_truth": "function buyTicket(uint256 numberOfTickets, uint256 _pid) public payable {\\n        TokenInfo storage tokens = AllowedCrypto[_pid];\\n        IERC20 paytoken;\\n        paytoken = tokens.paytoken;\\n        uint256 cost;\\n        cost = tokens.costvalue;\\n        \\n        require(lotteryStatus == true, \\\"Lottery is not running\\\"); //Lottery must be running\\n        allow = paytoken.allowance(msg.sender, address(this));\\n        paytoken.transferFrom(msg.sender,address(this), cost * numberOfTickets);\\n        entryCounts[msg.sender] += numberOfTickets;\\n        totalEntries += numberOfTickets;\\n        \\n\\n        if (!isPlayer(msg.sender)) {\\n            players.push(msg.sender); //Add the player to the players array\\n        }\\n        \\n        for (uint256 i = 0; i < numberOfTickets; i++) {\\n            playerSelector.push(msg.sender); //Add the player to the playerSelector array\\n        }\\n\\n        emit NewTicketBought(msg.sender); //Emit the event that a new ticket was bought\\n    }"
}