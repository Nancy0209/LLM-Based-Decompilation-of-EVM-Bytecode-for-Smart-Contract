{
    "contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b",
    "heimdall_input": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(0x01 > arg1, CustomError_df2d9b42());\n        require(!(arg1 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x04;\n        require(bytes1(storage_map_n[var_a]), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(storage_map_n[var_a], CustomError_cfb3b942());\n        require(address(storage_map_n[var_a]) == msg.sender, CustomError_cfb3b942());\n        var_a = address(storage_map_n[var_a]);\n        var_b = 0x07;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_n[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_c = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1;\n        var_b = 0x04;\n        if (storage_map_n[var_a]) {\n            var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1);\n            var_b = 0x04;\n            if (storage_map_n[var_a]) {\n                var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1));\n                var_b = 0x04;\n                if (storage_map_n[var_a]) {\n                }\n            }\n        }\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function approve(address to, uint256 tokenId) public payable {\n    // These first two requirements are retained verbatim from the decompiled byte-code\n    // (note that `to == address(to)` is always true but must stay for logical fidelity)\n    require(to == address(to));\n    require(0x01 > tokenId, CustomError_df2d9b42());\n\n    // Original logic: require(!(tokenId < totalSupply))\n    require(!(tokenId < totalSupply), CustomError_df2d9b42());\n\n    // Verify packed ownership data at `tokenId` exists\n    require(\n        bytes1(bytes32(storage_map_n[tokenId])) != bytes1(0),\n        CustomError_df2d9b42()\n    );\n\n    // Caller must own the token\n    require(storage_map_n[tokenId] != 0, CustomError_cfb3b942());\n    require(\n        address(uint160(storage_map_n[tokenId])) == msg.sender,\n        CustomError_cfb3b942()\n    );\n\n    // The following hash computation is present in the original byte-code\n    // and therefore kept even though its result is unused.\n    unchecked {\n        uint256 _callerHash = uint256(\n            keccak256(abi.encodePacked(msg.sender))\n        );\n        _callerHash; // silence unused-variable warning\n    }\n\n    // Approve `to` for `tokenId` (performed twice in the original byte-code)\n    unchecked {\n        uint256 packedData = storage_map_n[tokenId];\n        storage_map_n[tokenId] =\n            (uint256(uint160(to))) |\n            uint256(uint96(packedData));\n        emit Approval(\n            address(uint160(packedData)),\n            to,\n            tokenId\n        );\n\n        // Repeat (per original byte-code)\n        packedData = storage_map_n[tokenId];\n        storage_map_n[tokenId] =\n            (uint256(uint160(to))) |\n            uint256(uint96(packedData));\n        emit Approval(\n            address(uint160(packedData)),\n            to,\n            tokenId\n        );\n    }\n\n    // Traversal over previous token IDs exactly as observed in the byte-code\n    unchecked {\n        uint256 prevTokenId = tokenId - 1; // equivalently: tokenId + (\u22121)\n        if (storage_map_n[prevTokenId] != 0) {\n            prevTokenId = prevTokenId - 1;\n            if (storage_map_n[prevTokenId] != 0) {\n                prevTokenId = prevTokenId - 1;\n                if (storage_map_n[prevTokenId] != 0) {\n                    // no-op (placeholder for original empty branch)\n                }\n            }\n        }\n    }\n}",
    "ground_truth": "function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}"
}