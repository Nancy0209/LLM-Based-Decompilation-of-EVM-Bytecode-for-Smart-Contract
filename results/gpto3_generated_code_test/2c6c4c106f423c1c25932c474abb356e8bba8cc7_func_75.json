{
    "contract_address": "0x2C6C4c106F423c1C25932c474Abb356e8BBa8cC7",
    "heimdall_input": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        uint256 var_a = arg1;\n        var_b = 0x02;\n        require(address(storage_map_b[var_a]), \"ERC721: invalid token ID\");\n        require(!(address(arg0) == (address(storage_map_b[var_a]))), \"ERC721: invalid token ID\");\n        require(address(storage_map_b[var_a]) == msg.sender, \"ERC721: invalid token ID\");\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x05;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), \"ERC721: invalid token ID\");\n        var_a = arg1;\n        var_b = 0x04;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        var_a = arg1;\n        var_b = 0x02;\n        require(address(storage_map_b[var_a]), \"ERC721: invalid token ID\");\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x18;\n        var_f = 0x4552433732313a20696e76616c696420746f6b656e2049440000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x3d;\n        var_f = 0x4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f;\n        var_g = 0x6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000;\n        require(address(storage_map_b[var_a]) == msg.sender, \"ERC721: approve caller is not token owner or approved for all\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x3d;\n        var_f = 0x4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f;\n        var_g = 0x6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x4552433732313a20617070726f76616c20746f2063757272656e74206f776e65;\n        var_g = 0x7200000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x18;\n        var_f = 0x4552433732313a20696e76616c696420746f6b656e2049440000000000000000;\n    }",
    "llm_output": "function approve(address to, uint256 tokenId) public payable {\n    // 1. Tautological check preserved from byte-code for parity\n    require(to == address(to));\n\n    // 2. Verify the token exists\n    address owner = _owners[tokenId];\n    require(owner != address(0), \"ERC721: invalid token ID\");\n\n    // 3. Disallow approving the current owner\n    require(to != owner, \"ERC721: invalid token ID\");\n\n    // 4. Caller must be token owner or an approved operator\n    if (msg.sender != owner) {\n        require(_operatorApprovals[owner][msg.sender], \"ERC721: approve caller is not token owner or approved for all\");\n    }\n\n    // 5. Record the approval\n    _tokenApprovals[tokenId] = to;\n\n    // 6. Emit the standard event\n    emit Approval(owner, to, tokenId);\n}",
    "ground_truth": "function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}"
}