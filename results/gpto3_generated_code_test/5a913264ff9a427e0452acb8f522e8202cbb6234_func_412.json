{
    "contract_address": "0x5a913264FF9a427e0452acB8f522E8202CBB6234",
    "heimdall_input": "function setBurnAddress(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        burnAddress = (address(arg0)) | (uint96(burnAddress));\n        emit NewBurnAddress(msg.sender, address(arg0));\n    }",
    "llm_output": "function setBurnAddress(address _burnAddress) public {\n    // Redundant but preserved check from decompiled code\n    require(_burnAddress == address(_burnAddress));\n\n    // Ownership check (matches original logic)\n    require(msg.sender == owner(), \"Ownable: caller is not the owner\");\n\n    // Update `burnAddress` while preserving the upper 96 bits\n    assembly {\n        let slot := burnAddress.slot\n        let current := sload(slot)\n\n        // Mask to keep upper 96 bits intact (bits 160\u2012255)\n        let upper := and(\n            current,\n            not(0xffffffffffffffffffffffffffffffffffffffff)\n        )\n\n        // Combine upper 96 bits with new address (lower 160 bits)\n        let newVal := or(upper, _burnAddress)\n        sstore(slot, newVal)\n    }\n\n    emit NewBurnAddress(msg.sender, _burnAddress);\n}",
    "ground_truth": "function setBurnAddress(address _burnAddress) external onlyOwner {\\n        burnAddress = _burnAddress;\\n        emit NewBurnAddress(msg.sender, _burnAddress);\\n    }"
}