{
    "contract_address": "0xfc606C8F7141110c3f295a22004D274680A9A029",
    "heimdall_input": "function withdrawTokens() public {\n        require(store_j - 0x02, \"ReentrancyGuard: reentrant call\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1f;\n        var_d = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n        store_j = 0x02;\n        require(bytes1(canBond), \"must be able to withdraw\");\n        address var_e = msg.sender;\n        var_f = 0x04;\n        require(storage_map_k[var_e], \"must be able to withdraw\");\n        var_e = msg.sender;\n        var_f = 0x04;\n        require(block.timestamp > (storage_map_n[var_e]), \"must be able to withdraw\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x18;\n        var_d = 0x6d7573742062652061626c6520746f2077697468647261770000000000000000;\n        var_e = msg.sender;\n        var_f = 0x04;\n        require(0 - storage_map_k[var_e]);\n        require((TOKENS_PER_ETH == ((TOKENS_PER_ETH * storage_map_k[var_e]) / storage_map_k[var_e])) | !storage_map_k[var_e]);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        var_e = msg.sender;\n        var_f = 0x04;\n        require(!address(storage_map_o[var_e]));\n        require((TOKENS_PER_ETH * storage_map_k[var_e]) == (((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x01f4) | !0x01f4);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n        var_e = msg.sender;\n        var_f = 0x04;\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(storage_map_o[var_e]);\n        address var_c = ((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x2710;\n        (bool success, bytes memory ret0) = address(canBond / 0x0100).{ value: 0 ether }Unresolved_a9059cbb(var_b); // call\n        uint256 var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!((var_h + ret0.length) - var_h) < 0x20);\n        require(var_h.length == var_h.length);\n        var_e = msg.sender;\n        var_f = 0x06;\n        require(!storage_map_k[var_e] > ((((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x2710) + storage_map_k[var_e]));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        storage_map_k[var_e] = (((TOKENS_PER_ETH * storage_map_k[var_e]) * 0x01f4) / 0x2710) + storage_map_k[var_e];\n        var_i = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_c = msg.sender;\n        address var_d = TOKENS_PER_ETH * storage_map_k[var_e];\n        (bool success, bytes memory ret0) = address(canBond / 0x0100).{ value: 0 ether }Unresolved_a9059cbb(var_c); // call\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_b = msg.sender;\n        var_c = TOKENS_PER_ETH * storage_map_k[var_e];\n        (bool success, bytes memory ret0) = address(canBond / 0x0100).{ value: 0 ether }many_msg_babbage(var_b); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x6d757374206861766520626f6e64656420616d6f756e74000000000000000000;\n    }",
    "llm_output": "function withdrawTokens() external nonReentrant {\n    /* --------------------------------------------------------------------- */\n    /*  Reentrancy guard handled by `nonReentrant` modifier (see constructor) */\n    /* --------------------------------------------------------------------- */\n\n    /* --------------------------------------------------------------------- */\n    /*  1. Global contract status check                                      */\n    /* --------------------------------------------------------------------- */\n    require(canBond, \"must be able to withdraw\");\n\n    /* --------------------------------------------------------------------- */\n    /*  2. Load user bond                                                    */\n    /* --------------------------------------------------------------------- */\n    BondEntry storage userBond = bonds[msg.sender];\n\n    require(userBond.ethAmount > 0, \"must be able to withdraw\");\n    require(block.timestamp > userBond.withdrawTime, \"must be able to withdraw\");\n\n    /* --------------------------------------------------------------------- */\n    /*  3. Overflow\u2013style assertions that were visible in the decompiled     */\n    /*     byte-code.  These had no custom messages, so none are supplied.   */\n    /* --------------------------------------------------------------------- */\n    require(\n        userBond.ethAmount == 0 ||\n            (TOKENS_PER_ETH * userBond.ethAmount) / userBond.ethAmount == TOKENS_PER_ETH,\n        \"multiplication overflow\"\n    );\n\n    /*  In the original byte-code this appeared as `require(!address(referrer))`\n        which passes only if the address is the zero-address.                */\n    require(userBond.referrer == address(0), \"referrer must be zero\");\n\n    uint256 tokensForUser = TOKENS_PER_ETH * userBond.ethAmount;\n\n    require(\n        500 == 0 || (tokensForUser * 500) / 500 == tokensForUser,\n        \"multiplication overflow\"\n    );\n    require(10000 > 0, \"constant check\");\n\n    /* --------------------------------------------------------------------- */\n    /*  4. Referral payout (5 % = 500 / 10 000)                               */\n    /* --------------------------------------------------------------------- */\n    uint256 referralTokens = (tokensForUser * 500) / 10000;\n\n    if (referralTokens > 0) {\n        IERC20(token).transfer(userBond.referrer, referralTokens);\n    }\n\n    /* Additional assertion kept from decompiled code                        */\n    require(\n        !(userBond.ethAmount > (referralTokens + userBond.ethAmount)),\n        \"overflow check\"\n    );\n\n    /* Update stored ethAmount (logic copied from decompiled storage write)  */\n    userBond.ethAmount += referralTokens;\n\n    /* --------------------------------------------------------------------- */\n    /*  5. Transfer principal tokens to user                                 */\n    /* --------------------------------------------------------------------- */\n    IERC20(token).transfer(msg.sender, tokensForUser);\n}",
    "ground_truth": "function withdrawTokens() public nonReentrant {\r\n        require(canBond);\r\n        require(bonds[msg.sender].ethAmount > 0, \"must have bonded amount\");\r\n        require(block.timestamp > bonds[msg.sender].withdrawTime, \"must be able to withdraw\");\r\n        uint256 bondAmount = getTokenOut(\r\n            bonds[msg.sender].ethAmount\r\n        );\r\n        if(bonds[msg.sender].referrer != address(0)) {\r\n            uint256 refAmount = getRefAmount(bondAmount);\r\n            token.transfer(bonds[msg.sender].referrer, refAmount);\r\n            totalReferred[msg.sender] += refAmount;\r\n        }\r\n        token.transfer(msg.sender, bondAmount);\r\n        bonds[msg.sender].ethAmount = 0;\r\n    }"
}