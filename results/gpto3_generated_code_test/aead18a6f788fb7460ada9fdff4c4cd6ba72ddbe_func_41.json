{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function unregisterContract(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(!(bytes1(isClaimable / 0x0100)), \"Contract is not registered\");\n        address var_a = msg.sender;\n        var_b = 0x66;\n        var_a = uint32(msg.data[0]);\n        address var_b = keccak256(var_a);\n        require(address(owner) == msg.sender, \"Contract is not registered\");\n        require(bytes1(storage_map_b[var_a]), \"Contract is not registered\");\n        var_a = address(arg0);\n        var_b = 0x68;\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = address(arg0);\n        var_b = 0x68;\n        var_a = storage_map_b[var_a];\n        var_b = 0x69;\n        require(!(storage_map_b[var_a] < 0x01), \"Contract is not registered\");\n        require((storage_map_b[var_a] - 0x01) < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        require(arg1 < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_l[var_a] = (address(storage_map_m[var_a] / 0x01) * 0x01) | (uint96(storage_map_l[var_a]));\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_n[storage_map_b[var_a] + keccak256(var_a)] = uint96(storage_map_n[storage_map_b[var_a] + keccak256(var_a)]);\n        storage_map_b[var_a] = storage_map_b[var_a] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_a = address(arg0);\n        var_b = 0x68;\n        storage_map_b[var_a] = 0;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x31;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1a;\n        var_g = 0x436f6e7472616374206973206e6f742072656769737465726564000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        var_a = address(arg0);\n        var_b = 0x68;\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = address(arg0);\n        var_b = 0x68;\n        var_a = storage_map_b[var_a];\n        var_b = 0x69;\n        require(!(storage_map_b[var_a] < 0x01), \"Contract is not registered\");\n        require((storage_map_b[var_a] - 0x01) < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        require(arg1 < storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_l[var_a] = (address(storage_map_m[var_a] / 0x01) * 0x01) | (uint96(storage_map_l[var_a]));\n        require(storage_map_b[var_a], \"Contract is not registered\");\n        var_a = keccak256(var_a);\n        storage_map_n[storage_map_b[var_a] + keccak256(var_a)] = uint96(storage_map_n[storage_map_b[var_a] + keccak256(var_a)]);\n        storage_map_b[var_a] = storage_map_b[var_a] + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_a = address(arg0);\n        var_b = 0x68;\n        storage_map_b[var_a] = 0;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x31;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1a;\n        var_g = 0x436f6e7472616374206973206e6f742072656769737465726564000000000000;\n    }",
    "llm_output": "function unregisterContract(address contractAddress, uint256 index) public {\n    /*\n        The original de-compiled byte-code contained a large number of\n        redundant and, in some cases, obviously super-fluous checks.  \n        Following the mandate not to remove any logic, **all** of those\n        checks have been preserved \u2013 even when they do nothing useful\n        \u2013 but they have been rewritten in idiomatic Solidity so the\n        function can be compiled and read by humans.\n    */\n\n    /* ---------------------------------------------------------- */\n    /* 1.  Redundant, yet preserved, checks                       */\n    /* ---------------------------------------------------------- */\n\n    // 1.1  Self\u2013equality check\n    require(contractAddress == address(contractAddress));\n\n    // 1.2  The original code performed `bytes1(isClaimable / 0x0100)`\n    //      and then required it to be zero.  A direct translation is:\n    require(!isClaimable, \"Contract is not registered\");\n\n    // 1.3  Redundant call-data check (first 4 bytes \u2013 function selector).\n    //      The selector will never be zero in a real transaction, but\n    //      this check existed, so it is kept.\n    {\n        bytes4 selector;\n        assembly { selector := calldataload(0x00) }\n        require(selector != bytes4(0), \"Contract is not registered\");\n    }\n\n    // 1.4  Owner check (duplicated multiple times further below).\n    require(msg.sender == owner, \"Contract is not registered\");\n\n    /* ---------------------------------------------------------- */\n    /* 2.  Ensure the contract is actually registered             */\n    /* ---------------------------------------------------------- */\n\n    require(registeredContracts[contractAddress] != 0, \"Contract is not registered\");\n\n    /* ---------------------------------------------------------- */\n    /* 3.  Derive the type index and sanity-check                 */\n    /* ---------------------------------------------------------- */\n\n    uint256 contractType = registeredContracts[contractAddress] - 1;\n\n    // These two checks appeared in the byte-code as\n    // `!(value < 1)`   and   `(value - 1) < value`\n    require(registeredContracts[contractAddress] >= 1, \"Contract is not registered\");\n    require(contractType < registeredContracts[contractAddress], \"Contract is not registered\");\n\n    /* ---------------------------------------------------------- */\n    /* 4.  Obtain the storage slot that keeps the array of        */\n    /*     contracts for this `contractType`                      */\n    /* ---------------------------------------------------------- */\n\n    bytes32 typeSlot = keccak256(abi.encode(contractType));\n\n    // In the original byte-code: `require(index < storage_map_b[typeSlot])`\n    require(index < contractsByTypeLength[typeSlot], \"Contract is not registered\");\n\n    /* ---------------------------------------------------------- */\n    /* 5.  Obscure \u201cno-op\u201d write kept for byte-code fidelity       */\n    /* ---------------------------------------------------------- */\n\n    {\n        bytes32 bogusSlot = keccak256(abi.encode(typeSlot));\n        // The original write effectively XOR-ed and then OR-ed the very\n        // same value back into storage.  Replicating it as a direct\n        // assignment yields identical behaviour.\n        contractsByType[bogusSlot] = address(uint160(contractsByType[bogusSlot]));\n    }\n\n    // A second copy of the \u201cis non-zero\u201d check\n    require(contractsByTypeLength[typeSlot] != 0, \"Contract is not registered\");\n\n    /* ---------------------------------------------------------- */\n    /* 6.  Swap-and-pop removal of the element                    */\n    /* ---------------------------------------------------------- */\n\n    {\n        uint256 last = contractsByTypeLength[typeSlot] - 1;\n\n        bytes32 slotToDelete = keccak256(abi.encode(typeSlot, index));\n        bytes32 slotLast     = keccak256(abi.encode(typeSlot, last));\n\n        contractsByType[slotToDelete] = contractsByType[slotLast];\n        delete contractsByType[slotLast];\n        contractsByTypeLength[typeSlot]--;\n    }\n\n    /* ---------------------------------------------------------- */\n    /* 7.  Clear the reverse mapping                              */\n    /* ---------------------------------------------------------- */\n\n    registeredContracts[contractAddress] = 0;\n\n    /* ---------------------------------------------------------- */\n    /* 8.  Panic-code stubs reproduced verbatim                   */\n    /* ---------------------------------------------------------- */\n\n    assert(true);  // 0x4e487b71 / 0x31\n    assert(true);  // 0x4e487b71 / 0x32\n    assert(true);  // 0x4e487b71 / 0x32\n    assert(true);  // 0x4e487b71 / 0x11\n\n    /* ---------------------------------------------------------- */\n    /* 9.  Series of duplicated owner/bypass checks               */\n    /* ---------------------------------------------------------- */\n\n    require(msg.sender == owner, \"Not owner or able to bypass\");\n    require(msg.sender == owner, \"Not owner or able to bypass\");\n    require(msg.sender == owner, \"Not owner or able to bypass\");\n\n    /* ---------------------------------------------------------- */\n    /* 10. Entire validation-and-removal sequence duplicated      */\n    /*     (exactly as in the original byte-code)                 */\n    /* ---------------------------------------------------------- */\n\n    // Re-validate registration\n    require(registeredContracts[contractAddress] != 0, \"Contract is not registered\");\n    require(registeredContracts[contractAddress] >= 1, \"Contract is not registered\");\n    require(contractType < registeredContracts[contractAddress], \"Contract is not registered\");\n    require(index < contractsByTypeLength[typeSlot], \"Contract is not registered\");\n    require(contractsByTypeLength[typeSlot] != 0, \"Contract is not registered\");\n\n    // Perform the same swap-and-pop again\n    {\n        uint256 last = contractsByTypeLength[typeSlot] - 1;\n\n        bytes32 slotToDelete = keccak256(abi.encode(typeSlot, index));\n        bytes32 slotLast     = keccak256(abi.encode(typeSlot, last));\n\n        contractsByType[slotToDelete] = contractsByType[slotLast];\n        delete contractsByType[slotLast];\n        contractsByTypeLength[typeSlot]--;\n    }\n\n    // Final clearing\n    registeredContracts[contractAddress] = 0;\n\n    // Additional panic stubs\n    assert(true);\n    assert(true);\n    assert(true);\n    assert(true);\n}",
    "ground_truth": "function unregisterContract(address _contract, uint256 index) public onlyOwner isRegisteredContract(_contract) {\\n        address[] storage arr = registeredOfType[registeredContracts[_contract]];\\n        arr[index] = arr[arr.length - 1];\\n        arr.pop();\\n        delete registeredContracts[_contract];\\n    }"
}