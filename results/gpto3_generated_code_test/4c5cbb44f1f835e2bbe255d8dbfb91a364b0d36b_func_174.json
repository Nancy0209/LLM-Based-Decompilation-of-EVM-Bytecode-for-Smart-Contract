{
    "contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B",
    "heimdall_input": "function mintForTeam(uint256 arg0) public {\n        require(store_d - 0x02, \"Ownable: caller is not the owner\");\n        store_d = 0x02;\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(totalSupply > (arg0 + totalSupply)), CustomError_c30436e9());\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!((arg0 + totalSupply) > 0x2710), CustomError_c30436e9());\n        var_a = 0xc30436e900000000000000000000000000000000000000000000000000000000;\n        require(!(remainingTeamMints < arg0), CustomError_9f5441e4());\n        var_a = 0x9f5441e400000000000000000000000000000000000000000000000000000000;\n        require(0x06, CustomError_4341e6ed());\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(arg0 % 0x06), CustomError_4341e6ed());\n        var_a = 0x4341e6ed00000000000000000000000000000000000000000000000000000000;\n        require(0x06, \"ERC721A: token already minted\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(0 < (arg0 / 0x06)), \"ERC721A: token already minted\");\n        uint256 var_g = var_b + var_g;\n        uint256 var_a = 0;\n        require(address(msg.sender), \"ERC721A: token already minted\");\n        require(!(totalSupply > totalSupply), \"ERC721A: token already minted\");\n        var_h = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x1d;\n        var_i = 0x455243373231413a20746f6b656e20616c7265616479206d696e746564000000;\n        require(!(0x06 > 0x06), \"ERC721A: quantity to mint too high\");\n        var_h = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x22;\n        var_i = 0x455243373231413a207175616e7469747920746f206d696e7420746f6f206869;\n        var_j = 0x6768000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(msg.sender);\n        var_k = 0x04;\n        var_g = 0x40 + var_g;\n        address var_h = address(storage_map_h[var_e]);\n        address var_l = address(storage_map_h[var_e] / 0x0100000000000000000000000000000000);\n        var_g = 0x40 + var_g;\n        require(!((0x06 + (address(var_g.length))) > 0xffffffffffffffffffffffffffffffff), \"ERC721A: mint to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_h = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x21;\n        var_i = 0x455243373231413a206d696e7420746f20746865207a65726f20616464726573;\n        var_j = 0x7300000000000000000000000000000000000000000000000000000000000000;\n        require(!((remainingTeamMints - arg0) > remainingTeamMints), \"ReentrancyGuard: reentrant call\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        remainingTeamMints = remainingTeamMints - arg0;\n        store_d = 0x01;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1f;\n        var_d = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n    }",
    "llm_output": "function mintForTeam(uint256 amount) external onlyOwner nonReentrant {\n    // This check is a tautology but preserved to maintain decompiled logic fidelity.\n    if (totalSupply() > totalSupply() + amount) revert ExceedsMaxSupply();\n\n    // Make sure the mint does not exceed the overall collection size.\n    if (totalSupply() + amount > collectionSize) revert ExceedsMaxSupply();\n\n    // Make sure the mint does not exceed the team\u2019s remaining allocation.\n    if (amount > remainingTeamMints) revert ExceedsMaxPerTeam();\n\n    // Ensure `maxBatchSize` is non-zero (matches the decompiled always-true check).\n    if (maxBatchSize == 0) revert AmountNotMultipleOfBatchSize();\n\n    // The amount to mint must be a multiple of the batch size.\n    if (amount % maxBatchSize != 0) revert AmountNotMultipleOfBatchSize();\n\n    // Mint in batches of `maxBatchSize`.\n    uint256 batches = amount / maxBatchSize;\n    for (uint256 i; i < batches; ++i) {\n        _safeMint(msg.sender, maxBatchSize);\n    }\n\n    // Update remaining team allocation.\n    remainingTeamMints -= amount;\n}",
    "ground_truth": "function mintForTeam(uint256 amount) external nonReentrant onlyOwner {\\n        if (totalSupply() + amount > collectionSize) revert ExceedsMaxSupply();\\n        if (remainingTeamMints < amount) revert ExceedsMaxPerTeam();\\n        if (amount % maxBatchSize != 0) revert AmountNotMultipleOfBatchSize();\\n        \\n        uint256 SizeforTeam = amount / maxBatchSize;\\n        for (uint256 i = 0; i < SizeforTeam ; i++) {\\n            _safeMint(msg.sender, maxBatchSize);\\n        }\\n        \\n        remainingTeamMints -= amount; \\n        \\n    }"
}