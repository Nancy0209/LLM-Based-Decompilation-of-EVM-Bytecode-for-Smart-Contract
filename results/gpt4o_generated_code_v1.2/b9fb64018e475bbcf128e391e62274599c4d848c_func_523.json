{
    "contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C",
    "heimdall_input": "function getMintStats(address arg0) public view returns (bytes memory) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = uint64(storage_map_b[var_a] >> 0x40);\n        uint256 var_d = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + totalSupply;\n        var_e = maxSupply;\n        return abi.encodePacked(uint64(storage_map_b[var_a] >> 0x40), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + totalSupply, maxSupply);\n    }",
    "llm_output": "function getMintStats(address minter) public view returns (uint256 minterNumMinted, uint256 currentTotalSupply, uint256 maxSupply) {\n    // Ensure the provided address is valid (this check is redundant but preserved for logical fidelity)\n    require(minter == address(minter));\n\n    // Retrieve the number of tokens minted by the minter\n    minterNumMinted = uint64(storage_map_b[minter] >> 64);\n\n    // Calculate the current total supply\n    currentTotalSupply = totalSupply;\n\n    // Retrieve the maximum supply\n    maxSupply = maxSupply;\n\n    return (minterNumMinted, currentTotalSupply, maxSupply);\n}",
    "ground_truth": "function getMintStats(address minter)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 minterNumMinted,\\n            uint256 currentTotalSupply,\\n            uint256 maxSupply\\n        )\\n    {\\n        minterNumMinted = _numberMinted(minter);\\n        currentTotalSupply = _totalMinted();\\n        maxSupply = _maxSupply;\\n    }"
}