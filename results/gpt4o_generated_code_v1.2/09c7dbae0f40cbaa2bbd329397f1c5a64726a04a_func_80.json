{
    "contract_address": "0x09c7dBaE0F40CBAA2BBd329397f1c5A64726a04a",
    "heimdall_input": "function transfer(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!(bytes1(limitOn / 0x01000000)), \"Blacklisted\");\n        require(!(!(address(pair)) == (address(arg0))), \"Blacklisted\");\n        require((sellFee == ((sellFee * arg1) / arg1)) | !arg1, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(0x64, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require((burnFee == ((burnFee * arg1) / arg1)) | !arg1, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(0x64, \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!((arg1 - ((sellFee * arg1) / 0x64)) > arg1), \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!((arg1 - ((sellFee * arg1) / 0x64)) - ((burnFee * arg1) / 0x64) > (arg1 - ((sellFee * arg1) / 0x64))), \"Blacklisted\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(address(msg.sender), \"Blacklisted\");\n        require(address(limitOn / 0x0100000000), \"Blacklisted\");\n        address var_a = address(limitOn / 0x0100000000);\n        var_c = 0x0b;\n        require(!(!bytes1(storage_map_b[var_a])), \"Blacklisted\");\n        require(!(bytes1(storage_map_b[var_a])), \"Blacklisted\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x0b;\n        var_g = 0x426c61636b6c6973746564000000000000000000000000000000000000000000;\n        require(bytes1(limitOn), \"Presale tokens are currently frozen.\");\n        require(bytes1(limitOn / 0x0100), \"Presale tokens are currently frozen.\");\n        require(bytes1(limitOn / 0x0100), \"Presale tokens are currently frozen.\");\n        require(!(bytes1(limitOn / 0x010000)), \"Presale tokens are currently frozen.\");\n        require(!(address(pair) == (address(msg.sender))), \"Presale tokens are currently frozen.\");\n        require(!(bytes1(requiredTokenRuleOn)), \"Presale tokens are currently frozen.\");\n        require(!(address(pair) == (address(limitOn / 0x0100000000))), \"Presale tokens are currently frozen.\");\n        require(!(bytes1(presaleHolderLock)), \"Presale tokens are currently frozen.\");\n        var_a = address(msg.sender);\n        var_c = 0x0f;\n        require(!storage_map_b[var_a], \"Presale tokens are currently frozen.\");\n        var_a = address(msg.sender);\n        var_c = 0x0f;\n        uint256 var_c = 0;\n        require(!(storage_map_b[var_a] - ((sellFee * arg1) / 0x64) > storage_map_b[var_a]), \"Presale tokens are currently frozen.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(storage_map_b[var_a] - ((sellFee * arg1) / 0x64) < storage_map_b[var_a]), \"Presale tokens are currently frozen.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x50726573616c6520746f6b656e73206172652063757272656e746c792066726f;\n        var_h = 0x7a656e2e00000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_c = 0;\n        require(!(storage_map_b[var_a] < ((sellFee * arg1) / 0x64)), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_c = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - ((sellFee * arg1) / 0x64);\n        var_a = address(limitOn / 0x0100000000);\n        storage_map_b[var_a] = ((sellFee * arg1) / 0x64) + storage_map_b[var_a];\n        uint256 var_d = (sellFee * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(limitOn / 0x0100000000), (sellFee * arg1) / 0x64);\n        require(address(msg.sender), \"ERC20: burn from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x21;\n        var_g = 0x45524332303a206275726e2066726f6d20746865207a65726f20616464726573;\n        var_h = 0x7300000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_e = address(msg.sender);\n        (bool success, bytes memory ret0) = address(requiredToken).Unresolved_70a08231(var_e); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!(((var_i + ret0.length) - var_i) < 0x20), \"Insufficient Finale balance in wallet to sell.\");\n        require(!(var_i.length < requiredTokenAmount), \"Insufficient Finale balance in wallet to sell.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x2e;\n        var_h = 0x496e73756666696369656e742046696e616c652062616c616e636520696e2077;\n        var_k = 0x616c6c657420746f2073656c6c2e000000000000000000000000000000000000;\n        if (!requiredTokenRuleOn) {\n        }\n        var_a = address(limitOn / 0x0100000000);\n        var_c = 0;\n        require(!(storage_map_b[var_a] > (((sellFee * arg1) / 0x64) + storage_map_b[var_a])), \"Max holding amount exceeded\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(((sellFee * arg1) / 0x64) + storage_map_b[var_a] > maxHoldingAmount), \"Max holding amount exceeded\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x4d617820686f6c64696e6720616d6f756e742065786365656465640000000000;\n        if (!limitOn / 0x010000) {\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x13;\n        var_g = 0x53656c6c696e67206e6f7420656e61626c656400000000000000000000000000;\n        require(address(owner) == (address(msg.sender)), \"Trading not enabled\");\n        require(address(owner) == (address(limitOn / 0x0100000000)), \"Trading not enabled\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x13;\n        var_g = 0x54726164696e67206e6f7420656e61626c656400000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "function transfer(address recipient, uint256 amount) public payable {\n    require(recipient != address(0), \"Invalid recipient address\");\n    require(!blacklist[msg.sender], \"Sender is blacklisted\");\n    require(!blacklist[recipient], \"Recipient is blacklisted\");\n    require(tradingOn, \"Trading is not enabled\");\n\n    uint256 sellFeeAmount = (sellFee * amount) / 100;\n    uint256 burnFeeAmount = (burnFee * amount) / 100;\n    uint256 transferAmount = amount - sellFeeAmount - burnFeeAmount;\n\n    require(transferAmount <= amount, \"Transfer amount exceeds balance\");\n    require(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\n\n    // Deduct fees and update balances\n    balanceOf[msg.sender] -= amount;\n    balanceOf[recipient] += transferAmount;\n    balanceOf[feeWallet] += sellFeeAmount;\n\n    emit Transfer(msg.sender, recipient, transferAmount);\n    emit Transfer(msg.sender, feeWallet, sellFeeAmount);\n\n    // Burn fee logic\n    totalSupply -= burnFeeAmount;\n    emit Transfer(msg.sender, address(0), burnFeeAmount);\n\n    // Check max holding amount if limit is enabled\n    if (limitOn) {\n        require(balanceOf[recipient] <= maxHoldingAmount, \"Max holding amount exceeded\");\n    }\n\n    // Check required token rule if enabled\n    if (requiredTokenRuleOn) {\n        uint256 requiredTokenBalance = IERC20(requiredToken).balanceOf(msg.sender);\n        require(requiredTokenBalance >= requiredTokenAmount, \"Insufficient required token balance\");\n    }\n}",
    "ground_truth": "function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}"
}