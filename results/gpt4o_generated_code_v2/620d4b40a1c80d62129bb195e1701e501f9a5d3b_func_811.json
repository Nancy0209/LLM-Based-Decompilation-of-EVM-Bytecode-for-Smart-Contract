{
    "contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b",
    "heimdall_input": "function ownerOf(uint256 arg0) public view returns (address) {\n        require(0x01 > arg0, CustomError_df2d9b42());\n        require(!(arg0 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg0;\n        var_b = 0x04;\n        require(bytes1(storage_map_n[var_a]), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(storage_map_n[var_a], CustomError_df2d9b42());\n        uint256 var_c = address(storage_map_n[var_a]);\n        return address(storage_map_n[var_a]);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg0;\n        var_b = 0x04;\n        require(storage_map_n[var_a], CustomError_df2d9b42());\n        var_c = address(storage_map_n[var_a]);\n        return address(storage_map_n[var_a]);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg0);\n        var_b = 0x04;\n        require(storage_map_n[var_a], CustomError_df2d9b42());\n        var_c = address(storage_map_n[var_a]);\n        return address(storage_map_n[var_a]);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg0));\n        var_b = 0x04;\n        require(storage_map_n[var_a], CustomError_df2d9b42());\n        var_c = address(storage_map_n[var_a]);\n        return address(storage_map_n[var_a]);\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract TokenOwnership {\n    // Mapping to store the owner of each token ID\n    mapping(uint256 => address) private tokenOwners;\n\n    // Total supply of tokens\n    uint256 private totalSupply;\n\n    // Custom error for invalid token ID\n    error InvalidTokenId();\n\n    /**\n     * @dev Returns the owner of the specified token ID.\n     * Reverts if the token ID is invalid or does not exist.\n     * @param tokenId The ID of the token to query.\n     * @return The address of the owner of the token.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        // Ensure the token ID is within the valid range\n        if (tokenId >= totalSupply) {\n            revert InvalidTokenId();\n        }\n\n        // Retrieve the owner of the token\n        address owner = tokenOwners[tokenId];\n\n        // Ensure the token has a valid owner\n        if (owner == address(0)) {\n            revert InvalidTokenId();\n        }\n\n        return owner;\n    }\n\n    /**\n     * @dev Internal function to set the owner of a token.\n     * This function is for demonstration purposes and assumes proper checks\n     * are performed before calling it.\n     * @param tokenId The ID of the token.\n     * @param owner The address of the new owner.\n     */\n    function _setTokenOwner(uint256 tokenId, address owner) internal {\n        tokenOwners[tokenId] = owner;\n    }\n\n    /**\n     * @dev Internal function to set the total supply of tokens.\n     * This function is for demonstration purposes and assumes proper checks\n     * are performed before calling it.\n     * @param supply The total supply of tokens.\n     */\n    function _setTotalSupply(uint256 supply) internal {\n        totalSupply = supply;\n    }\n}\n```\n\n### Explanation of Changes:\n1. **Improved Naming**:\n   - Renamed variables and mappings to meaningful names (`tokenOwners`, `totalSupply`, `tokenId`, etc.).\n   - Replaced the cryptic `CustomError_df2d9b42` with a clear custom error `InvalidTokenId`.\n\n2. **Removed Redundant Code**:\n   - Removed unnecessary and repetitive calculations involving large constants.\n   - Simplified the logic to directly check the validity of the `tokenId` and retrieve the owner.\n\n3. **Added Comments**:\n   - Added comments to explain the purpose of each function and variable.\n\n4. **Best Practices**:\n   - Used the latest Solidity version (`^0.8.0`) to avoid issues like integer overflow/underflow.\n   - Used a custom error (`InvalidTokenId`) for gas-efficient error handling.\n\n5. **Modular Design**:\n   - Added internal helper functions (`_setTokenOwner` and `_setTotalSupply`) to demonstrate how the contract could be extended or used in a real-world scenario.\n\nThis refactored code is clean, readable, and ready for compilation.",
    "ground_truth": "function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\n    }"
}