{
    "contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE",
    "heimdall_input": "function explicitOwnershipOf(uint256 arg0) public view returns (bool) {\n        uint256 var_a = var_a + 0x80;\n        uint256 var_b = 0;\n        uint256 var_c = 0;\n        uint256 var_d = 0;\n        uint256 var_e = 0;\n        require(arg0 < 0x01);\n        require(!arg0 < totalSupply);\n        uint256 var_f = arg0;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        uint256 var_h = 0;\n        uint256 var_i = 0;\n        uint256 var_j = 0;\n        uint256 var_k = 0;\n        var_f = arg0;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        uint256 var_l = 0;\n        uint256 var_m = 0;\n        uint256 var_n = 0;\n        uint256 var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        uint256 var_p = address(var_a.length);\n        uint64 var_q = uint64(var_r);\n        var_s = !(!var_t);\n        uint24 var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_f = arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        var_h = 0;\n        var_i = 0;\n        var_j = 0;\n        var_k = 0;\n        var_f = arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        var_l = 0;\n        var_m = 0;\n        var_n = 0;\n        var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        var_p = address(var_a.length);\n        var_q = uint64(var_r);\n        var_s = !(!var_t);\n        var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_f = (arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        var_h = 0;\n        var_i = 0;\n        var_j = 0;\n        var_k = 0;\n        var_f = (arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        var_l = 0;\n        var_m = 0;\n        var_n = 0;\n        var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        var_p = address(var_a.length);\n        var_q = uint64(var_r);\n        var_s = !(!var_t);\n        var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_f = ((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(storage_map_s[var_f]);\n        var_a = var_a + 0x80;\n        var_h = 0;\n        var_i = 0;\n        var_j = 0;\n        var_k = 0;\n        var_f = ((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_g = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        var_a = var_a + 0x80;\n        var_l = 0;\n        var_m = 0;\n        var_n = 0;\n        var_o = 0;\n        var_l = address(storage_map_s[var_f]);\n        var_m = uint64(storage_map_s[var_f] >> 0xa0);\n        var_n = !(!bytes1(storage_map_s[var_f]));\n        var_o = storage_map_s[var_f] >> 0xe8;\n        var_p = address(var_a.length);\n        var_q = uint64(var_r);\n        var_s = !(!var_t);\n        var_u = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_h = address(var_a.length);\n        var_i = uint64(var_r);\n        var_j = !(!var_t);\n        var_k = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n        var_h = address(var_a.length);\n        var_i = uint64(var_r);\n        var_j = !(!var_t);\n        var_k = uint24(var_v);\n        return abi.encodePacked(address(var_a.length), uint64(var_w), !(!var_x), uint24(var_y));\n    }",
    "llm_output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract OwnershipContract {\n    uint256 public totalSupply;\n    mapping(uint256 => uint256) private storageMap;\n\n    function explicitOwnershipOf(uint256 tokenId) public view returns (address owner, uint64 timestamp, bool isActive, uint24 extraData) {\n        require(tokenId < totalSupply, \"Token ID is out of range\");\n\n        uint256 data = storageMap[tokenId];\n        require(data != 0, \"Token does not exist\");\n\n        owner = address(uint160(data));\n        timestamp = uint64(data >> 160);\n        isActive = (data & (1 << 224)) != 0;\n        extraData = uint24(data >> 232);\n\n        return (owner, timestamp, isActive, extraData);\n    }\n}\n```\n\n### Explanation:\n1. **Contract Name**: Changed the contract name to `OwnershipContract` for clarity.\n2. **Function Name**: Changed the function name to `explicitOwnershipOf` to reflect its purpose.\n3. **Parameters and Returns**: The function now takes a `tokenId` and returns a tuple containing the `owner` address, `timestamp`, `isActive` status, and `extraData`.\n4. **Mapping**: Used a mapping `storageMap` to simulate the storage of token data.\n5. **Data Extraction**: Extracted the owner, timestamp, active status, and extra data from the stored data using bitwise operations.\n6. **Require Statements**: Added require statements to ensure the token ID is valid and the token exists.\n7. **Readability**: Improved readability by using meaningful variable names and removing unnecessary operations.",
    "ground_truth": "function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}"
}