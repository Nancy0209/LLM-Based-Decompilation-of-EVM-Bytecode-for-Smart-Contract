{
    "contract_address": "0x3cf93d43251324C527346abF3e0559f4C7a713d1",
    "heimdall_input": "function upgradeTo(address arg0) public returns (uint256) {\n        require(arg0 == (address(arg0)));\n        require(!(address(msg.sender)) == (address(store_a)));\n        require(!(address(msg.sender)) == (address(store_a)));\n        var_a = msg.data[0:4];\n        (bool success, bytes memory ret0) = address(store_b).Unresolved_(var_b); // delegatecall\n        return ;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x42;\n        var_f = 0x5472616e73706172656e745570677261646561626c6550726f78793a2061646d;\n        var_g = 0x696e2063616e6e6f742066616c6c6261636b20746f2070726f78792074617267;\n        var_h = 0x6574000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_i = var_d + var_i;\n        uint256 var_c = 0;\n        require(address(arg0).code.length, \"ERC1967: new implementation is not a contract\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x2d;\n        var_g = 0x455243313936373a206e657720696d706c656d656e746174696f6e206973206e;\n        var_h = 0x6f74206120636f6e747261637400000000000000000000000000000000000000;\n        store_b = (address(arg0)) | (uint96(store_b));\n        emit Upgraded(address(arg0));\n        require(var_i.length > 0, \"Address: delegate call to non-contract\");\n        require(!(var_i.length > 0), \"Address: delegate call to non-contract\");\n        var_i = 0x60 + var_i;\n        var_j = 0x27;\n        var_k = this.code[2049:2088];\n        require(address(arg0).code.length, \"Address: delegate call to non-contract\");\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        var_m = 0x26;\n        var_n = 0x416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f;\n        var_o = 0x6e74726163740000000000000000000000000000000000000000000000000000;\n        require(!0 > var_i.length);\n        uint256 var_l = 0;\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_(var_p); // delegatecall\n        require(ret0.length == 0);\n        require(!var_q);\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        uint256 var_m = var_i.length;\n        require(!(0 > var_i.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_r = 0;\n        var_i = var_i + (uint248(ret0.length + 0x3f));\n        var_l = ret0.length;\n        require(!var_i.length);\n    }",
    "llm_output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract UpgradeableProxy {\n    // Storage variables\n    address private _implementation; // Current implementation address\n    address private _admin; // Admin address\n\n    // Events\n    event Upgraded(address indexed newImplementation);\n\n    // Modifiers\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"UpgradeableProxy: caller is not the admin\");\n        _;\n    }\n\n    constructor(address initialImplementation, address admin) {\n        require(initialImplementation != address(0), \"UpgradeableProxy: implementation cannot be zero address\");\n        require(admin != address(0), \"UpgradeableProxy: admin cannot be zero address\");\n\n        _implementation = initialImplementation;\n        _admin = admin;\n    }\n\n    /**\n     * @dev Upgrades the implementation to a new address.\n     * @param newImplementation The address of the new implementation contract.\n     */\n    function upgradeTo(address newImplementation) external onlyAdmin {\n        require(newImplementation != address(0), \"UpgradeableProxy: new implementation cannot be zero address\");\n        require(newImplementation != _implementation, \"UpgradeableProxy: new implementation must be different\");\n        require(isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n        _implementation = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Fallback function to delegate calls to the implementation contract.\n     */\n    fallback() external payable {\n        _delegate(_implementation);\n    }\n\n    /**\n     * @dev Delegates the current call to `implementation`.\n     * @param implementation The address of the implementation contract.\n     */\n    function _delegate(address implementation) internal {\n        require(isContract(implementation), \"UpgradeableProxy: delegate call to non-contract\");\n\n        assembly {\n            // Copy msg.data to memory\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n\n            // Delegate call to the implementation\n            let result := delegatecall(gas(), implementation, ptr, calldatasize(), 0, 0)\n\n            // Copy the returned data\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            // Handle the result\n            switch result\n            case 0 {\n                // Revert if the delegatecall failed\n                revert(ptr, size)\n            }\n            default {\n                // Return the data if the delegatecall succeeded\n                return(ptr, size)\n            }\n        }\n    }\n\n    /**\n     * @dev Checks if an address is a contract.\n     * @param account The address to check.\n     * @return True if the address is a contract, false otherwise.\n     */\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() external view returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Returns the current admin address.\n     */\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n}\n```\n\n### Key Improvements:\n1. **Readable Variable Names**: Replaced ambiguous variable names like `var_a`, `var_b`, etc., with meaningful names.\n2. **Removed Redundant Code**: Eliminated unnecessary and duplicate checks.\n3. **Added Comments**: Included comments to explain the purpose of each function and logic.\n4. **Proper Error Messages**: Added descriptive error messages for `require` statements.\n5. **Fallback Functionality**: Implemented a fallback function to delegate calls to the implementation contract.\n6. **Contract Check**: Added a utility function `isContract` to verify if an address is a contract.\n7. **Event Emission**: Ensured the `Upgraded` event is emitted when the implementation is updated.\n8. **Admin Control**: Restricted the `upgradeTo` function to only be callable by the admin.\n\nThis refactored code is clean, functional, and adheres to Solidity best practices.",
    "ground_truth": "function upgradeTo(address newImplementation) external virtual {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, bytes(\\\"\\\"), false);\\n    }"
}