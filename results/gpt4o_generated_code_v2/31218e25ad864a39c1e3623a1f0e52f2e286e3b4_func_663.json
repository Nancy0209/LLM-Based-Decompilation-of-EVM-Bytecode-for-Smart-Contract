{
    "contract_address": "0x31218E25Ad864a39c1e3623a1F0e52f2E286E3b4",
    "heimdall_input": "function manualBurn(uint256 arg0) public {\n        require(arg0 > 0, \"SafeMath: addition overflow\");\n        address var_a = address(msg.sender);\n        var_b = 0x03;\n        require(bytes1(storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        require(bytes1(storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        require(!0, \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_a[var_a] > (0 + storage_map_a[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((0 + storage_map_a[var_a]) < storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_a[var_a] = 0 + storage_map_a[var_a];\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        uint256 var_h = 0x40 + var_h;\n        var_d = 0x1e;\n        var_i = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg0 > storage_map_a[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_k = var_h.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        require(!((storage_map_a[var_a] - arg0) > storage_map_a[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_a[var_a] = storage_map_a[var_a] - arg0;\n        var_h = 0x40 + var_h;\n        var_j = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(0 > arg0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_p = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        uint256 var_q = var_h.length;\n        uint256 var_r = 0;\n        var_s = var_n;\n        var_r = 0;\n        require(!((arg0 - 0) > arg0), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(bytes1(tradingEnabled / 0x010000000000000000000000000000000000000000), \"SafeMath: multiplication overflow\");\n        require(address(msg.sender) - (address(tradingEnabled)), \"SafeMath: multiplication overflow\");\n        require(0xdead - (address(tradingEnabled)), \"SafeMath: multiplication overflow\");\n        require(0 - arg0, \"SafeMath: multiplication overflow\");\n        require((sellFees == ((sellFees * arg0) / arg0)) | !arg0, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(arg0, \"SafeMath: multiplication overflow\");\n        require(((sellFees * arg0) / arg0) == sellFees, \"SafeMath: multiplication overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_k = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x40 + var_h;\n        var_d = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64);\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        tradingEnabled = 0x01000000000000000000000000000000000000000000 | (uint248(tradingEnabled));\n        var_j = 0x02;\n        var_h = var_h + 0x60;\n        var_t = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_o = address(this);\n        var_u = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_c / 0x01).WETH(var_q); // staticcall\n        var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!((var_h + ret0.length) - var_h) < 0x20);\n        require(var_h.length == (address(var_h.length)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        uint256 var_p = address(var_h.length);\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_c);\n        address var_b = keccak256(var_a);\n        storage_map_a[var_a] = store_d;\n        var_v = store_d;\n        emit Approval(address(this), address(store_c), store_d);\n        var_v = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_s = store_d;\n        uint256 var_w = 0;\n        var_x = 0xa0;\n        uint256 var_y = var_h.length;\n        address var_z = address(this);\n        uint256 var_aa = block.timestamp;\n        require(address(store_c).code.length);\n        (bool success, bytes memory ret0) = address(store_c).Unresolved_791ac947(var_s); // call\n        tradingEnabled = uint248(tradingEnabled);\n        (bool success, bytes memory ret0) = address(store_e).transfer(address(this).balance);\n        if (ret0.length == 0) {\n        }\n        var_a = address(this);\n        var_b = 0x01;\n        if (!storage_map_a[var_a] > store_d) {\n        }\n        if (!tradingEnabled / 0x0100000000000000000000000000000000000000000000) {\n        }\n        if (!(address(tradingEnabled)) == 0xdead) {\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x16;\n        var_g = 0x54726164696e67206973206e6f74207374617274656400000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_k = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n    }",
    "llm_output": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Token {\n    mapping(address => uint256) private balances;\n    uint256 public sellFees;\n    bool public tradingEnabled;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    modifier onlyWhenTradingEnabled() {\n        require(tradingEnabled, \"Trading is not enabled\");\n        _;\n    }\n\n    function manualBurn(uint256 amount) public onlyWhenTradingEnabled {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        balances[address(this)] += amount;\n\n        emit Transfer(msg.sender, address(this), amount);\n    }\n\n    function enableTrading() public {\n        tradingEnabled = true;\n    }\n\n    function setSellFees(uint256 _sellFees) public {\n        sellFees = _sellFees;\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(to != address(0), \"Transfer to the zero address\");\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0), \"Approve to the zero address\");\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balances[account];\n    }\n}\n```\n\n### Explanation:\n1. **Functionality**: The refactored code provides a basic ERC20-like token contract with a `manualBurn` function that allows users to burn their tokens by transferring them to the contract itself.\n2. **Modifiers**: Added a modifier `onlyWhenTradingEnabled` to ensure that certain functions can only be executed when trading is enabled.\n3. **Events**: Added `Transfer` and `Approval` events to follow the ERC20 standard.\n4. **Functions**: Implemented basic functions like `transfer`, `approve`, and `balanceOf` to manage token balances.\n5. **State Variables**: Added state variables for `balances`, `sellFees`, and `tradingEnabled` to manage the contract's state.\n6. **Error Messages**: Improved error messages for clarity and correctness.",
    "ground_truth": "function manualBurn(uint256 amount) external returns (bool) {\r\n        _transfer(address(msg.sender), address(0xdead), amount);\r\n        return true;\r\n    }"
}