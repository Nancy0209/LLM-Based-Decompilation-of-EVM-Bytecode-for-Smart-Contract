{
    "contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421",
    "heimdall_input": "function farm(uint256 arg0, uint256 arg1) public payable {\n        require(0x01 == (bytes1(isStakingAvilable)), \"Invalid amount\");\n        require(!(arg0 < minimumDeposit), \"Invalid amount\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0e;\n        var_d = 0x496e76616c696420616d6f756e74000000000000000000000000000000000000;\n        uint256 var_e = arg1;\n        var_f = 0x02;\n        require(storage_map_c[var_e]);\n        var_a = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        address var_c = address(this);\n        uint256 var_d = arg0;\n        require(address(Token).code.length);\n        (bool success, bytes memory ret0) = address(Token).{ value: 0 ether }Unresolved_23b872dd(var_b); // call\n        uint256 var_g = var_g + (uint248(ret0.length + 0x1f));\n        require(!((var_g + ret0.length) - var_g) < 0x20);\n        require(var_g.length == var_g.length);\n        var_e = msg.sender;\n        var_f = 0x03;\n        storage_map_c[var_e] = 0x01 + storage_map_c[var_e];\n        var_e = keccak256(var_e);\n        storage_map_e[var_e] = arg0;\n        var_e = msg.sender;\n        var_f = 0x05;\n        storage_map_c[var_e] = storage_map_c[var_e] + 0x01;\n        var_e = keccak256(var_e);\n        storage_map_f[var_e] = uint40(block.timestamp);\n        var_e = msg.sender;\n        var_f = 0x06;\n        require(!storage_map_c[var_e] > ~(arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x15;\n        var_d = 0x496e76616c6964206461792073656c656374696f6e0000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x12;\n        var_d = 0x5374616b696e6720697320706175736564210000000000000000000000000000;\n    }",
    "llm_output": "function farm(uint256 _amount, uint256 _lockableDays) public payable {\n    require(isStakingAvilable, \"Staking is not available\");\n    require(_amount >= minimumDeposit, \"Invalid deposit amount\");\n    require(_lockableDays == 14 || _lockableDays == 30, \"Invalid lockable days\");\n\n    // Transfer tokens from the sender to the contract\n    require(Token.transferFrom(msg.sender, address(this), _amount), \"Token transfer failed\");\n\n    // Update user staking information\n    Users[msg.sender].DepositeToken += _amount;\n    Users[msg.sender].lastUpdated = block.timestamp;\n    Users[msg.sender].lockableDays = _lockableDays;\n    Users[msg.sender].depositeTime = block.timestamp;\n\n    // Emit deposit event\n    emit Deposite_(address(this), msg.sender, _amount, _lockableDays, block.timestamp);\n}",
    "ground_truth": "function farm(uint256 _amount, uint256 _lockableDays) public \r\n    {\r\n        require(isStakingAvilable==true,\"Staking is paused!\");\r\n        require(_amount >= minimumDeposit, \"Invalid amount\");\r\n        require(allocation[_lockableDays] > 0, \"Invalid day selection\");\r\n        Token.transferFrom(msg.sender, address(this), _amount);\r\n        depositeToken[msg.sender].push(_amount);\r\n        depositetime[msg.sender].push(uint40(block.timestamp));\r\n        Users[msg.sender].DepositeToken += _amount;\r\n        lockabledays[msg.sender].push(_lockableDays);\r\n        stakers.push(msg.sender);\r\n        totalStakedToken+=_amount;\r\n        totallockvalue+=_amount;\r\n        uint256 reward = (allocation[_lockableDays].mul(_amount).div(100)).div(1e18);\r\n        rewardtobewithdraw+=reward;\r\n        emit Deposite_(msg.sender,address(this),_amount,_lockableDays,block.timestamp);\r\n    }"
}