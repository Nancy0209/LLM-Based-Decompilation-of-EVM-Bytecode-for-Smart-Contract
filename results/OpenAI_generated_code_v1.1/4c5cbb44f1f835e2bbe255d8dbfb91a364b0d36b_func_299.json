{
    "contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B",
    "heimdall_input": "function mintForOG(uint256 arg0, bytes32[] arg1) public payable {\n        require(!arg1 > 0xffffffffffffffff);\n        require(!(arg1) > 0xffffffffffffffff);\n        require(store_d - 0x02, CustomError_2c5a460a());\n        store_d = 0x02;\n        require(0x01 == salePhase, CustomError_2c5a460a());\n        uint256 var_a = var_a + (0x20 + (0x20 * (arg1)));\n        uint256 var_b = (arg1);\n        var_c = msg.data[36:36];\n        uint256 var_d = 0;\n        address var_e = address(msg.sender << 0x60);\n        var_d = ((0x34 + var_a) - var_a) - 0x20;\n        var_a = 0x34 + var_a;\n        require(keccak256(var_c) < (var_c), CustomError_2c5a460a());\n        var_f = keccak256(var_c);\n        var_g = var_c;\n        require(0x01, CustomError_2c5a460a());\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_f = var_c;\n        var_g = keccak256(var_c);\n        require(0x01, CustomError_2c5a460a());\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x32;\n        require(keccak256(var_c) == merkleRootOG, CustomError_2c5a460a());\n        require(!(arg0 > 0x06), CustomError_2c5a460a());\n        var_i = 0x2c5a460a00000000000000000000000000000000000000000000000000000000;\n        address var_f = msg.sender;\n        var_g = 0x17;\n        require(!(storage_map_v[var_f] > (arg0 + storage_map_v[var_f])), CustomError_30db1f08());\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(!((arg0 + storage_map_v[var_f]) > 0x06), CustomError_30db1f08());\n        var_i = 0x30db1f0800000000000000000000000000000000000000000000000000000000;\n        var_i = 0xb05e92fa00000000000000000000000000000000000000000000000000000000;\n        var_b = 0x4ce630e100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_j = 0x20;\n        var_k = 0x1f;\n        var_l = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n    }",
    "llm_output": "function mintForOG(uint256 amount, bytes32[] calldata merkleProof) public payable {\n    // Ensure the sale phase is active for OG minting\n    if (salePhase != 1) {\n        revert SaleNotInWLOGPhase();\n    }\n\n    // Verify the Merkle proof against the OG Merkle root\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n    bool isValidProof = verifyMerkleProof(merkleProof, merkleRootOG, leaf);\n    if (!isValidProof) {\n        revert InvalidMerkleProof();\n    }\n\n    // Ensure the requested amount does not exceed the maximum allowed per transaction\n    if (amount > maxBatchSizeForWL) {\n        revert ExceedsMaxPerTransaction();\n    }\n\n    // Ensure the total minted tokens for the sender do not exceed the maximum allowed per address\n    uint256 totalMintedBySender = _mintedPerAddress[msg.sender];\n    if (totalMintedBySender + amount > maxPerAddressDuringMint) {\n        revert ExceedsMaxPerAddress();\n    }\n\n    // Ensure the total supply does not exceed the maximum collection size\n    if (totalSupply() + amount > collectionSize) {\n        revert ExceedsMaxSupply();\n    }\n\n    // Ensure the payment sent matches the required amount\n    uint256 requiredPayment = amount * OG_PRICE;\n    if (msg.value < requiredPayment) {\n        revert InsufficientPayment();\n    }\n\n    // Update the minted count for the sender\n    _mintedPerAddress[msg.sender] += amount;\n\n    // Mint the tokens to the sender\n    _safeMint(msg.sender, amount);\n}",
    "ground_truth": "function mintForOG(uint256 amount, bytes32[] calldata merkleProof) external payable nonReentrant {\\n        if (salePhase != 1) revert SaleNotInWLOGPhase();\\n        if (!_verifyMerkleProof(msg.sender, merkleProof, merkleRootOG)) revert InvalidMerkleProof();\\n        if (amount > maxPerAddressDuringMint) revert ExceedsMaxPerTransaction();\\n        if (_mintedPerAddress[msg.sender] + amount > maxPerAddressDuringMint) revert ExceedsMaxPerAddress();\\n        if (totalSupply() + amount > AmountForPublic) revert ExceedsMaxPerPublic();\\n        \\n        uint256 totalPrice = OG_PRICE * amount;\\n        if (msg.value < totalPrice) revert InsufficientPayment();\\n        \\n        _mintedPerAddress[msg.sender] += amount;\\n        _safeMint(msg.sender, amount);\\n    }"
}