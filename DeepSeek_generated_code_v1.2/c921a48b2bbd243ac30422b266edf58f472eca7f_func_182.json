{
    "contract_address": "0xc921a48b2bBd243aC30422B266edf58F472Eca7F",
    "heimdall_input": "function burnFrom(address arg0, uint256 arg1) public {\n        require(arg0 == (address(arg0)));\n        require(bytes1(burnEnable), \"Not enough $DINO.\");\n        require((lCost == ((lCost * arg1) / arg1)) | !arg1, \"Not enough $DINO.\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        address var_a = address(arg0);\n        uint256 var_c = 0;\n        require(!(storage_map_i[var_a] < (lCost * arg1)), \"Not enough $DINO.\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x11;\n        var_g = 0x4e6f7420656e6f756768202444494e4f2e000000000000000000000000000000;\n        require((lCost == ((lCost * arg1) / arg1)) | !arg1, \"ERC20: burn amount exceeds balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = address(arg0);\n        var_c = 0x01;\n        var_a = address(msg.sender);\n        var_c = keccak256(var_a);\n        require(storage_map_i[var_a] == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"ERC20: burn amount exceeds balance\");\n        require(address(arg0), \"ERC20: burn amount exceeds balance\");\n        var_a = address(arg0);\n        var_c = 0;\n        require(!(storage_map_i[var_a] < (lCost * arg1)), \"ERC20: burn amount exceeds balance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a206275726e20616d6f756e7420657863656564732062616c616e;\n        var_h = 0x6365000000000000000000000000000000000000000000000000000000000000;\n        var_a = address(arg0);\n        var_c = 0;\n        storage_map_i[var_a] = storage_map_i[var_a] - (lCost * arg1);\n        totalSupply = totalSupply - (lCost * arg1);\n        uint256 var_d = lCost * arg1;\n        emit Transfer(address(arg0), 0, lCost * arg1);\n        var_a = address(arg0);\n        var_c = 0x19;\n        require(!(storage_map_i[var_a] > (arg1 + storage_map_i[var_a])), \"ERC20: burn from the zero address\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        storage_map_i[var_a] = arg1 + storage_map_i[var_a];\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x21;\n        var_g = 0x45524332303a206275726e2066726f6d20746865207a65726f20616464726573;\n        var_h = 0x7300000000000000000000000000000000000000000000000000000000000000;\n        require(!(storage_map_i[var_a] < (lCost * arg1)), \"ERC20: insufficient allowance\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1d;\n        var_g = 0x45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000;\n        require(address(arg0), \"ERC20: approve to the zero address\");\n        require(address(msg.sender), \"ERC20: approve to the zero address\");\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x22;\n        var_g = 0x45524332303a20617070726f766520746f20746865207a65726f206164647265;\n        var_h = 0x7373000000000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x24;\n        var_g = 0x45524332303a20617070726f76652066726f6d20746865207a65726f20616464;\n        var_h = 0x7265737300000000000000000000000000000000000000000000000000000000;\n        var_d = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_e = 0x20;\n        var_f = 0x1e;\n        var_g = 0x2444494e4f206275726e206973206e6f7420656e61626c6564207965742e0000;\n    }",
    "llm_output": "function burnFrom(address account, uint256 amount) public {\n    require(account == address(account));\n    require(burnEnable, \"Not enough $DINO.\");\n    require((lCost == (lCost * amount) / amount) || amount == 0, \"Not enough $DINO.\");\n    \n    require(_balances[account] >= lCost * amount, \"Not enough $DINO.\");\n    \n    require((lCost == (lCost * amount) / amount) || amount == 0, \"ERC20: burn amount exceeds balance\");\n    require(account != address(0), \"ERC20: burn amount exceeds balance\");\n    \n    if (_allowances[account][msg.sender] != type(uint256).max) {\n        require(_allowances[account][msg.sender] >= lCost * amount, \"ERC20: insufficient allowance\");\n        _allowances[account][msg.sender] -= lCost * amount;\n    }\n    \n    require(_balances[account] >= lCost * amount, \"ERC20: burn amount exceeds balance\");\n    _balances[account] -= lCost * amount;\n    totalSupply -= lCost * amount;\n    emit Transfer(account, address(0), lCost * amount);\n    \n    require(!(_balances[account] > amount + _balances[account]), \"ERC20: burn from the zero address\");\n    _balances[account] += amount;\n    \n    require(_allowances[account][msg.sender] >= lCost * amount, \"ERC20: insufficient allowance\");\n    require(account != address(0), \"ERC20: approve to the zero address\");\n    require(msg.sender != address(0), \"ERC20: approve to the zero address\");\n    revert(\"ERC20: insufficient allowance\");\n}",
    "ground_truth": "function burnFrom(address account, uint256 amount) public override {\\r\\n        require(burnEnable, \\\"$DINO burn is not enabled yet.\\\");\\r\\n        require(balanceOf(account) >= amount*lCost, \\\"Not enough $DINO.\\\");\\r\\n\\r\\n        super.burnFrom(account, amount*lCost);\\r\\n        addressLives[account] += amount;\\r\\n    }"
}