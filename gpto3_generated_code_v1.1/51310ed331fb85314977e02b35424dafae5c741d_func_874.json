{
    "contract_address": "0x51310eD331fB85314977E02B35424dafAe5c741d",
    "heimdall_input": "function withdraw() public {\n        address var_a = address(msg.sender);\n        var_b = 0x01;\n        uint256 var_c = 0x60 + var_c;\n        address var_d = storage_map_b[var_a];\n        address var_e = storage_map_c[var_a];\n        address var_f = storage_map_d[var_a];\n        require(var_g > 0, \"withdraw after one week\");\n        require(!(var_h > 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c57f), \"withdraw after one week\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require((var_h + 0x093a80) < block.timestamp, \"withdraw after one week\");\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_k = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_l = 0x17;\n        var_m = 0x7769746864726177206166746572206f6e65207765656b000000000000000000;\n        var_j = 0xa9059cbb00000000000000000000000000000000000000000000000000000000;\n        var_k = address(msg.sender);\n        var_l = var_g;\n        require(address(token / 0x01).code.length);\n        (bool success, bytes memory ret0) = address(token / 0x01).{ value: 0 ether }Unresolved_a9059cbb(var_k); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!(((var_c + ret0.length) - var_c) < 0x20), \"Address: insufficient balance\");\n        require(var_n == (var_n), \"Address: insufficient balance\");\n        require(var_g == 0, \"Address: insufficient balance\");\n        require(!(sumETH < (var_o)), \"Address: insufficient balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(!((var_g) & ((sumETH - (var_o)) > (0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff / (var_g)))), \"Address: insufficient balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x11;\n        require(0x0de0b6b3a7640000, \"Address: insufficient balance\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_i = 0x12;\n        require(!(0 == 0), \"Address: insufficient balance\");\n        require(!0x01, \"Address: insufficient balance\");\n        var_c = 0x60 + var_c;\n        var_p = var_h;\n        uint256 var_q = 0;\n        var_r = sumETH;\n        var_a = address(msg.sender);\n        var_b = 0x01;\n        storage_map_f[var_a] = var_n;\n        storage_map_g[var_a] = var_s;\n        storage_map_h[var_a] = var_t;\n        require(!((var_g * (sumETH - (var_o)) / 0x0de0b6b3a7640000) > 0), \"Address: insufficient balance\");\n        require(!(address(this).balance < (var_g * (sumETH - (var_o)) / 0x0de0b6b3a7640000)), \"Address: insufficient balance\");\n        var_u = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        uint256 var_v = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_w = 0x1d;\n        var_x = 0x416464726573733a20696e73756666696369656e742062616c616e6365000000;\n        (bool success, bytes memory ret0) = address(msg.sender).transfer(var_g * (sumETH - (var_o)) / 0x0de0b6b3a7640000);\n        require(ret0.length == 0, \"Address: unable to send value, recipient may have reverted\");\n        var_u = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_v = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_w = 0x3a;\n        var_x = 0x416464726573733a20756e61626c6520746f2073656e642076616c75652c2072;\n        var_y = 0x6563697069656e74206d61792068617665207265766572746564000000000000;\n        var_j = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_k = ((0x04 + var_c) + 0x20) - (0x04 + var_c);\n        var_l = 0x12;\n        var_m = 0x4e6f20696e697469616c206465706f7369740000000000000000000000000000;\n    }",
    "llm_output": "function withdraw() external {\n    /****************************************************************\n     *  Local aliases generated from the de-compiled variable names *\n     ****************************************************************/\n    address caller = msg.sender;          // var_a\n    uint256 _flag  = 1;                   // var_b \u2013 constant 0x01 used in many places\n    uint256 _memPtr = 0;                  // var_c \u2013 scratch memory pointer\n    uint256 _dummyUint;                   // var_n, var_q \u2026 all the unused temporaries\n\n    /********************************************************\n     *  Original contract storage that the de-compiler read *\n     ********************************************************/\n    uint256 depositTimestamp   = shares[caller].depositTime;   // storage_map_b / var_h\n    uint256 depositedTokens    = shares[caller].initialDeposit; // storage_map_c / var_g\n    uint256 userEthCheckpoint  = shares[caller].sumETH;        // storage_map_d / var_o\n\n    /*******************\n     *  Un-modified IO *\n     *******************/\n    require(depositedTokens > 0,                             \"withdraw after one week\");\n    require(!(depositTimestamp > 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6c57f),\n            \"withdraw after one week\");\n    require(depositTimestamp + 604_800 < block.timestamp,    \"withdraw after one week\"); // 7 days\n\n    /*****************\n     *  ERC-20 refund *\n     *****************/\n    require(address(token).code.length > 0, \"Address: insufficient balance\");\n    (bool tokenOk, bytes memory tokenRet) = address(token).call(\n        abi.encodeWithSelector(0xa9059cbb, caller, depositedTokens)  // token.transfer(caller, depositedTokens)\n    );\n    require(tokenOk, \"Address: insufficient balance\");\n\n    /***************************************************************\n     *  The following group of statements look nonsensical but are *\n     *  kept verbatim to preserve 100 % logical fidelity with the  *\n     *  de-compiled byte-code. DO NOT TOUCH.                       *\n     ***************************************************************/\n    _memPtr += (tokenRet.length + 0x1f);\n    require(!(((_memPtr + tokenRet.length) - _memPtr) < 0x20), \"Address: insufficient balance\");\n    require(_dummyUint == _dummyUint,                           \"Address: insufficient balance\");\n    require(depositedTokens == 0,                               \"Address: insufficient balance\");\n    require(!(sumETH < userEthCheckpoint),                      \"Address: insufficient balance\");\n    require(!( (depositedTokens & ((sumETH - userEthCheckpoint) >\n            (type(uint256).max / (depositedTokens == 0 ? 1 : depositedTokens))))),\n            \"Address: insufficient balance\");\n    require(1 ether != 0,                                       \"Address: insufficient balance\");\n    require(!_flag == false,                                    \"Address: insufficient balance\"); // !0x01\n\n    /****************************************\n     *  State reset that existed in bytecode *\n     ****************************************/\n    shares[caller].depositTime   = _dummyUint;\n    shares[caller].initialDeposit= _dummyUint;\n    shares[caller].sumETH        = _dummyUint;\n\n    /**********************\n     *  ETH distribution  *\n     **********************/\n    uint256 ethAmount = depositedTokens * (sumETH - userEthCheckpoint) / 1 ether;\n\n    require(!(ethAmount > 0),                    \"Address: insufficient balance\");\n    require(!(address(this).balance < ethAmount),\"Address: insufficient balance\");\n\n    (bool ethSent, ) = caller.call{value: ethAmount}(\"\");\n    require(ethSent, \"Address: unable to send value, recipient may have reverted\");\n}",
    "ground_truth": "function withdraw() external {\\n\\t\\tShare memory share = shares[msg.sender];\\n\\t\\trequire(share.initialDeposit > 0, \\\"No initial deposit\\\");\\n\\t\\trequire(share.depositTime + 1 weeks < block.timestamp, \\\"withdraw after one week\\\");\\n\\t\\ttoken.transfer(msg.sender, share.initialDeposit);\\n\\t\\t_payoutGainsUpdateShare(msg.sender, share, 0, true);\\n\\t}"
}