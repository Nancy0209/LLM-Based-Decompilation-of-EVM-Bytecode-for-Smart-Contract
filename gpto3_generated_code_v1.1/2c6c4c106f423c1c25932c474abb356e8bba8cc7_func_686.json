{
    "contract_address": "0x2C6C4c106F423c1C25932c474Abb356e8BBa8cC7",
    "heimdall_input": "function grantRole(bytes32 arg0, address arg1) public payable {\n        require(arg1 == (address(arg1)));\n        uint256 var_a = arg0;\n        var_b = 0x0b;\n        var_a = storage_map_e[var_a];\n        var_b = 0x0b;\n        var_a = address(msg.sender);\n        uint256 var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), \"Strings: hex length insufficient\");\n        var_a = arg0;\n        var_b = 0x0b;\n        var_a = address(arg1);\n        var_b = keccak256(var_a);\n        require(bytes1(storage_map_b[var_a]), \"Strings: hex length insufficient\");\n        var_a = arg0;\n        var_b = 0x0b;\n        var_a = address(arg1);\n        var_b = keccak256(var_a);\n        storage_map_b[var_a] = 0x01 | (uint248(storage_map_b[var_a]));\n        emit RoleGranted(arg0, address(arg1), address(msg.sender));\n        require(!(0x02 & (0x14 > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), \"Strings: hex length insufficient\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(0x02 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd7), \"Strings: hex length insufficient\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(0x2a > 0xffffffffffffffff), \"Strings: hex length insufficient\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x41;\n        var_d = 0x2a;\n        uint256 var_e = var_e + 0x60;\n        require(!0x2a, \"Strings: hex length insufficient\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_f = 0x3000000000000000000000000000000000000000000000000000000000000000;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        var_g = 0x7800000000000000000000000000000000000000000000000000000000000000;\n        require(!(0x02 & (0x14 > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), \"Strings: hex length insufficient\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(0x01 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd7), \"Strings: hex length insufficient\");\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n        require(!(0x29 > 0x01), \"Strings: hex length insufficient\");\n        require(!(address(msg.sender)), \"Strings: hex length insufficient\");\n        var_h = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n        var_i = 0x20;\n        var_j = 0x20;\n        var_k = 0x537472696e67733a20686578206c656e67746820696e73756666696369656e74;\n        require(bytes1(address(msg.sender)) < 0x10);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        require(0x29 < var_e.length);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x32;\n        bytes1 var_l = (bytes1(0x3031323334353637383961626364656600000000000000000000000000000000 << 0xf8));\n        require(0x29);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_c = 0x11;\n    }",
    "llm_output": "function grantRole(bytes32 role, address account) public payable {\n    /* ---------------------------- Original Checks --------------------------- */\n    // 1. Address self\u2013equality (always true, preserved for fidelity).\n    require(account == address(account));\n\n    /* --------------------------- Storage Read Ops --------------------------- */\n    // These storage mappings were referenced in the de-compiled output.\n    // Their concrete meanings are unknown, but we keep the interactions intact.\n    uint256 _unusedRoleData = storage_map_e[role];\n\n    /* ------------------------- Permission Validations ------------------------ */\n    uint256 senderHash  = uint256(keccak256(abi.encodePacked(msg.sender)));\n    require(bytes1(storage_map_b[senderHash]) != bytes1(0), \"Strings: hex length insufficient\");\n\n    uint256 accountHash = uint256(keccak256(abi.encodePacked(account)));\n    require(bytes1(storage_map_b[accountHash]) != bytes1(0), \"Strings: hex length insufficient\");\n\n    /* ------------------------------ Role Grant ------------------------------ */\n    storage_map_b[accountHash] = uint256(storage_map_b[accountHash]) | uint256(0x01);\n    emit RoleGranted(role, account, msg.sender);\n\n    /* --------------------------- Misc. Decompiler Ops ----------------------- */\n    // The following \u201crequires\u201d mimick the bizarre, always-true checks that were\n    // present in the de-compiled bytecode. They are kept verbatim.\n    require(\n        (0x02 & (0x14 > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ? 1 : 0)) == 0,\n        \"Strings: hex length insufficient\"\n    );\n    require(!(0x02 > 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd7), \"Strings: hex length insufficient\");\n    require(!(0x2a > 0xffffffffffffffff), \"Strings: hex length insufficient\");\n\n    /* -------------------------- Guaranteed Reversion ------------------------ */\n    // The remainder of the de-compiled code consisted of operations that would\n    // inevitably fail.  Per instruction, we replace that unreachable section\n    // with a single, explicit revert.\n    revert(\"Decompiler artifact\");\n}",
    "ground_truth": "function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked}"
}