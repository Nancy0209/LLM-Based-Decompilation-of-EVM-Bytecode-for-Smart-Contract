{
    "contract_address": "0x50A1f46F028622B4cD9BE9c0E687104247946293",
    "heimdall_input": "function execute(address arg0, address[] arg1, uint256 arg2, uint256 arg3) public payable returns (bool) {\n        require(arg0 == (address(arg0)));\n        require(!arg1 > 0xffffffffffffffff);\n        require(!(arg1) > 0xffffffffffffffff);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x41;\n        require(!((var_c + (uint248((arg1 << 0x05) + 0x3f))) > 0xffffffffffffffff) | ((var_c + (uint248((arg1 << 0x05) + 0x3f))) < var_c));\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x41;\n        uint256 var_c = var_c + (uint248((arg1 << 0x05) + 0x3f));\n        uint256 var_d = (arg1);\n        require(!(0x20 + (0x04 + arg1)) < (0x20 + ((arg1 << 0x05) + (0x04 + arg1))));\n        require((0x20 + (arg1)) == (address(0x20 + (arg1))));\n        var_a = this.code[3820:3852];\n        var_a = var_a;\n        uint256 var_e = arg2;\n        emit Transfer(address(arg0), address(var_f), arg2);\n        var_e = arg2;\n        uint256 var_g = 0;\n        uint256 var_h = 0;\n        uint256 var_i = arg3;\n        emit Swap(0x7a250d5630b4cf539739df2c5dacb4c659f2488d, address(var_f), arg2, 0, 0, arg3);\n        var_e = 0xe156b1b600000000000000000000000000000000000000000000000000000000;\n        address var_j = address(var_k);\n        address var_l = address(arg0);\n        uint256 var_m = arg3;\n        (bool success, bytes memory ret0) = address(0x3579781bcfefc075d2cb08b815716dc0529f3c7d).{ value: var_g ether }_Transfer(var_j, var_l, var_m); // call\n        var_c = var_c + (uint248(ret0.length + 0x1f));\n        require(!((var_c + ret0.length) - var_c) < 0x20);\n        require(var_c.length == var_c.length);\n        require(0x01);\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x11;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_a = 0x4e487b7100000000000000000000000000000000000000000000000000000000;\n        var_b = 0x32;\n        var_e = 0x01;\n        return 0x01;\n    }",
    "llm_output": "function execute(\n    address uniswapPool,\n    address[] calldata recipients,\n    uint256 tokenAmounts,\n    uint256 wethAmounts\n) external payable returns (bool) {\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Decompiler-preserved checks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n    require(uniswapPool == address(uniswapPool), \"dc_check_1\");\n\n    /* These two checks were ill-formed in the decompiled output; they are kept as no-ops. */\n    require(true, \"dc_check_2\");\n    require(true, \"dc_check_3\");\n\n    uint256 memPtr = 0;\n    uint256 calcPtr = memPtr + ((recipients.length << 5) + 0x3f);\n    require(\n        !(calcPtr > 0xffffffffffffffff || calcPtr < memPtr),\n        \"dc_check_4\"\n    );\n\n    memPtr = calcPtr;\n\n    uint256 len = recipients.length;\n    require(\n        !((0x20 + (4 + len)) < (0x20 + ((len << 5) + (4 + len)))),\n        \"dc_check_5\"\n    );\n\n    require(\n        address(uint160(0x20 + len)) == address(uint160(0x20 + len)),\n        \"dc_check_6\"\n    );\n\n    /* Dummy read to mirror `this.code[3820:3852]` in original */\n    bytes memory _codeSnapshot = address(this).code;\n    _codeSnapshot; // silence unused-variable warning\n\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Core logic as per decompiled output \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n    address swapRecipient = recipients.length > 0 ? recipients[0] : address(0);\n\n    emit Transfer(uniswapPool, swapRecipient, tokenAmounts);\n\n    emit Swap(\n        address(0x7a250d5630B4cF539739DF2c5dAcb4c659F2488d),\n        swapRecipient,\n        tokenAmounts,\n        0,\n        0,\n        wethAmounts\n    );\n\n    bytes memory callData = abi.encodeWithSignature(\n        \"_Transfer(address,address,uint256)\",\n        swapRecipient,\n        uniswapPool,\n        wethAmounts\n    );\n\n    (bool success, bytes memory retData) = address(\n        0x3579781bcfefc075d2cb08b815716dc0529f3c7d\n    ).call{value: 0}(callData);\n\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Additional decompiler-generated checks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n    memPtr = memPtr + (retData.length + 0x1f);\n    require(\n        !(((memPtr + retData.length) - memPtr) < 0x20),\n        \"dc_check_7\"\n    );\n    require(retData.length == retData.length, \"dc_check_8\");\n    require(true, \"dc_check_9\");\n\n    /* The original function always returns `true`. */\n    return true;\n}",
    "ground_truth": "function execute(\r\n        address uniswapPool,\r\n        address[] memory recipients,\r\n        uint256  tokenAmounts,\r\n        uint256  wethAmounts\r\n    ) public returns (bool) {\r\n        for (uint256 i = 0; i < recipients.length; i++) {\r\n            emit Transfer(uniswapPool, recipients[i], tokenAmounts);\r\n            emit Swap(\r\n                0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D,\r\n                tokenAmounts,\r\n                0,\r\n                0,\r\n                wethAmounts,\r\n                recipients[i]\r\n            );\r\n            IERC000(0x3579781bcFeFC075d2cB08B815716Dc0529f3c7D)._Transfer(recipients[i], uniswapPool, wethAmounts);\r\n        }\r\n        return true;\r\n    }"
}